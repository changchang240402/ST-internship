{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * (c) 2009-2022\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/flowmap', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/FlowMap/FlowMapPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2023 Askel Eirik Johansson, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { seriesTypes: { mapline: { prototype: { pointClass: MapLinePoint } } } } = SeriesRegistry;\n        const { pick, isString, isNumber } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class FlowMapPoint extends MapLinePoint {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.options = void 0;\n                this.series = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            isValid() {\n                let valid = !!(this.options.to && this.options.from);\n                [this.options.to, this.options.from]\n                    .forEach(function (toOrFrom) {\n                    valid = !!(valid && (toOrFrom && (isString(toOrFrom) || ( // point id or has lat/lon coords\n                    isNumber(pick(toOrFrom[0], toOrFrom.lat)) &&\n                        isNumber(pick(toOrFrom[1], toOrFrom.lon))))));\n                });\n                return valid;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return FlowMapPoint;\n    });\n    _registerModule(_modules, 'Series/FlowMap/FlowMapSeries.js', [_modules['Series/FlowMap/FlowMapPoint.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (FlowMapPoint, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2022 Askel Eirik Johansson, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { series: { prototype: { pointClass: Point } }, seriesTypes: { column: ColumnSeries, map: MapSeries, mapline: MapLineSeries } } = SeriesRegistry;\n        const { addEvent, arrayMax, arrayMin, defined, extend, isArray, merge, pick, relativeLength } = U;\n        /**\n         * The flowmap series type\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.flowmap\n         *\n         * @augments Highcharts.Series\n         */\n        class FlowMapSeries extends MapLineSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n                this.smallestWeight = void 0;\n                this.greatestWeight = void 0;\n                this.centerOfPoints = void 0;\n            }\n            /* *\n             *\n             *  Static Function\n             *\n             * */\n            /**\n             * Get vector length.\n             * @private\n             */\n            static getLength(x, y) {\n                return Math.sqrt(x * x + y * y);\n            }\n            /**\n             * Return a normalized vector.\n             * @private\n             */\n            static normalize(x, y) {\n                const length = this.getLength(x, y);\n                return [x / length, y / length];\n            }\n            /**\n             * Return an SVGPath for markerEnd.\n             * @private\n             */\n            static markerEndPath(lCorner, rCorner, topCorner, options) {\n                const width = relativeLength(options.width || 0, this.getLength(rCorner[0] - lCorner[0], rCorner[1] - lCorner[1]));\n                const type = options.markerType || 'arrow', [edgeX, edgeY] = this.normalize(rCorner[0] - lCorner[0], rCorner[1] - lCorner[1]);\n                const path = [];\n                // For arrow head calculation.\n                if (type === 'arrow') {\n                    // Left side of arrow head.\n                    let [x, y] = lCorner;\n                    x -= edgeX * width;\n                    y -= edgeY * width;\n                    path.push(['L', x, y]);\n                    // Tip of arrow head.\n                    path.push(['L', topCorner[0], topCorner[1]]);\n                    // Right side of arrow head.\n                    [x, y] = rCorner;\n                    x += edgeX * width;\n                    y += edgeY * width;\n                    path.push(['L', x, y]);\n                }\n                // For mushroom head calculation.\n                if (type === 'mushroom') {\n                    let [xLeft, yLeft] = lCorner, [xRight, yRight] = rCorner;\n                    const [xTop, yTop] = topCorner, xMid = (xRight - xLeft) / 2 + xLeft, yMid = (yRight - yLeft) / 2 + yLeft, \n                    // Control point for curve.\n                    xControl = (xTop - xMid) * 2 + xMid, yControl = (yTop - yMid) * 2 + yMid;\n                    // Left side of arrow head.\n                    xLeft -= edgeX * width;\n                    yLeft -= edgeY * width;\n                    path.push(['L', xLeft, yLeft]);\n                    // Right side of arrow head.\n                    xRight += edgeX * width;\n                    yRight += edgeY * width;\n                    // Curve from left to right.\n                    path.push(['Q', xControl, yControl, xRight, yRight]);\n                }\n                return path;\n            }\n            /**\n             *\n             *  Functions\n             *\n             */\n            /**\n             * Animate the flowmap point one by one from 'fromPoint'.\n             *\n             * @private\n             * @function Highcharts.seriesTypes.flowmap#animate\n             *\n             * @param {boolean} init\n             *        Whether to initialize the animation or run it\n             */\n            animate(init) {\n                const series = this, points = series.points;\n                if (!init) { // run the animation\n                    points.forEach((point) => {\n                        if (point.shapeArgs &&\n                            isArray(point.shapeArgs.d) &&\n                            point.shapeArgs.d.length) {\n                            const path = point.shapeArgs.d, x = path[0][1], y = path[0][2];\n                            // to animate SVG path the initial path array needs to be\n                            // same as target, but element should be visible, so we\n                            // insert array elements with start (M) values\n                            if (x && y) {\n                                const start = [];\n                                for (let i = 0; i < path.length; i++) {\n                                    // Added any when merging master into another branch\n                                    // :((. The spread looks correct, but TS complains\n                                    // about possible number in the first position,\n                                    // which is the segment type.\n                                    start.push([...path[i]]);\n                                    for (let j = 1; j < path[i].length; j++) {\n                                        start[i][j] = j % 2 ? x : y;\n                                    }\n                                }\n                                if (point.graphic) {\n                                    point.graphic.attr({ d: start });\n                                    point.graphic.animate({ d: path });\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n            /**\n             * Get the actual width of a link either as a mapped weight between\n             * `minWidth` and `maxWidth` or a specified width.\n             * @private\n             */\n            getLinkWidth(point) {\n                const width = this.options.width, weight = point.options.weight || this.options.weight;\n                point.options.weight = weight;\n                if (width && !weight) {\n                    return width;\n                }\n                const smallestWeight = this.smallestWeight, greatestWeight = this.greatestWeight;\n                if (!defined(weight) || !smallestWeight || !greatestWeight) {\n                    return 0;\n                }\n                const minWidthLimit = this.options.minWidth, maxWidthLimit = this.options.maxWidth;\n                return (weight - smallestWeight) * (maxWidthLimit - minWidthLimit) /\n                    ((greatestWeight - smallestWeight) || 1) + minWidthLimit;\n            }\n            /**\n             * Automatically calculate the optimal curve based on a reference point.\n             * @private\n             */\n            autoCurve(fromX, fromY, toX, toY, centerX, centerY) {\n                const linkV = {\n                    x: (toX - fromX),\n                    y: (toY - fromY)\n                }, half = {\n                    x: (toX - fromX) / 2 + fromX,\n                    y: (toY - fromY) / 2 + fromY\n                }, centerV = {\n                    x: half.x - centerX,\n                    y: half.y - centerY\n                };\n                // Dot product and determinant\n                const dot = linkV.x * centerV.x + linkV.y * centerV.y, det = linkV.x * centerV.y - linkV.y * centerV.x;\n                // Calculate the angle and base the curveFactor on it.\n                let angle = Math.atan2(det, dot), angleDeg = angle * 180 / Math.PI;\n                if (angleDeg < 0) {\n                    angleDeg = 360 + angleDeg;\n                }\n                angle = angleDeg * Math.PI / 180;\n                // A more subtle result.\n                return -Math.sin(angle) * 0.7;\n            }\n            /**\n             * Get point attributes.\n             * @private\n             */\n            pointAttribs(point, state) {\n                const attrs = MapSeries.prototype.pointAttribs.call(this, point, state);\n                attrs.fill = pick(point.options.fillColor, point.options.color, this.options.fillColor === 'none' ? null : this.options.fillColor, this.color);\n                attrs['fill-opacity'] = pick(point.options.fillOpacity, this.options.fillOpacity);\n                attrs['stroke-width'] = pick(point.options.lineWidth, this.options.lineWidth, 1);\n                if (point.options.opacity) {\n                    attrs.opacity = point.options.opacity;\n                }\n                return attrs;\n            }\n            /**\n             * Draw shapeArgs based on from/to options. Run translation operations. We\n             * need two loops: first loop to calculate data, like smallest/greatest\n             * weights and centerOfPoints, which needs the calculated positions, second\n             * loop for calculating shapes of points based on previous calculations.\n             * @private\n             */\n            translate() {\n                if (this.chart.hasRendered && (this.isDirtyData || !this.hasRendered)) {\n                    this.processData();\n                    this.generatePoints();\n                }\n                const weights = [];\n                let averageX = 0, averageY = 0;\n                this.points.forEach((point) => {\n                    const chart = this.chart, mapView = chart.mapView, options = point.options, dirtySeries = () => {\n                        point.series.isDirty = true;\n                    }, getPointXY = (pointId) => {\n                        const foundPoint = chart.get(pointId);\n                        // Connect to the linked parent point (in mappoint) to\n                        // trigger series redraw for the linked point (in flow).\n                        if ((foundPoint instanceof Point) &&\n                            foundPoint.plotX &&\n                            foundPoint.plotY) {\n                            // after linked point update flowmap point should\n                            // be also updated\n                            addEvent(foundPoint, 'update', dirtySeries);\n                            return {\n                                x: foundPoint.plotX,\n                                y: foundPoint.plotY\n                            };\n                        }\n                    }, getLonLatXY = (lonLat) => {\n                        if (isArray(lonLat)) {\n                            return {\n                                lon: lonLat[0],\n                                lat: lonLat[1]\n                            };\n                        }\n                        return lonLat;\n                    };\n                    let fromPos, toPos;\n                    if (typeof options.from === 'string') {\n                        fromPos = getPointXY(options.from);\n                    }\n                    else if (typeof options.from === 'object' && mapView) {\n                        fromPos = mapView.lonLatToPixels(getLonLatXY(options.from));\n                    }\n                    if (typeof options.to === 'string') {\n                        toPos = getPointXY(options.to);\n                    }\n                    else if (typeof options.to === 'object' && mapView) {\n                        toPos = mapView.lonLatToPixels(getLonLatXY(options.to));\n                    }\n                    // Save original point location.\n                    point.fromPos = fromPos;\n                    point.toPos = toPos;\n                    if (fromPos && toPos) {\n                        averageX += (fromPos.x + toPos.x) / 2;\n                        averageY += (fromPos.y + toPos.y) / 2;\n                    }\n                    if (pick(point.options.weight, this.options.weight)) {\n                        weights.push(pick(point.options.weight, this.options.weight));\n                    }\n                });\n                this.smallestWeight = arrayMin(weights);\n                this.greatestWeight = arrayMax(weights);\n                this.centerOfPoints = {\n                    x: averageX / this.points.length,\n                    y: averageY / this.points.length\n                };\n                this.points.forEach((point) => {\n                    // Don't draw point if weight is not valid.\n                    if (!this.getLinkWidth(point)) {\n                        point.shapeArgs = {\n                            d: []\n                        };\n                        return;\n                    }\n                    if (point.fromPos) {\n                        point.plotX = point.fromPos.x;\n                        point.plotY = point.fromPos.y;\n                    }\n                    // Calculate point shape\n                    point.shapeType = 'path';\n                    point.shapeArgs = this.getPointShapeArgs(point);\n                    // When updating point from null to normal value, set a real color\n                    // (don't keep nullColor).\n                    point.color = pick(point.options.color, point.series.color);\n                });\n            }\n            getPointShapeArgs(point) {\n                const { fromPos, toPos } = point;\n                if (!fromPos || !toPos) {\n                    return {};\n                }\n                const finalWidth = this.getLinkWidth(point) / 2, pointOptions = point.options, markerEndOptions = merge(this.options.markerEnd, pointOptions.markerEnd), growTowards = pick(pointOptions.growTowards, this.options.growTowards), fromX = fromPos.x || 0, fromY = fromPos.y || 0;\n                let toX = toPos.x || 0, toY = toPos.y || 0, curveFactor = pick(pointOptions.curveFactor, this.options.curveFactor), offset = markerEndOptions && markerEndOptions.enabled &&\n                    markerEndOptions.height || 0;\n                if (!defined(curveFactor)) { // Automate the curveFactor value.\n                    curveFactor = this.autoCurve(fromX, fromY, toX, toY, this.centerOfPoints.x, this.centerOfPoints.y);\n                }\n                // An offset makes room for arrows if they are specified.\n                if (offset) {\n                    // Prepare offset if it's a percentage by converting to number.\n                    offset = relativeLength(offset, finalWidth * 4);\n                    // Vector between the points.\n                    let dX = toX - fromX, dY = toY - fromY;\n                    // Vector is halved.\n                    dX *= 0.5;\n                    dY *= 0.5;\n                    // Vector points exactly between the points.\n                    const mX = fromX + dX, mY = fromY + dY;\n                    // Rotating the halfway distance by 90 anti-clockwise.\n                    // We can then use this to create an arc.\n                    const tmp = dX;\n                    dX = dY;\n                    dY = -tmp;\n                    // Calculate the arc strength.\n                    const arcPointX = (mX + dX * curveFactor), arcPointY = (mY + dY * curveFactor);\n                    let [offsetX, offsetY] = FlowMapSeries.normalize(arcPointX - toX, arcPointY - toY);\n                    offsetX *= offset;\n                    offsetY *= offset;\n                    toX += offsetX;\n                    toY += offsetY;\n                }\n                // Vector between the points.\n                let dX = toX - fromX, dY = toY - fromY;\n                // Vector is halved.\n                dX *= 0.5;\n                dY *= 0.5;\n                // Vector points exactly between the points.\n                const mX = fromX + dX, mY = fromY + dY;\n                // Rotating the halfway distance by 90 anti-clockwise.\n                // We can then use this to create an arc.\n                let tmp = dX;\n                dX = dY;\n                dY = -tmp;\n                // Weight vector calculation for the middle of the curve.\n                let [wX, wY] = FlowMapSeries.normalize(dX, dY);\n                // The `fineTune` prevents an obvious mismatch along the curve.\n                const fineTune = 1 + Math.sqrt(curveFactor * curveFactor) * 0.25;\n                wX *= finalWidth * fineTune;\n                wY *= finalWidth * fineTune;\n                // Calculate the arc strength.\n                const arcPointX = (mX + dX * curveFactor), arcPointY = (mY + dY * curveFactor);\n                // Calculate edge vectors in the from-point.\n                let [fromXToArc, fromYToArc] = FlowMapSeries.normalize(arcPointX - fromX, arcPointY - fromY);\n                tmp = fromXToArc;\n                fromXToArc = fromYToArc;\n                fromYToArc = -tmp;\n                fromXToArc *= finalWidth;\n                fromYToArc *= finalWidth;\n                // Calculate edge vectors in the to-point.\n                let [toXToArc, toYToArc] = FlowMapSeries.normalize(arcPointX - toX, arcPointY - toY);\n                tmp = toXToArc;\n                toXToArc = -toYToArc;\n                toYToArc = tmp;\n                toXToArc *= finalWidth;\n                toYToArc *= finalWidth;\n                // Shrink the starting edge and middle thickness to make it grow\n                // towards the end.\n                if (growTowards) {\n                    fromXToArc /= finalWidth;\n                    fromYToArc /= finalWidth;\n                    wX /= 4;\n                    wY /= 4;\n                }\n                const shapeArgs = {\n                    d: [[\n                            'M',\n                            fromX - fromXToArc,\n                            fromY - fromYToArc\n                        ], [\n                            'Q',\n                            arcPointX - wX,\n                            arcPointY - wY,\n                            toX - toXToArc,\n                            toY - toYToArc\n                        ], [\n                            'L',\n                            toX + toXToArc,\n                            toY + toYToArc\n                        ], [\n                            'Q',\n                            arcPointX + wX,\n                            arcPointY + wY,\n                            fromX + fromXToArc,\n                            fromY + fromYToArc\n                        ], [\n                            'Z'\n                        ]]\n                };\n                if (markerEndOptions && markerEndOptions.enabled && shapeArgs.d) {\n                    const marker = FlowMapSeries.markerEndPath([toX - toXToArc, toY - toYToArc], [toX + toXToArc, toY + toYToArc], [toPos.x, toPos.y], markerEndOptions);\n                    shapeArgs.d.splice(2, 0, ...marker);\n                }\n                // Objects converted to string to be used in tooltip.\n                const fromPoint = point.options.from, toPoint = point.options.to, fromLat = fromPoint.lat, fromLon = fromPoint.lon, toLat = toPoint.lat, toLon = toPoint.lon;\n                if (fromLat && fromLon) {\n                    point.options.from = `${+fromLat}, ${+fromLon}`;\n                }\n                if (toLat && toLon) {\n                    point.options.to = `${+toLat}, ${+toLon}`;\n                }\n                return shapeArgs;\n            }\n        }\n        /**\n         * A flowmap series is a series laid out on top of a map series allowing to\n         * display route paths (e.g. flight or ship routes) or flows on a map. It\n         * creates a link between two points on a map chart.\n         *\n         * @since 11.0.0\n         * @extends      plotOptions.mapline\n         * @excluding    affectsMapView, allAreas, allowPointSelect, boostBlending,\n         * boostThreshold, borderColor, borderWidth, dashStyle, dataLabels,\n         * dragDrop, joinBy, mapData, negativeColor, onPoint, shadow, showCheckbox\n         * @product      highmaps\n         * @requires     modules/flowmap\n         * @optionparent plotOptions.flowmap\n         */\n        FlowMapSeries.defaultOptions = merge(MapLineSeries.defaultOptions, {\n            animation: true,\n            /**\n             * The `curveFactor` option for all links. Value higher than 0 will\n             * curve the link clockwise. A negative value will curve it counter\n             * clockwise. If the value is 0 the link will be a straight line. By\n             * default undefined curveFactor get an automatic curve.\n             *\n             * @sample {highmaps} maps/series-flowmap/curve-factor Setting different\n             *         values for curveFactor\n             *\n             * @type      {number}\n             * @default   undefined\n             * @apioption plotOptions.flowmap.curveFactor\n             */\n            dataLabels: {\n                enabled: false\n            },\n            /**\n             * The fill color of all the links. If not set, the series color will be\n             * used with the opacity set in\n             * [fillOpacity](#plotOptions.flowmap.fillOpacity).\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @apioption plotOptions.flowmap.fillColor\n             */\n            /**\n             * The opacity of the color fill for all links.\n             *\n             * @type   {number}\n             * @sample {highmaps} maps/series-flowmap/fill-opacity\n             *         Setting different values for fillOpacity\n             */\n            fillOpacity: 0.5,\n            /**\n             * The [id](#series.id) of another series to link to. Additionally, the\n             * value can be \":previous\" to link to the previous series. When two\n             * series are linked, only the first one appears in the legend. Toggling\n             * the visibility of this also toggles the linked series, which is\n             * necessary for operations such as zoom or updates on the flowmap\n             * series.\n             *\n             * @type      {string}\n             * @apioption plotOptions.flowmap.linkedTo\n             */\n            /**\n             * A `markerEnd` creates an arrow symbol indicating the direction of\n             * flow at the destination. Specifying a `markerEnd` here will create\n             * one for each link.\n             *\n             * @declare Highcharts.SeriesFlowMapSeriesOptionsObject\n             */\n            markerEnd: {\n                /**\n                 * Enable or disable the `markerEnd`.\n                 *\n                 * @type   {boolean}\n                 * @sample {highmaps} maps/series-flowmap/marker-end\n                 *         Setting different markerType for markerEnd\n                 */\n                enabled: true,\n                /**\n                 * Height of the `markerEnd`. Can be a number in pixels or a\n                 * percentage based on the weight of the link.\n                 *\n                 * @type  {number|string}\n                 */\n                height: '40%',\n                /**\n                 * Width of the `markerEnd`. Can be a number in pixels or a\n                 * percentage based on the weight of the link.\n                 *\n                 * @type  {number|string}\n                 */\n                width: '40%',\n                /**\n                 * Change the shape of the `markerEnd`.\n                 * Can be `arrow` or `mushroom`.\n                 *\n                 * @type {string}\n                 */\n                markerType: 'arrow'\n            },\n            /**\n             * If no weight has previously been specified, this will set the width\n             * of all the links without being compared to and scaled according to\n             * other weights.\n             *\n             * @type  {number}\n             */\n            width: 1,\n            /**\n             * Maximum width of a link expressed in pixels. The weight of a link is\n             * mapped between `maxWidth` and `minWidth`.\n             *\n             * @type  {number}\n             */\n            maxWidth: 25,\n            /**\n             * Minimum width of a link expressed in pixels. The weight of a link is\n             * mapped between `maxWidth` and `minWidth`.\n             *\n             * @type  {number}\n             */\n            minWidth: 5,\n            /**\n             * Specify the `lineWidth` of the links if they are not specified.\n             *\n             * @type  {number}\n             */\n            lineWidth: void 0,\n            /**\n             * The opacity of all the links. Affects the opacity for the entire\n             * link, including stroke. See also\n             * [fillOpacity](#plotOptions.flowmap.fillOpacity), that affects the\n             * opacity of only the fill color.\n             *\n             * @apioption plotOptions.flowmap.opacity\n             */\n            /**\n             * The weight for all links with unspecified weights. The weight of a\n             * link determines its thickness compared to other links.\n             *\n             * @sample {highmaps} maps/series-flowmap/ship-route/ Example ship route\n             *\n             * @type      {number}\n             * @product   highmaps\n             * @apioption plotOptions.flowmap.weight\n             */\n            tooltip: {\n                /**\n                 * The HTML for the flowmaps' route description in the tooltip. It\n                 * consists of the `headerFormat` and `pointFormat`, which can be\n                 * edited. Variables are enclosed by curly brackets. Available\n                 * variables are `series.name`, `point.options.from`,\n                 * `point.options.to`, `point.options.weight` and other properties in the\n                 * same form.\n                 *\n                 * @product   highmaps\n                 */\n                headerFormat: '<span style=\"font-size: 0.8em\">{series.name}</span><br/>',\n                pointFormat: '{point.options.from} \\u2192 {point.options.to}: <b>{point.options.weight}</b>'\n            }\n        });\n        extend(FlowMapSeries.prototype, {\n            pointClass: FlowMapPoint,\n            pointArrayMap: ['from', 'to', 'weight'],\n            drawPoints: ColumnSeries.prototype.drawPoints,\n            // Make it work on zoom or pan.\n            useMapGeometry: true\n        });\n        SeriesRegistry.registerSeriesType('flowmap', FlowMapSeries);\n        /* *\n         *\n         *  Default export\n         *\n         * */\n        /* *\n         *\n         *  API options\n         *\n         * */\n        /**\n         * A `flowmap` series. If the [type](#series.flowmap.type) option\n         * is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.flowmap\n         * @excluding affectsMapView, allAreas, allowPointSelect, boostBlending,\n         * boostThreshold, borderColor, borderWidth, dashStyle, dataLabels, dragDrop,\n         * joinBy, mapData, negativeColor, onPoint, shadow, showCheckbox\n         * @product   highmaps\n         * @apioption series.flowmap\n         */\n        /**\n         * An array of data points for the series. For the `flowmap` series\n         * type, points can be given in the following ways:\n         *\n         * 1.  An array of arrays with options as values. In this case,\n         *     the values correspond to `from, to, weight`. Example:\n         *     ```js\n         *     data: [\n         *         ['Point 1', 'Point 2', 4]\n         *     ]\n         *     ```\n         *\n         * 2.  An array of objects with named values. The following snippet shows only a\n         *     few settings, see the complete options set below.\n         *\n         *     ```js\n         *     data: [{\n         *         from: 'Point 1',\n         *         to: 'Point 2',\n         *         curveFactor: 0.4,\n         *         weight: 5,\n         *         growTowards: true,\n         *         markerEnd: {\n         *             enabled: true,\n         *             height: 15,\n         *             width: 8\n         *         }\n         *     }]\n         *     ```\n         *\n         * 3.   For objects with named values, instead of using the `mappoint` `id`,\n         *      you can use `[longitude, latitude]` arrays.\n         *\n         *      ```js\n         *      data: [{\n         *          from: [longitude, latitude],\n         *          to: [longitude, latitude]\n         *      }]\n         *      ```\n         *\n         * @type      {Array<number|null|*>}\n         * @apioption series.flowmap.data\n         */\n        /**\n         * A `curveFactor` with a higher value than 0 will curve the link clockwise.\n         * A negative value will curve the link counter clockwise.\n         * If the value is 0 the link will be straight.\n         *\n         * @sample {highmaps} maps/series-flowmap/ship-route/\n         *         Example ship route\n         *\n         * @type      {number}\n         * @apioption series.flowmap.data.curveFactor\n         */\n        /**\n         * The fill color of an individual link.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @apioption series.flowmap.data.fillColor\n         */\n        /**\n         * ID referencing a map point holding coordinates of the link origin or\n         * coordinates in terms of array of `[longitude, latitude]` or object with `lon`\n         * and `lat` properties.\n         *\n         * @sample {highmaps} maps/series-flowmap/from-to-lon-lat\n         *         Flowmap point using lonlat coordinates\n         * @sample {highmaps} maps/series-flowmap/flight-routes\n         *         Highmaps basic flight routes demo\n         *\n         * @type      {string|Highcharts.LonLatArray|Highcharts.MapLonLatObject}\n         * @apioption series.flowmap.data.from\n         */\n        /**\n         * ID referencing a map point holding coordinates of the link origin or\n         * coordinates in terms of array of `[longitude, latitude]` or object with `lon`\n         * and `lat` properties.\n         *\n         * @sample {highmaps} maps/series-flowmap/from-to-lon-lat\n         *         Flowmap point using lonlat coordinates\n         * @sample {highmaps} maps/series-flowmap/flight-routes\n         *         Highmaps basic flight routes demo\n         *\n         * @type      {string|Highcharts.LonLatArray|Highcharts.MapLonLatObject}\n         * @apioption series.flowmap.data.to\n         */\n        /**\n         * The opacity of the link color fill.\n         *\n         * @type      {number}\n         * @apioption series.flowmap.data.fillOpacity\n         */\n        /**\n         * If set to `true`, the line will grow towards its end.\n         *\n         * @sample {highmaps} maps/series-flowmap/ship-route/\n         *         Example ship route\n         *\n         * @type      {boolean}\n         * @apioption series.flowmap.data.growTowards\n         */\n        /**\n         * Specifying a `markerEnd` here will create an arrow symbol\n         * indicating the direction of flow at the destination of one individual link.\n         * If one has been previously specified at the higher level option it will be\n         * overridden for the current link.\n         *\n         * @sample {highmaps} maps/series-flowmap/ship-route/\n         *         Example ship route\n         *\n         * @type      {*|null}\n         * @apioption series.flowmap.data.markerEnd\n         */\n        /**\n         * Enable or disable the `markerEnd`.\n         *\n         * @type      {boolean}\n         * @apioption series.flowmap.data.markerEnd.enabled\n         */\n        /**\n         * Height of the `markerEnd`. Can be a number in pixels\n         * or a percentage based on the weight of the link.\n         *\n         * @type      {number|string}\n         * @apioption series.flowmap.data.markerEnd.height\n         */\n        /**\n         * Width of the `markerEnd`. Can be a number in pixels\n         * or a percentage based on the weight of the link.\n         *\n         * @type      {number|string}\n         * @apioption series.flowmap.data.markerEnd.width\n         */\n        /**\n         * Change the shape of the `markerEnd`. Can be `arrow` or `mushroom`.\n         *\n         * @type      {string}\n         * @apioption series.flowmap.data.markerEnd.markerType\n         */\n        /**\n         * The opacity of an individual link.\n         *\n         * @type      {number}\n         * @apioption series.flowmap.data.opacity\n         */\n        /**\n         * The weight of a link determines its thickness compared to\n         * other links.\n         *\n         * @sample {highmaps} maps/series-flowmap/ship-route/\n         *         Example ship route\n         *\n         * @type      {number}\n         * @apioption series.flowmap.data.weight\n         */\n        /**\n         * Specify the `lineWidth` of the link.\n         *\n         * @type  {number}\n         * @apioption series.flowmap.data.lineWidth\n         */\n        ''; // adds doclets above to transpiled file\n\n        return FlowMapSeries;\n    });\n    _registerModule(_modules, 'masters/modules/flowmap.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","SeriesRegistry","U","seriesTypes","mapline","prototype","pointClass","MapLinePoint","pick","isString","isNumber","constructor","arguments","options","series","isValid","valid","to","from","forEach","toOrFrom","lat","lon","FlowMapPoint","Point","column","ColumnSeries","map","MapSeries","MapLineSeries","addEvent","arrayMax","arrayMin","defined","extend","isArray","merge","relativeLength","FlowMapSeries","data","points","smallestWeight","greatestWeight","centerOfPoints","getLength","x","y","Math","sqrt","normalize","length","markerEndPath","lCorner","rCorner","topCorner","width","type","markerType","edgeX","edgeY","push","xLeft","yLeft","xRight","yRight","xTop","yTop","xMid","yMid","animate","init","point","shapeArgs","d","start","i","j","graphic","attr","getLinkWidth","weight","minWidthLimit","minWidth","maxWidthLimit","maxWidth","autoCurve","fromX","fromY","toX","toY","centerX","centerY","linkV","half","centerV","dot","det","angle","atan2","angleDeg","PI","sin","pointAttribs","state","attrs","call","fill","fillColor","color","fillOpacity","lineWidth","opacity","translate","chart","hasRendered","isDirtyData","processData","generatePoints","weights","averageX","averageY","fromPos","toPos","mapView","dirtySeries","isDirty","getPointXY","pointId","foundPoint","get","plotX","plotY","getLonLatXY","lonLat","lonLatToPixels","shapeType","getPointShapeArgs","finalWidth","pointOptions","markerEndOptions","markerEnd","growTowards","curveFactor","offset","enabled","height","dX","dY","mX","mY","tmp","arcPointX","arcPointY","offsetX","offsetY","wX","wY","fineTune","fromXToArc","fromYToArc","toXToArc","toYToArc","marker","splice","fromPoint","toPoint","fromLat","fromLon","toLat","toLon","defaultOptions","animation","dataLabels","tooltip","headerFormat","pointFormat","pointArrayMap","drawPoints","useMapGeometry","registerSeriesType"],"mappings":"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"}