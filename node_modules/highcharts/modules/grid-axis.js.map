{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.2.0 (2023-10-30)\n *\n * GridAxis\n *\n * (c) 2016-2021 Lars A. V. Cabrera\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/grid-axis', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Axis/GridAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Axis, H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { dateFormats } = H;\n        const { addEvent, defined, erase, find, isArray, isNumber, merge, pick, timeUnits, wrap } = U;\n        /* *\n         *\n         *  Enums\n         *\n         * */\n        /**\n         * Enum for which side the axis is on. Maps to axis.side.\n         * @private\n         */\n        var GridAxisSide;\n        (function (GridAxisSide) {\n            GridAxisSide[GridAxisSide[\"top\"] = 0] = \"top\";\n            GridAxisSide[GridAxisSide[\"right\"] = 1] = \"right\";\n            GridAxisSide[GridAxisSide[\"bottom\"] = 2] = \"bottom\";\n            GridAxisSide[GridAxisSide[\"left\"] = 3] = \"left\";\n        })(GridAxisSide || (GridAxisSide = {}));\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function argsToArray(args) {\n            return Array.prototype.slice.call(args, 1);\n        }\n        /**\n         * @private\n         */\n        function isObject(x) {\n            // Always use strict mode\n            return U.isObject(x, true);\n        }\n        /**\n         * @private\n         */\n        function applyGridOptions(axis) {\n            const options = axis.options;\n            // Center-align by default\n            /*\n            if (!options.labels) {\n                options.labels = {};\n            }\n            */\n            options.labels.align = pick(options.labels.align, 'center');\n            // @todo: Check against tickLabelPlacement between/on etc\n            /* Prevents adding the last tick label if the axis is not a category\n               axis.\n               Since numeric labels are normally placed at starts and ends of a\n               range of value, and this module makes the label point at the value,\n               an \"extra\" label would appear. */\n            if (!axis.categories) {\n                options.showLastLabel = false;\n            }\n            // Prevents rotation of labels when squished, as rotating them would not\n            // help.\n            axis.labelRotation = 0;\n            options.labels.rotation = 0;\n            // Allow putting ticks closer than their data points.\n            options.minTickInterval = 1;\n        }\n        /**\n         * Extends axis class with grid support.\n         * @private\n         */\n        function compose(AxisClass, ChartClass, TickClass) {\n            if (U.pushUnique(composedMembers, AxisClass)) {\n                AxisClass.keepProps.push('grid');\n                AxisClass.prototype.getMaxLabelDimensions = getMaxLabelDimensions;\n                wrap(AxisClass.prototype, 'unsquish', wrapUnsquish);\n                // Add event handlers\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterGetOffset', onAfterGetOffset);\n                addEvent(AxisClass, 'afterGetTitlePosition', onAfterGetTitlePosition);\n                addEvent(AxisClass, 'afterInit', onAfterInit);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(AxisClass, 'afterSetAxisTranslation', onAfterSetAxisTranslation);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions);\n                addEvent(AxisClass, 'afterSetOptions', onAfterSetOptions2);\n                addEvent(AxisClass, 'afterSetScale', onAfterSetScale);\n                addEvent(AxisClass, 'afterTickSize', onAfterTickSize);\n                addEvent(AxisClass, 'trimTicks', onTrimTicks);\n                addEvent(AxisClass, 'destroy', onDestroy);\n            }\n            if (U.pushUnique(composedMembers, ChartClass)) {\n                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);\n            }\n            if (U.pushUnique(composedMembers, TickClass)) {\n                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                addEvent(TickClass, 'labelFormat', onTickLabelFormat);\n            }\n            return AxisClass;\n        }\n        /**\n         * Get the largest label width and height.\n         *\n         * @private\n         * @function Highcharts.Axis#getMaxLabelDimensions\n         *\n         * @param {Highcharts.Dictionary<Highcharts.Tick>} ticks\n         * All the ticks on one axis.\n         *\n         * @param {Array<number|string>} tickPositions\n         * All the tick positions on one axis.\n         *\n         * @return {Highcharts.SizeObject}\n         * Object containing the properties height and width.\n         *\n         * @todo Move this to the generic axis implementation, as it is used there.\n         */\n        function getMaxLabelDimensions(ticks, tickPositions) {\n            const dimensions = {\n                width: 0,\n                height: 0\n            };\n            tickPositions.forEach(function (pos) {\n                const tick = ticks[pos];\n                let labelHeight = 0, labelWidth = 0, label;\n                if (isObject(tick)) {\n                    label = isObject(tick.label) ? tick.label : {};\n                    // Find width and height of label\n                    labelHeight = label.getBBox ? label.getBBox().height : 0;\n                    if (label.textStr && !isNumber(label.textPxLength)) {\n                        label.textPxLength = label.getBBox().width;\n                    }\n                    labelWidth = isNumber(label.textPxLength) ?\n                        // Math.round ensures crisp lines\n                        Math.round(label.textPxLength) :\n                        0;\n                    if (label.textStr) {\n                        // Set the tickWidth same as the label width after ellipsis\n                        // applied #10281\n                        labelWidth = Math.round(label.getBBox().width);\n                    }\n                    // Update the result if width and/or height are larger\n                    dimensions.height = Math.max(labelHeight, dimensions.height);\n                    dimensions.width = Math.max(labelWidth, dimensions.width);\n                }\n            });\n            // For tree grid, add indentation\n            if (this.options.type === 'treegrid' &&\n                this.treeGrid &&\n                this.treeGrid.mapOfPosToGridNode) {\n                const treeDepth = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n                dimensions.width += (this.options.labels.indentation *\n                    (treeDepth - 1));\n            }\n            return dimensions;\n        }\n        /**\n         * Handle columns and getOffset.\n         * @private\n         */\n        function onAfterGetOffset() {\n            const { grid } = this;\n            (grid && grid.columns || []).forEach(function (column) {\n                column.getOffset();\n            });\n        }\n        /**\n         * @private\n         */\n        function onAfterGetTitlePosition(e) {\n            const axis = this;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                // compute anchor points for each of the title align options\n                const { axisTitle, height: axisHeight, horiz, left: axisLeft, offset, opposite, options, top: axisTop, width: axisWidth } = axis;\n                const tickSize = axis.tickSize();\n                const titleWidth = axisTitle && axisTitle.getBBox().width;\n                const xOption = options.title.x;\n                const yOption = options.title.y;\n                const titleMargin = pick(options.title.margin, horiz ? 5 : 10);\n                const titleFontSize = axisTitle ? axis.chart.renderer.fontMetrics(axisTitle).f : 0;\n                const crispCorr = tickSize ? tickSize[0] / 2 : 0;\n                // TODO account for alignment\n                // the position in the perpendicular direction of the axis\n                const offAxis = ((horiz ? axisTop + axisHeight : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                        (opposite ? -1 : 1) * // so does opposite axes\n                        crispCorr +\n                    (axis.side === GridAxisSide.bottom ? titleFontSize : 0));\n                e.titlePosition.x = horiz ?\n                    axisLeft - (titleWidth || 0) / 2 - titleMargin + xOption :\n                    offAxis + (opposite ? axisWidth : 0) + offset + xOption;\n                e.titlePosition.y = horiz ?\n                    (offAxis -\n                        (opposite ? axisHeight : 0) +\n                        (opposite ? titleFontSize : -titleFontSize) / 2 +\n                        offset +\n                        yOption) :\n                    axisTop - titleMargin + yOption;\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterInit() {\n            const axis = this;\n            const { chart, options: { grid: gridOptions = {} }, userOptions } = axis;\n            if (gridOptions.enabled) {\n                applyGridOptions(axis);\n            }\n            if (gridOptions.columns) {\n                const columns = axis.grid.columns = [];\n                let columnIndex = axis.grid.columnIndex = 0;\n                // Handle columns, each column is a grid axis\n                while (++columnIndex < gridOptions.columns.length) {\n                    const columnOptions = merge(userOptions, gridOptions.columns[gridOptions.columns.length - columnIndex - 1], {\n                        isInternal: true,\n                        linkedTo: 0,\n                        // Force to behave like category axis\n                        type: 'category',\n                        // Disable by default the scrollbar on the grid axis\n                        scrollbar: {\n                            enabled: false\n                        }\n                    });\n                    delete columnOptions.grid.columns; // Prevent recursion\n                    const column = new Axis(axis.chart, columnOptions, 'yAxis');\n                    column.grid.isColumn = true;\n                    column.grid.columnIndex = columnIndex;\n                    // Remove column axis from chart axes array, and place it\n                    // in the columns array.\n                    erase(chart.axes, column);\n                    erase(chart[axis.coll] || [], column);\n                    columns.push(column);\n                }\n            }\n        }\n        /**\n         * Draw an extra line on the far side of the outermost axis,\n         * creating floor/roof/wall of a grid. And some padding.\n         * ```\n         * Make this:\n         *             (axis.min) __________________________ (axis.max)\n         *                           |    |    |    |    |\n         * Into this:\n         *             (axis.min) __________________________ (axis.max)\n         *                        ___|____|____|____|____|__\n         * ```\n         * @private\n         */\n        function onAfterRender() {\n            const axis = this, grid = axis.grid, options = axis.options, gridOptions = options.grid || {};\n            if (gridOptions.enabled === true) {\n                const min = axis.min || 0, max = axis.max || 0;\n                // @todo acutual label padding (top, bottom, left, right)\n                axis.maxLabelDimensions = axis.getMaxLabelDimensions(axis.ticks, axis.tickPositions);\n                // Remove right wall before rendering if updating\n                if (axis.rightWall) {\n                    axis.rightWall.destroy();\n                }\n                /*\n                Draw an extra axis line on outer axes\n                            >\n                Make this:    |______|______|______|___\n\n                            > _________________________\n                Into this:    |______|______|______|__|\n                                                        */\n                if (axis.grid && axis.grid.isOuterAxis() && axis.axisLine) {\n                    const lineWidth = options.lineWidth;\n                    if (lineWidth) {\n                        const linePath = axis.getLinePath(lineWidth), startPoint = linePath[0], endPoint = linePath[1], \n                        // Negate distance if top or left axis\n                        // Subtract 1px to draw the line at the end of the tick\n                        tickLength = (axis.tickSize('tick') || [1])[0], distance = (tickLength - 1) * ((axis.side === GridAxisSide.top ||\n                            axis.side === GridAxisSide.left) ? -1 : 1);\n                        // If axis is horizontal, reposition line path vertically\n                        if (startPoint[0] === 'M' && endPoint[0] === 'L') {\n                            if (axis.horiz) {\n                                startPoint[2] += distance;\n                                endPoint[2] += distance;\n                            }\n                            else {\n                                startPoint[1] += distance;\n                                endPoint[1] += distance;\n                            }\n                        }\n                        // If it doesn't exist, add an upper and lower border\n                        // for the vertical grid axis.\n                        if (!axis.horiz && axis.chart.marginRight) {\n                            const upperBorderStartPoint = startPoint, upperBorderEndPoint = [\n                                'L',\n                                axis.left,\n                                startPoint[2] || 0\n                            ], upperBorderPath = [\n                                upperBorderStartPoint,\n                                upperBorderEndPoint\n                            ], lowerBorderEndPoint = [\n                                'L',\n                                axis.chart.chartWidth - axis.chart.marginRight,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderStartPoint = [\n                                'M',\n                                endPoint[1] || 0,\n                                axis.toPixels(max + axis.tickmarkOffset)\n                            ], lowerBorderPath = [\n                                lowerBorderStartPoint,\n                                lowerBorderEndPoint\n                            ];\n                            if (!axis.grid.upperBorder && min % 1 !== 0) {\n                                axis.grid.upperBorder = axis.grid.renderBorder(upperBorderPath);\n                            }\n                            if (axis.grid.upperBorder) {\n                                axis.grid.upperBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.upperBorder.animate({\n                                    d: upperBorderPath\n                                });\n                            }\n                            if (!axis.grid.lowerBorder && max % 1 !== 0) {\n                                axis.grid.lowerBorder = axis.grid.renderBorder(lowerBorderPath);\n                            }\n                            if (axis.grid.lowerBorder) {\n                                axis.grid.lowerBorder.attr({\n                                    stroke: options.lineColor,\n                                    'stroke-width': options.lineWidth\n                                });\n                                axis.grid.lowerBorder.animate({\n                                    d: lowerBorderPath\n                                });\n                            }\n                        }\n                        // Render an extra line parallel to the existing axes, to\n                        // close the grid.\n                        if (!axis.grid.axisLineExtra) {\n                            axis.grid.axisLineExtra = axis.grid.renderBorder(linePath);\n                        }\n                        else {\n                            axis.grid.axisLineExtra.attr({\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth\n                            });\n                            axis.grid.axisLineExtra.animate({\n                                d: linePath\n                            });\n                        }\n                        // show or hide the line depending on options.showEmpty\n                        axis.axisLine[axis.showAxis ? 'show' : 'hide']();\n                    }\n                }\n                (grid && grid.columns || []).forEach((column) => column.render());\n                // Manipulate the tick mark visibility\n                // based on the axis.max- allows smooth scrolling.\n                if (!axis.horiz &&\n                    axis.chart.hasRendered &&\n                    (axis.scrollbar ||\n                        (axis.linkedParent && axis.linkedParent.scrollbar))) {\n                    const tickmarkOffset = axis.tickmarkOffset, lastTick = axis.tickPositions[axis.tickPositions.length - 1], firstTick = axis.tickPositions[0];\n                    let label, tickMark;\n                    while ((label = axis.hiddenLabels.pop()) && label.element) {\n                        label.show(); // #15453\n                    }\n                    while ((tickMark = axis.hiddenMarks.pop()) &&\n                        tickMark.element) {\n                        tickMark.show(); // #16439\n                    }\n                    // Hide/show firts tick label.\n                    label = axis.ticks[firstTick].label;\n                    if (label) {\n                        if (min - firstTick > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    // Hide/show last tick mark/label.\n                    label = axis.ticks[lastTick].label;\n                    if (label) {\n                        if (lastTick - max > tickmarkOffset) {\n                            axis.hiddenLabels.push(label.hide());\n                        }\n                        else {\n                            label.show();\n                        }\n                    }\n                    const mark = axis.ticks[lastTick].mark;\n                    if (mark &&\n                        lastTick - max < tickmarkOffset &&\n                        lastTick - max > 0 && axis.ticks[lastTick].isLast) {\n                        axis.hiddenMarks.push(mark.hide());\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetAxisTranslation() {\n            const axis = this;\n            const tickInfo = axis.tickPositions && axis.tickPositions.info;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            const userLabels = axis.userOptions.labels || {};\n            // Fire this only for the Gantt type chart, #14868.\n            if (gridOptions.enabled) {\n                if (axis.horiz) {\n                    axis.series.forEach((series) => {\n                        series.options.pointRange = 0;\n                    });\n                    // Lower level time ticks, like hours or minutes, represent\n                    // points in time and not ranges. These should be aligned\n                    // left in the grid cell by default. The same applies to\n                    // years of higher order.\n                    if (tickInfo &&\n                        options.dateTimeLabelFormats &&\n                        options.labels &&\n                        !defined(userLabels.align) &&\n                        (options.dateTimeLabelFormats[tickInfo.unitName]\n                            .range === false ||\n                            tickInfo.count > 1 // years\n                        )) {\n                        options.labels.align = 'left';\n                        if (!defined(userLabels.x)) {\n                            options.labels.x = 3;\n                        }\n                    }\n                }\n                else {\n                    // Don't trim ticks which not in min/max range but\n                    // they are still in the min/max plus tickInterval.\n                    if (this.options.type !== 'treegrid' &&\n                        axis.grid &&\n                        axis.grid.columns) {\n                        this.minPointOffset = this.tickInterval;\n                    }\n                }\n            }\n        }\n        /**\n         * Creates a left and right wall on horizontal axes:\n         * - Places leftmost tick at the start of the axis, to create a left\n         *   wall\n         * - Ensures that the rightmost tick is at the end of the axis, to\n         *   create a right wall.\n         * @private\n         */\n        function onAfterSetOptions(e) {\n            const options = this.options, userOptions = e.userOptions, gridOptions = ((options && isObject(options.grid)) ? options.grid : {});\n            let gridAxisOptions;\n            if (gridOptions.enabled === true) {\n                // Merge the user options into default grid axis options so\n                // that when a user option is set, it takes presedence.\n                gridAxisOptions = merge(true, {\n                    className: ('highcharts-grid-axis ' + (userOptions.className || '')),\n                    dateTimeLabelFormats: {\n                        hour: {\n                            list: ['%H:%M', '%H']\n                        },\n                        day: {\n                            list: ['%A, %e. %B', '%a, %e. %b', '%E']\n                        },\n                        week: {\n                            list: ['Week %W', 'W%W']\n                        },\n                        month: {\n                            list: ['%B', '%b', '%o']\n                        }\n                    },\n                    grid: {\n                        borderWidth: 1\n                    },\n                    labels: {\n                        padding: 2,\n                        style: {\n                            fontSize: '0.9em'\n                        }\n                    },\n                    margin: 0,\n                    title: {\n                        text: null,\n                        reserveSpace: false,\n                        rotation: 0\n                    },\n                    // In a grid axis, only allow one unit of certain types,\n                    // for example we shouln't have one grid cell spanning\n                    // two days.\n                    units: [[\n                            'millisecond',\n                            [1, 10, 100]\n                        ], [\n                            'second',\n                            [1, 10]\n                        ], [\n                            'minute',\n                            [1, 5, 15]\n                        ], [\n                            'hour',\n                            [1, 6]\n                        ], [\n                            'day',\n                            [1]\n                        ], [\n                            'week',\n                            [1]\n                        ], [\n                            'month',\n                            [1]\n                        ], [\n                            'year',\n                            null\n                        ]]\n                }, userOptions);\n                // X-axis specific options\n                if (this.coll === 'xAxis') {\n                    // For linked axes, tickPixelInterval is used only if\n                    // the tickPositioner below doesn't run or returns\n                    // undefined (like multiple years)\n                    if (defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPixelInterval)) {\n                        gridAxisOptions.tickPixelInterval = 350;\n                    }\n                    // For the secondary grid axis, use the primary axis'\n                    // tick intervals and return ticks one level higher.\n                    if (\n                    // Check for tick pixel interval in options\n                    !defined(userOptions.tickPixelInterval) &&\n                        // Only for linked axes\n                        defined(userOptions.linkedTo) &&\n                        !defined(userOptions.tickPositioner) &&\n                        !defined(userOptions.tickInterval)) {\n                        gridAxisOptions.tickPositioner = function (min, max) {\n                            const parentInfo = (this.linkedParent &&\n                                this.linkedParent.tickPositions &&\n                                this.linkedParent.tickPositions.info);\n                            if (parentInfo) {\n                                const units = (gridAxisOptions.units || []);\n                                let unitIdx, count = 1, unitName = 'year';\n                                for (let i = 0; i < units.length; i++) {\n                                    const unit = units[i];\n                                    if (unit && unit[0] === parentInfo.unitName) {\n                                        unitIdx = i;\n                                        break;\n                                    }\n                                }\n                                // Get the first allowed count on the next unit.\n                                const unit = (isNumber(unitIdx) && units[unitIdx + 1]);\n                                if (unit) {\n                                    unitName = unit[0] || 'year';\n                                    const counts = unit[1];\n                                    count = counts && counts[0] || 1;\n                                    // In case the base X axis shows years, make the\n                                    // secondary axis show ten times the years (#11427)\n                                }\n                                else if (parentInfo.unitName === 'year') {\n                                    // unitName is 'year'\n                                    count = parentInfo.count * 10;\n                                }\n                                const unitRange = timeUnits[unitName];\n                                this.tickInterval = unitRange * count;\n                                return this.chart.time.getTimeTicks({ unitRange, count, unitName }, min, max, this.options.startOfWeek);\n                            }\n                        };\n                    }\n                }\n                // Now merge the combined options into the axis options\n                merge(true, this.options, gridAxisOptions);\n                if (this.horiz) {\n                    /*               _________________________\n                    Make this:    ___|_____|_____|_____|__|\n                                    ^                     ^\n                                    _________________________\n                    Into this:    |_____|_____|_____|_____|\n                                        ^                 ^    */\n                    options.minPadding = pick(userOptions.minPadding, 0);\n                    options.maxPadding = pick(userOptions.maxPadding, 0);\n                }\n                // If borderWidth is set, then use its value for tick and\n                // line width.\n                if (isNumber(options.grid.borderWidth)) {\n                    options.tickWidth = options.lineWidth =\n                        gridOptions.borderWidth;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAfterSetOptions2(e) {\n            const axis = this;\n            const userOptions = e.userOptions;\n            const gridOptions = userOptions && userOptions.grid || {};\n            const columns = gridOptions.columns;\n            // Add column options to the parent axis. Children has their column\n            // options set on init in onGridAxisAfterInit.\n            if (gridOptions.enabled && columns) {\n                merge(true, axis.options, columns[columns.length - 1]);\n            }\n        }\n        /**\n         * Handle columns and setScale.\n         * @private\n         */\n        function onAfterSetScale() {\n            const axis = this;\n            (axis.grid.columns || []).forEach((column) => column.setScale());\n        }\n        /**\n         * Draw vertical axis ticks extra long to create cell floors and roofs.\n         * Overrides the tickLength for vertical axes.\n         * @private\n         */\n        function onAfterTickSize(e) {\n            const { horiz, maxLabelDimensions, options: { grid: gridOptions = {} } } = this;\n            if (gridOptions.enabled && maxLabelDimensions) {\n                const labelPadding = this.options.labels.distance * 2;\n                const distance = horiz ?\n                    (gridOptions.cellHeight ||\n                        labelPadding + maxLabelDimensions.height) :\n                    labelPadding + maxLabelDimensions.width;\n                if (isArray(e.tickSize)) {\n                    e.tickSize[0] = distance;\n                }\n                else {\n                    e.tickSize = [distance, 0];\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartAfterSetChartSize() {\n            this.axes.forEach((axis) => {\n                (axis.grid && axis.grid.columns || []).forEach((column) => {\n                    column.setAxisSize();\n                    column.setAxisTranslation();\n                });\n            });\n        }\n        /**\n         * @private\n         */\n        function onDestroy(e) {\n            const { grid } = this;\n            (grid.columns || []).forEach((column) => column.destroy(e.keepEvents));\n            grid.columns = void 0;\n        }\n        /**\n         * Wraps axis init to draw cell walls on vertical axes.\n         * @private\n         */\n        function onInit(e) {\n            const axis = this;\n            const userOptions = e.userOptions || {};\n            const gridOptions = userOptions.grid || {};\n            if (gridOptions.enabled && defined(gridOptions.borderColor)) {\n                userOptions.tickColor = userOptions.lineColor = (gridOptions.borderColor);\n            }\n            if (!axis.grid) {\n                axis.grid = new GridAxisAdditions(axis);\n            }\n            axis.hiddenLabels = [];\n            axis.hiddenMarks = [];\n        }\n        /**\n         * Center tick labels in cells.\n         * @private\n         */\n        function onTickAfterGetLabelPosition(e) {\n            const tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed, chart = axis.chart, options = axis.options, gridOptions = options.grid || {}, labelOpts = axis.options.labels, align = labelOpts.align, \n            // verticalAlign is currently not supported for axis.labels.\n            verticalAlign = 'middle', // labelOpts.verticalAlign,\n            side = GridAxisSide[axis.side], tickmarkOffset = e.tickmarkOffset, tickPositions = axis.tickPositions, tickPos = tick.pos - tickmarkOffset, nextTickPos = (isNumber(tickPositions[e.index + 1]) ?\n                tickPositions[e.index + 1] - tickmarkOffset :\n                (axis.max || 0) + tickmarkOffset), tickSize = axis.tickSize('tick'), tickWidth = tickSize ? tickSize[0] : 0, crispCorr = tickSize ? tickSize[1] / 2 : 0;\n            // Only center tick labels in grid axes\n            if (gridOptions.enabled === true) {\n                let bottom, top, left, right;\n                // Calculate top and bottom positions of the cell.\n                if (side === 'top') {\n                    bottom = axis.top + axis.offset;\n                    top = bottom - tickWidth;\n                }\n                else if (side === 'bottom') {\n                    top = chart.chartHeight - axis.bottom + axis.offset;\n                    bottom = top + tickWidth;\n                }\n                else {\n                    bottom = axis.top + axis.len - (axis.translate(reversed ? nextTickPos : tickPos) || 0);\n                    top = axis.top + axis.len - (axis.translate(reversed ? tickPos : nextTickPos) || 0);\n                }\n                // Calculate left and right positions of the cell.\n                if (side === 'right') {\n                    left = chart.chartWidth - axis.right + axis.offset;\n                    right = left + tickWidth;\n                }\n                else if (side === 'left') {\n                    right = axis.left + axis.offset;\n                    left = right - tickWidth;\n                }\n                else {\n                    left = Math.round(axis.left + (axis.translate(reversed ? nextTickPos : tickPos) || 0)) - crispCorr;\n                    right = Math.min(// #15742\n                    Math.round(axis.left + (axis.translate(reversed ? tickPos : nextTickPos) || 0)) - crispCorr, axis.left + axis.len);\n                }\n                tick.slotWidth = right - left;\n                // Calculate the positioning of the label based on\n                // alignment.\n                e.pos.x = (align === 'left' ?\n                    left :\n                    align === 'right' ?\n                        right :\n                        left + ((right - left) / 2) // default to center\n                );\n                e.pos.y = (verticalAlign === 'top' ?\n                    top :\n                    verticalAlign === 'bottom' ?\n                        bottom :\n                        top + ((bottom - top) / 2) // default to middle\n                );\n                if (label) {\n                    const lblMetrics = chart.renderer.fontMetrics(label), labelHeight = label.getBBox().height;\n                    // Adjustment to y position to align the label correctly.\n                    // Would be better to have a setter or similar for this.\n                    if (!labelOpts.useHTML) {\n                        const lines = Math.round(labelHeight / lblMetrics.h);\n                        e.pos.y += (\n                        // Center the label\n                        // TODO: why does this actually center the label?\n                        ((lblMetrics.b - (lblMetrics.h - lblMetrics.f)) / 2) +\n                            // Adjust for height of additional lines.\n                            -(((lines - 1) * lblMetrics.h) / 2));\n                    }\n                    else {\n                        e.pos.y += (\n                        // Readjust yCorr in htmlUpdateTransform\n                        lblMetrics.b +\n                            // Adjust for height of html label\n                            -(labelHeight / 2));\n                    }\n                }\n                e.pos.x += (axis.horiz && labelOpts.x) || 0;\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickLabelFormat(ctx) {\n            const { axis, value } = ctx;\n            if (axis.options.grid &&\n                axis.options.grid.enabled) {\n                const tickPos = axis.tickPositions;\n                const series = (axis.linkedParent || axis).series[0];\n                const isFirst = value === tickPos[0];\n                const isLast = value === tickPos[tickPos.length - 1];\n                const point = series && find(series.options.data, function (p) {\n                    return p[axis.isXAxis ? 'x' : 'y'] === value;\n                });\n                let pointCopy;\n                if (point && series.is('gantt')) {\n                    // For the Gantt set point aliases to the pointCopy\n                    // to do not change the original point\n                    pointCopy = merge(point);\n                    H.seriesTypes.gantt.prototype.pointClass\n                        .setGanttPointAliases(pointCopy);\n                }\n                // Make additional properties available for the\n                // formatter\n                ctx.isFirst = isFirst;\n                ctx.isLast = isLast;\n                ctx.point = pointCopy;\n            }\n        }\n        /**\n         * Makes tick labels which are usually ignored in a linked axis\n         * displayed if they are within range of linkedParent.min.\n         * ```\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Make this:             |   |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         *                        _____________________________\n         *                        |   |       |       |       |\n         * Into this:             | 1 |   2   |   3   |   4   |\n         *                        |___|_______|_______|_______|\n         *                          ^\n         * ```\n         * @private\n         * @todo Does this function do what the drawing says? Seems to affect\n         *       ticks and not the labels directly?\n         */\n        function onTrimTicks() {\n            const axis = this;\n            const options = axis.options;\n            const gridOptions = options.grid || {};\n            const categoryAxis = axis.categories;\n            const tickPositions = axis.tickPositions;\n            const firstPos = tickPositions[0];\n            const lastPos = tickPositions[tickPositions.length - 1];\n            const linkedMin = axis.linkedParent && axis.linkedParent.min;\n            const linkedMax = axis.linkedParent && axis.linkedParent.max;\n            const min = linkedMin || axis.min;\n            const max = linkedMax || axis.max;\n            const tickInterval = axis.tickInterval;\n            const endMoreThanMin = (firstPos < min &&\n                firstPos + tickInterval > min);\n            const startLessThanMax = (lastPos > max &&\n                lastPos - tickInterval < max);\n            if (gridOptions.enabled === true &&\n                !categoryAxis &&\n                (axis.horiz || axis.isLinked)) {\n                if (endMoreThanMin && !options.startOnTick) {\n                    tickPositions[0] = min;\n                }\n                if (startLessThanMax && !options.endOnTick) {\n                    tickPositions[tickPositions.length - 1] = max;\n                }\n            }\n        }\n        /**\n         * Avoid altering tickInterval when reserving space.\n         * @private\n         */\n        function wrapUnsquish(proceed) {\n            const axis = this;\n            const { options: { grid: gridOptions = {} } } = axis;\n            if (gridOptions.enabled === true && axis.categories) {\n                return axis.tickInterval;\n            }\n            return proceed.apply(axis, argsToArray(arguments));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Additions for grid axes.\n         * @private\n         * @class\n         */\n        class GridAxisAdditions {\n            /* *\n            *\n            *  Constructors\n            *\n            * */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n            *\n            *  Functions\n            *\n            * */\n            /**\n             * Checks if an axis is the outer axis in its dimension. Since\n             * axes are placed outwards in order, the axis with the highest\n             * index is the outermost axis.\n             *\n             * Example: If there are multiple x-axes at the top of the chart,\n             * this function returns true if the axis supplied is the last\n             * of the x-axes.\n             *\n             * @private\n             *\n             * @return {boolean}\n             * True if the axis is the outermost axis in its dimension; false if\n             * not.\n             */\n            isOuterAxis() {\n                const axis = this.axis;\n                const chart = axis.chart;\n                const columnIndex = axis.grid.columnIndex;\n                const columns = (axis.linkedParent && axis.linkedParent.grid.columns ||\n                    axis.grid.columns);\n                const parentAxis = columnIndex ? axis.linkedParent : axis;\n                let thisIndex = -1, lastIndex = 0;\n                (chart[axis.coll] || []).forEach((otherAxis, index) => {\n                    if (otherAxis.side === axis.side &&\n                        !otherAxis.options.isInternal) {\n                        lastIndex = index;\n                        if (otherAxis === parentAxis) {\n                            // Get the index of the axis in question\n                            thisIndex = index;\n                        }\n                    }\n                });\n                return (lastIndex === thisIndex &&\n                    (isNumber(columnIndex) ?\n                        columns.length === columnIndex :\n                        true));\n            }\n            /**\n             * Add extra border based on the provided path.\n             * @private\n             * @param {SVGPath} path\n             * The path of the border.\n             * @return {Highcharts.SVGElement}\n             * Border\n             */\n            renderBorder(path) {\n                const axis = this.axis, renderer = axis.chart.renderer, options = axis.options, extraBorderLine = renderer.path(path)\n                    .addClass('highcharts-axis-line')\n                    .add(axis.axisBorder);\n                if (!renderer.styledMode) {\n                    extraBorderLine.attr({\n                        stroke: options.lineColor,\n                        'stroke-width': options.lineWidth,\n                        zIndex: 7\n                    });\n                }\n                return extraBorderLine;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        // First letter of the day of the week, e.g. 'M' for 'Monday'.\n        dateFormats.E = function (timestamp) {\n            return this.dateFormat('%a', timestamp, true).charAt(0);\n        };\n        // Adds week date format\n        dateFormats.W = function (timestamp) {\n            const time = this, d = new this.Date(timestamp), unitsToOmit = ['Hours', 'Milliseconds', 'Minutes', 'Seconds'];\n            unitsToOmit.forEach(function (format) {\n                time.set(format, d, 0);\n            });\n            const firstDay = (this.get('Day', d) + 6) % 7;\n            const thursday = new this.Date(d.valueOf());\n            this.set('Date', thursday, this.get('Date', d) - firstDay + 3);\n            const firstThursday = new this.Date(this.get('FullYear', thursday), 0, 1);\n            if (this.get('Day', firstThursday) !== 4) {\n                this.set('Month', d, 0);\n                this.set('Date', d, 1 + (11 - this.get('Day', firstThursday)) % 7);\n            }\n            return (1 +\n                Math.floor((thursday.valueOf() - firstThursday.valueOf()) / 604800000)).toString();\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const GridAxis = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * @productdesc {gantt}\n         * For grid axes (like in Gantt charts),\n         * it is possible to declare as a list to provide different\n         * formats depending on available space.\n         *\n         * Defaults to:\n         * ```js\n         * {\n         *     hour: { list: ['%H:%M', '%H'] },\n         *     day: { list: ['%A, %e. %B', '%a, %e. %b', '%E'] },\n         *     week: { list: ['Week %W', 'W%W'] },\n         *     month: { list: ['%B', '%b', '%o'] }\n         * }\n         * ```\n         *\n         * @sample {gantt} gantt/grid-axis/date-time-label-formats\n         *         Gantt chart with custom axis date format.\n         *\n         * @apioption xAxis.dateTimeLabelFormats\n         */\n        /**\n         * Set grid options for the axis labels. Requires Highcharts Gantt.\n         *\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid\n         */\n        /**\n         * Enable grid on the axis labels. Defaults to true for Gantt charts.\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption xAxis.grid.enabled\n         */\n        /**\n         * Set specific options for each column (or row for horizontal axes) in the\n         * grid. Each extra column/row is its own axis, and the axis options can be set\n         * here.\n         *\n         * @sample gantt/demo/left-axis-table\n         *         Left axis as a table\n         *\n         * @type      {Array<Highcharts.XAxisOptions>}\n         * @apioption xAxis.grid.columns\n         */\n        /**\n         * Set border color for the label grid lines.\n         *\n         * @type      {Highcharts.ColorString}\n         * @apioption xAxis.grid.borderColor\n         */\n        /**\n         * Set border width of the label grid lines.\n         *\n         * @type      {number}\n         * @default   1\n         * @apioption xAxis.grid.borderWidth\n         */\n        /**\n         * Set cell height for grid axis labels. By default this is calculated from font\n         * size. This option only applies to horizontal axes. For vertical axes, check\n         * the [#yAxis.staticScale](yAxis.staticScale) option.\n         *\n         * @sample gantt/grid-axis/cellheight\n         *         Gant chart with custom cell height\n         * @type      {number}\n         * @apioption xAxis.grid.cellHeight\n         */\n        ''; // keeps doclets above in JS file\n\n        return GridAxis;\n    });\n    _registerModule(_modules, 'masters/modules/grid-axis.src.js', [_modules['Core/Globals.js'], _modules['Core/Axis/GridAxis.js']], function (Highcharts, GridAxis) {\n\n        const G = Highcharts;\n        // Compositions\n        GridAxis.compose(G.Axis, G.Chart, G.Tick);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","Axis","H","U","GridAxisSide","dateFormats","addEvent","defined","erase","find","isArray","isNumber","merge","pick","timeUnits","wrap","composedMembers","isObject","x","getMaxLabelDimensions","ticks","tickPositions","dimensions","width","height","forEach","pos","tick","labelHeight","labelWidth","label","getBBox","textStr","textPxLength","Math","round","max","options","type","treeGrid","mapOfPosToGridNode","treeDepth","labels","indentation","onAfterGetOffset","grid","columns","column","getOffset","onAfterGetTitlePosition","e","axis","gridOptions","enabled","axisTitle","axisHeight","horiz","left","axisLeft","offset","opposite","top","axisTop","axisWidth","tickSize","titleWidth","xOption","title","yOption","y","titleMargin","margin","titleFontSize","chart","renderer","fontMetrics","f","crispCorr","offAxis","side","bottom","titlePosition","onAfterInit","userOptions","applyGridOptions","align","categories","showLastLabel","labelRotation","rotation","minTickInterval","columnIndex","length","columnOptions","isInternal","linkedTo","scrollbar","isColumn","axes","coll","push","onAfterRender","min","maxLabelDimensions","rightWall","destroy","isOuterAxis","axisLine","lineWidth","linePath","getLinePath","startPoint","endPoint","tickLength","distance","marginRight","upperBorderEndPoint","upperBorderPath","lowerBorderEndPoint","chartWidth","toPixels","tickmarkOffset","lowerBorderStartPoint","lowerBorderPath","upperBorder","renderBorder","attr","stroke","lineColor","animate","d","lowerBorder","axisLineExtra","showAxis","render","hasRendered","linkedParent","tickMark","lastTick","firstTick","hiddenLabels","pop","element","show","hiddenMarks","hide","mark","isLast","onAfterSetAxisTranslation","tickInfo","info","userLabels","series","pointRange","dateTimeLabelFormats","unitName","range","count","minPointOffset","tickInterval","onAfterSetOptions","gridAxisOptions","className","hour","list","day","week","month","borderWidth","padding","style","fontSize","text","reserveSpace","units","tickPixelInterval","tickPositioner","parentInfo","unitIdx","i","unit","counts","unitRange","time","getTimeTicks","startOfWeek","minPadding","maxPadding","tickWidth","onAfterSetOptions2","onAfterSetScale","setScale","onAfterTickSize","labelPadding","cellHeight","onChartAfterSetChartSize","setAxisSize","setAxisTranslation","onDestroy","keepEvents","onInit","borderColor","tickColor","GridAxisAdditions","onTickAfterGetLabelPosition","reversed","labelOpts","tickPos","nextTickPos","index","right","chartHeight","len","translate","slotWidth","lblMetrics","useHTML","b","lines","h","onTickLabelFormat","ctx","value","pointCopy","isFirst","point","data","p","isXAxis","is","seriesTypes","gantt","prototype","pointClass","setGanttPointAliases","onTrimTicks","categoryAxis","firstPos","lastPos","linkedMin","linkedMax","isLinked","startOnTick","endOnTick","wrapUnsquish","proceed","arguments","Array","slice","call","constructor","parentAxis","thisIndex","lastIndex","otherAxis","extraBorderLine","addClass","add","axisBorder","styledMode","zIndex","E","timestamp","dateFormat","charAt","W","Date","unitsToOmit","format","set","firstDay","get","thursday","valueOf","firstThursday","floor","toString","compose","AxisClass","ChartClass","TickClass","pushUnique","keepProps","GridAxis","G","Chart","Tick"],"mappings":"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"}