{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * (c) 2016-2021 Highsoft AS\n * Authors: Jon Arild Nygard\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/wordcloud', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/DrawPointUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { isNumber } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Handles the drawing of a component.\n         * Can be used for any type of component that reserves the graphic property,\n         * and provides a shouldDraw on its context.\n         *\n         * @private\n         *\n         * @todo add type checking.\n         * @todo export this function to enable usage\n         */\n        function draw(point, params) {\n            const { animatableAttribs, onComplete, css, renderer } = params;\n            const animation = (point.series && point.series.chart.hasRendered) ?\n                // Chart-level animation on updates\n                void 0 :\n                // Series-level animation on new points\n                (point.series &&\n                    point.series.options.animation);\n            let graphic = point.graphic;\n            params.attribs = {\n                ...params.attribs,\n                'class': point.getClassName()\n            } || {};\n            if ((point.shouldDraw())) {\n                if (!graphic) {\n                    if (params.shapeType === 'text') {\n                        graphic = renderer.text();\n                    }\n                    else if (params.shapeType === 'image') {\n                        graphic = renderer.image(params.imageUrl || '')\n                            .attr(params.shapeArgs || {});\n                    }\n                    else {\n                        graphic = renderer[params.shapeType](params.shapeArgs || {});\n                    }\n                    point.graphic = graphic;\n                    graphic.add(params.group);\n                }\n                if (css) {\n                    graphic.css(css);\n                }\n                graphic\n                    .attr(params.attribs)\n                    .animate(animatableAttribs, params.isNew ? false : animation, onComplete);\n            }\n            else if (graphic) {\n                const destroy = () => {\n                    point.graphic = graphic = (graphic && graphic.destroy());\n                    if (typeof onComplete === 'function') {\n                        onComplete();\n                    }\n                };\n                // animate only runs complete callback if something was animated.\n                if (Object.keys(animatableAttribs).length) {\n                    graphic.animate(animatableAttribs, void 0, () => destroy());\n                }\n                else {\n                    destroy();\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const DrawPointUtilities = {\n            draw\n        };\n\n        return DrawPointUtilities;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class WordcloudPoint extends ColumnPoint {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.dimensions = void 0;\n                this.options = void 0;\n                this.polygon = void 0;\n                this.rect = void 0;\n                this.series = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            isValid() {\n                return true;\n            }\n        }\n        extend(WordcloudPoint.prototype, {\n            weight: 1\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudPoint;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A word cloud is a visualization of a set of words, where the size and\n         * placement of a word is determined by how it is weighted.\n         *\n         * @sample highcharts/demo/wordcloud Word Cloud chart\n         *\n         * @extends      plotOptions.column\n         * @excluding    allAreas, boostThreshold, clip, colorAxis, compare,\n         *               compareBase, crisp, cropThreshold, dataGrouping,\n         *               dataLabels, depth, dragDrop, edgeColor, findNearestPointBy,\n         *               getExtremesFromAll, grouping, groupPadding, groupZPadding,\n         *               joinBy, maxPointWidth, minPointLength, navigatorOptions,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPadding, pointPlacement, pointRange, pointStart,\n         *               pointWidth, pointStart, pointWidth, shadow, showCheckbox,\n         *               showInNavigator, softThreshold, stacking, threshold,\n         *               zoneAxis, zones, dataSorting, boostBlending\n         * @product      highcharts\n         * @since        6.0.0\n         * @requires     modules/wordcloud\n         * @optionparent plotOptions.wordcloud\n         */\n        const WordcloudSeriesDefaults = {\n            /**\n             * If there is no space for a word on the playing field, then this\n             * option will allow the playing field to be extended to fit the word.\n             * If false then the word will be dropped from the visualization.\n             *\n             * NB! This option is currently not decided to be published in the API,\n             * and is therefore marked as private.\n             *\n             * @ignore-option\n             */\n            allowExtendPlayingField: true,\n            animation: {\n                /** @internal */\n                duration: 500\n            },\n            borderWidth: 0,\n            /**\n             * @ignore-option\n             */\n            clip: false,\n            colorByPoint: true,\n            cropThreshold: Infinity,\n            /**\n             * A threshold determining the minimum font size that can be applied to\n             * a word.\n             */\n            minFontSize: 1,\n            /**\n             * The word with the largest weight will have a font size equal to this\n             * value. The font size of a word is the ratio between its weight and\n             * the largest occuring weight, multiplied with the value of\n             * maxFontSize.\n             */\n            maxFontSize: 25,\n            /**\n             * This option decides which algorithm is used for placement, and\n             * rotation of a word. The choice of algorith is therefore a crucial\n             * part of the resulting layout of the wordcloud. It is possible for\n             * users to add their own custom placement strategies for use in word\n             * cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-placement-strategies)\n             *\n             * @validvalue [\"center\", \"random\"]\n             */\n            placementStrategy: 'center',\n            /**\n             * Rotation options for the words in the wordcloud.\n             *\n             * @sample highcharts/plotoptions/wordcloud-rotation\n             *         Word cloud with rotation\n             */\n            rotation: {\n                /**\n                 * The smallest degree of rotation for a word.\n                 */\n                from: 0,\n                /**\n                 * The number of possible orientations for a word, within the range\n                 * of `rotation.from` and `rotation.to`. Must be a number larger\n                 * than 0.\n                 */\n                orientations: 2,\n                /**\n                 * The largest degree of rotation for a word.\n                 */\n                to: 90\n            },\n            showInLegend: false,\n            /**\n             * Spiral used for placing a word after the initial position\n             * experienced a collision with either another word or the borders.\n             * It is possible for users to add their own custom spiralling\n             * algorithms for use in word cloud. Read more about it in our\n             * [documentation](https://www.highcharts.com/docs/chart-and-series-types/word-cloud-series#custom-spiralling-algorithm)\n             *\n             * @validvalue [\"archimedean\", \"rectangular\", \"square\"]\n             */\n            spiral: 'rectangular',\n            /**\n             * CSS styles for the words.\n             *\n             * @type    {Highcharts.CSSObject}\n             * @default {\"fontFamily\":\"sans-serif\", \"fontWeight\": \"900\"}\n             */\n            style: {\n                /** @ignore-option */\n                fontFamily: 'sans-serif',\n                /** @ignore-option */\n                fontWeight: '900',\n                /** @ignore-option */\n                whiteSpace: 'nowrap'\n            },\n            tooltip: {\n                followPointer: true,\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.weight}</b><br/>'\n            }\n        };\n        /**\n         * A `wordcloud` series. If the [type](#series.wordcloud.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.wordcloud\n         * @exclude   dataSorting, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/wordcloud\n         * @apioption series.wordcloud\n         */\n        /**\n         * An array of data points for the series. For the `wordcloud` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond to\n         *    `name,weight`.\n         *    ```js\n         *    data: [\n         *        ['Lorem', 4],\n         *        ['Ipsum', 1]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.arearange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        name: \"Lorem\",\n         *        weight: 4\n         *    }, {\n         *        name: \"Ipsum\",\n         *        weight: 1\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<string,number>|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x, y\n         * @product   highcharts\n         * @apioption series.wordcloud.data\n         */\n        /**\n         * The name decides the text for a word.\n         *\n         * @type      {string}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.name\n         */\n        /**\n         * The weighting of a word. The weight decides the relative size of a word\n         * compared to the rest of the collection.\n         *\n         * @type      {number}\n         * @since     6.0.0\n         * @product   highcharts\n         * @apioption series.wordcloud.data.weight\n         */\n        ''; // detach doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudUtils.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { deg2rad } = H;\n        const { extend, find, isNumber, isObject, merge } = U;\n        /* *\n         *\n         * Functions\n         *\n         * */\n        /**\n         * Detects if there is a collision between two rectangles.\n         *\n         * @private\n         * @function isRectanglesIntersecting\n         *\n         * @param {Highcharts.PolygonBoxObject} r1\n         * First rectangle.\n         *\n         * @param {Highcharts.PolygonBoxObject} r2\n         * Second rectangle.\n         *\n         * @return {boolean}\n         * Returns true if the rectangles overlap.\n         */\n        function isRectanglesIntersecting(r1, r2) {\n            return !(r2.left > r1.right ||\n                r2.right < r1.left ||\n                r2.top > r1.bottom ||\n                r2.bottom < r1.top);\n        }\n        /**\n         * Calculates the normals to a line between two points.\n         *\n         * @private\n         * @function getNormals\n         * @param {Highcharts.PolygonPointObject} p1\n         *        Start point for the line. Array of x and y value.\n         * @param {Highcharts.PolygonPointObject} p2\n         *        End point for the line. Array of x and y value.\n         * @return {Highcharts.PolygonObject}\n         *         Returns the two normals in an array.\n         */\n        function getNormals(p1, p2) {\n            const dx = p2[0] - p1[0], // x2 - x1\n            dy = p2[1] - p1[1]; // y2 - y1\n            return [\n                [-dy, dx],\n                [dy, -dx]\n            ];\n        }\n        /**\n         * @private\n         */\n        function getAxesFromPolygon(polygon) {\n            let points, axes = polygon.axes || [];\n            if (!axes.length) {\n                axes = [];\n                points = points = polygon.concat([polygon[0]]);\n                points.reduce((p1, p2) => {\n                    const normals = getNormals(p1, p2), axis = normals[0]; // Use the left normal as axis.\n                    // Check that the axis is unique.\n                    if (!find(axes, (existing) => existing[0] === axis[0] &&\n                        existing[1] === axis[1])) {\n                        axes.push(axis);\n                    }\n                    // Return p2 to be used as p1 in next iteration.\n                    return p2;\n                });\n                polygon.axes = axes;\n            }\n            return axes;\n        }\n        /**\n         * Projects a polygon onto a coordinate.\n         *\n         * @private\n         * @function project\n         * @param {Highcharts.PolygonObject} polygon\n         * Array of points in a polygon.\n         * @param {Highcharts.PolygonPointObject} target\n         * The coordinate of pr\n         */\n        function project(polygon, target) {\n            const products = polygon.map((point) => {\n                const ax = point[0], ay = point[1], bx = target[0], by = target[1];\n                return ax * bx + ay * by;\n            });\n            return {\n                min: Math.min.apply(this, products),\n                max: Math.max.apply(this, products)\n            };\n        }\n        /**\n         * @private\n         */\n        function isPolygonsOverlappingOnAxis(axis, polygon1, polygon2) {\n            const projection1 = project(polygon1, axis), projection2 = project(polygon2, axis), isOverlapping = !(projection2.min > projection1.max ||\n                projection2.max < projection1.min);\n            return !isOverlapping;\n        }\n        /**\n         * Checks whether two convex polygons are colliding by using the Separating\n         * Axis Theorem.\n         *\n         * @private\n         * @function isPolygonsColliding\n         * @param {Highcharts.PolygonObject} polygon1\n         *        First polygon.\n         *\n         * @param {Highcharts.PolygonObject} polygon2\n         *        Second polygon.\n         *\n         * @return {boolean}\n         *         Returns true if they are colliding, otherwise false.\n         */\n        function isPolygonsColliding(polygon1, polygon2) {\n            // Get the axis from both polygons.\n            const axes1 = getAxesFromPolygon(polygon1), axes2 = getAxesFromPolygon(polygon2), axes = axes1.concat(axes2), overlappingOnAllAxes = !find(axes, (axis) => isPolygonsOverlappingOnAxis(axis, polygon1, polygon2));\n            return overlappingOnAllAxes;\n        }\n        /**\n         * Detects if a word collides with any previously placed words.\n         *\n         * @private\n         * @function intersectsAnyWord\n         *\n         * @param {Highcharts.Point} point\n         * Point which the word is connected to.\n         *\n         * @param {Array<Highcharts.Point>} points\n         * Previously placed points to check against.\n         *\n         * @return {boolean}\n         * Returns true if there is collision.\n         */\n        function intersectsAnyWord(point, points) {\n            const rect = point.rect, polygon = point.polygon, lastCollidedWith = point.lastCollidedWith, isIntersecting = function (p) {\n                let result = isRectanglesIntersecting(rect, p.rect);\n                if (result &&\n                    (point.rotation % 90 || p.rotation % 90)) {\n                    result = isPolygonsColliding(polygon, p.polygon);\n                }\n                return result;\n            };\n            let intersects = false;\n            // If the point has already intersected a different point, chances are\n            // they are still intersecting. So as an enhancement we check this\n            // first.\n            if (lastCollidedWith) {\n                intersects = isIntersecting(lastCollidedWith);\n                // If they no longer intersects, remove the cache from the point.\n                if (!intersects) {\n                    delete point.lastCollidedWith;\n                }\n            }\n            // If not already found, then check if we can find a point that is\n            // intersecting.\n            if (!intersects) {\n                intersects = !!find(points, function (p) {\n                    const result = isIntersecting(p);\n                    if (result) {\n                        point.lastCollidedWith = p;\n                    }\n                    return result;\n                });\n            }\n            return intersects;\n        }\n        /**\n         * Gives a set of cordinates for an Archimedian Spiral.\n         *\n         * @private\n         * @function archimedeanSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function archimedeanSpiral(attempt, params) {\n            const field = params.field, maxDelta = (field.width * field.width) + (field.height * field.height), t = attempt * 0.8; // 0.2 * 4 = 0.8. Enlarging the spiral.\n            let result = false;\n            // Emergency brake. TODO make spiralling logic more foolproof.\n            if (attempt <= 10000) {\n                result = {\n                    x: t * Math.cos(t),\n                    y: t * Math.sin(t)\n                };\n                if (!(Math.min(Math.abs(result.x), Math.abs(result.y)) < maxDelta)) {\n                    result = false;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function squareSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function squareSpiral(attempt, params) {\n            const a = attempt * 4, k = Math.ceil((Math.sqrt(a) - 1) / 2), isBoolean = (x) => (typeof x === 'boolean');\n            let t = 2 * k + 1, m = Math.pow(t, 2), result = false;\n            t -= 1;\n            if (attempt <= 10000) {\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: k - (m - a),\n                        y: -k\n                    };\n                }\n                m -= t;\n                if (isBoolean(result) && a >= m - t) {\n                    result = {\n                        x: -k,\n                        y: -k + (m - a)\n                    };\n                }\n                m -= t;\n                if (isBoolean(result)) {\n                    if (a >= m - t) {\n                        result = {\n                            x: -k + (m - a),\n                            y: k\n                        };\n                    }\n                    else {\n                        result = {\n                            x: k,\n                            y: k - (m - a - t)\n                        };\n                    }\n                }\n                result.x *= 5;\n                result.y *= 5;\n            }\n            return result;\n        }\n        /**\n         * Gives a set of cordinates for an rectangular spiral.\n         *\n         * @private\n         * @function rectangularSpiral\n         *\n         * @param {number} attempt\n         * How far along the spiral we have traversed.\n         *\n         * @param {Highcharts.WordcloudSpiralParamsObject} [params]\n         * Additional parameters.\n         *\n         * @return {boolean|Higcharts.PositionObject}\n         * Resulting coordinates, x and y. False if the word should be dropped from\n         * the visualization.\n         */\n        function rectangularSpiral(attempt, params) {\n            const result = squareSpiral(attempt, params), field = params.field;\n            if (result) {\n                result.x *= field.ratioX;\n                result.y *= field.ratioY;\n            }\n            return result;\n        }\n        /**\n         * @private\n         * @function getRandomPosition\n         *\n         * @param {number} size\n         * Random factor.\n         *\n         * @return {number}\n         * Random position.\n         */\n        function getRandomPosition(size) {\n            return Math.round((size * (Math.random() + 0.5)) / 2);\n        }\n        /**\n         * Calculates the proper scale to fit the cloud inside the plotting area.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} targetWidth\n         * Width of target area.\n         *\n         * @param {number} targetHeight\n         * Height of target area.\n         *\n         * @param {Object} field\n         * The playing field.\n         *\n         * @return {number}\n         * Returns the value to scale the playing field up to the size of the target\n         * area.\n         */\n        function getScale(targetWidth, targetHeight, field) {\n            const height = Math.max(Math.abs(field.top), Math.abs(field.bottom)) * 2, width = Math.max(Math.abs(field.left), Math.abs(field.right)) * 2, scaleX = width > 0 ? 1 / width * targetWidth : 1, scaleY = height > 0 ? 1 / height * targetHeight : 1;\n            return Math.min(scaleX, scaleY);\n        }\n        /**\n         * Calculates what is called the playing field. The field is the area which\n         * all the words are allowed to be positioned within. The area is\n         * proportioned to match the target aspect ratio.\n         *\n         * @private\n         * @function getPlayingField\n         *\n         * @param {number} targetWidth\n         * Width of the target area.\n         *\n         * @param {number} targetHeight\n         * Height of the target area.\n         *\n         * @param {Array<Highcharts.Point>} data\n         * Array of points.\n         *\n         * @param {Object} data.dimensions\n         * The height and width of the word.\n         *\n         * @return {Object}\n         * The width and height of the playing field.\n         */\n        function getPlayingField(targetWidth, targetHeight, data) {\n            const info = data.reduce(function (obj, point) {\n                const dimensions = point.dimensions, x = Math.max(dimensions.width, dimensions.height);\n                // Find largest height.\n                obj.maxHeight = Math.max(obj.maxHeight, dimensions.height);\n                // Find largest width.\n                obj.maxWidth = Math.max(obj.maxWidth, dimensions.width);\n                // Sum up the total maximum area of all the words.\n                obj.area += x * x;\n                return obj;\n            }, {\n                maxHeight: 0,\n                maxWidth: 0,\n                area: 0\n            }), \n            /**\n             * Use largest width, largest height, or root of total area to give\n             * size to the playing field.\n             */\n            x = Math.max(info.maxHeight, // Have enough space for the tallest word\n            info.maxWidth, // Have enough space for the broadest word\n            // Adjust 15% to account for close packing of words\n            Math.sqrt(info.area) * 0.85), ratioX = targetWidth > targetHeight ? targetWidth / targetHeight : 1, ratioY = targetHeight > targetWidth ? targetHeight / targetWidth : 1;\n            return {\n                width: x * ratioX,\n                height: x * ratioY,\n                ratioX: ratioX,\n                ratioY: ratioY\n            };\n        }\n        /**\n         * Calculates a number of degrees to rotate, based upon a number of\n         * orientations within a range from-to.\n         *\n         * @private\n         * @function getRotation\n         *\n         * @param {number} [orientations]\n         * Number of orientations.\n         *\n         * @param {number} [index]\n         * Index of point, used to decide orientation.\n         *\n         * @param {number} [from]\n         * The smallest degree of rotation.\n         *\n         * @param {number} [to]\n         * The largest degree of rotation.\n         *\n         * @return {boolean|number}\n         * Returns the resulting rotation for the word. Returns false if invalid\n         * input parameters.\n         */\n        function getRotation(orientations, index, from, to) {\n            let result = false, // Default to false\n            range, intervals, orientation;\n            // Check if we have valid input parameters.\n            if (isNumber(orientations) &&\n                isNumber(index) &&\n                isNumber(from) &&\n                isNumber(to) &&\n                orientations > 0 &&\n                index > -1 &&\n                to > from) {\n                range = to - from;\n                intervals = range / (orientations - 1 || 1);\n                orientation = index % orientations;\n                result = from + (orientation * intervals);\n            }\n            return result;\n        }\n        /**\n         * Calculates the spiral positions and store them in scope for quick access.\n         *\n         * @private\n         * @function getSpiral\n         *\n         * @param {Function} fn\n         * The spiral function.\n         *\n         * @param {Object} params\n         * Additional parameters for the spiral.\n         *\n         * @return {Function}\n         * Function with access to spiral positions.\n         */\n        function getSpiral(fn, params) {\n            const length = 10000, arr = [];\n            for (let i = 1; i < length; i++) {\n                // @todo unnecessary amount of precaclulation\n                arr.push(fn(i, params));\n            }\n            return (attempt) => (attempt <= length ? arr[attempt - 1] : false);\n        }\n        /**\n         * Detects if a word is placed outside the playing field.\n         *\n         * @private\n         * @function outsidePlayingField\n         *\n         * @param {Highcharts.PolygonBoxObject} rect\n         * The word box.\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width and height of the playing field.\n         *\n         * @return {boolean}\n         * Returns true if the word is placed outside the field.\n         */\n        function outsidePlayingField(rect, field) {\n            const playingField = {\n                left: -(field.width / 2),\n                right: field.width / 2,\n                top: -(field.height / 2),\n                bottom: field.height / 2\n            };\n            return !(playingField.left < rect.left &&\n                playingField.right > rect.right &&\n                playingField.top < rect.top &&\n                playingField.bottom > rect.bottom);\n        }\n        /**\n         * @private\n         */\n        function movePolygon(deltaX, deltaY, polygon) {\n            return polygon.map(function (point) {\n                return [\n                    point[0] + deltaX,\n                    point[1] + deltaY\n                ];\n            });\n        }\n        /**\n         * Check if a point intersects with previously placed words, or if it goes\n         * outside the field boundaries. If a collision, then try to adjusts the\n         * position.\n         *\n         * @private\n         * @function intersectionTesting\n         *\n         * @param {Highcharts.Point} point\n         * Point to test for intersections.\n         *\n         * @param {Highcharts.WordcloudTestOptionsObject} options\n         * Options object.\n         *\n         * @return {boolean|Highcharts.PositionObject}\n         * Returns an object with how much to correct the positions. Returns false\n         * if the word should not be placed at all.\n         */\n        function intersectionTesting(point, options) {\n            const placed = options.placed, field = options.field, rectangle = options.rectangle, polygon = options.polygon, spiral = options.spiral, \n            // Make a copy to update values during intersection testing.\n            rect = point.rect = extend({}, rectangle);\n            let attempt = 1, delta = {\n                x: 0,\n                y: 0\n            };\n            point.polygon = polygon;\n            point.rotation = options.rotation;\n            /* while w intersects any previously placed words:\n                do {\n                move w a little bit along a spiral path\n                } while any part of w is outside the playing field and\n                        the spiral radius is still smallish */\n            while (delta !== false &&\n                (intersectsAnyWord(point, placed) ||\n                    outsidePlayingField(rect, field))) {\n                delta = spiral(attempt);\n                if (isObject(delta)) {\n                    // Update the DOMRect with new positions.\n                    rect.left = rectangle.left + delta.x;\n                    rect.right = rectangle.right + delta.x;\n                    rect.top = rectangle.top + delta.y;\n                    rect.bottom = rectangle.bottom + delta.y;\n                    point.polygon = movePolygon(delta.x, delta.y, polygon);\n                }\n                attempt++;\n            }\n            return delta;\n        }\n        /**\n         * Extends the playing field to have enough space to fit a given word.\n         *\n         * @private\n         * @function extendPlayingField\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The width, height and ratios of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box of the word to add space for.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns the extended playing field with updated height and width.\n         */\n        function extendPlayingField(field, rectangle) {\n            let height, width, ratioX, ratioY, x, extendWidth, extendHeight, result;\n            if (isObject(field) && isObject(rectangle)) {\n                height = (rectangle.bottom - rectangle.top);\n                width = (rectangle.right - rectangle.left);\n                ratioX = field.ratioX;\n                ratioY = field.ratioY;\n                // Use the same variable to extend both the height and width.\n                x = ((width * ratioX) > (height * ratioY)) ? width : height;\n                // Multiply variable with ratios to preserve aspect ratio.\n                extendWidth = x * ratioX;\n                extendHeight = x * ratioY;\n                // Calculate the size of the new field after adding\n                // space for the word.\n                result = merge(field, {\n                    // Add space on the left and right.\n                    width: field.width + (extendWidth * 2),\n                    // Add space on the top and bottom.\n                    height: field.height + (extendHeight * 2)\n                });\n            }\n            else {\n                result = field;\n            }\n            // Return the new extended field.\n            return result;\n        }\n        /**\n         * If a rectangle is outside a give field, then the boundaries of the field\n         * is adjusted accordingly. Modifies the field object which is passed as the\n         * first parameter.\n         *\n         * @private\n         * @function updateFieldBoundaries\n         *\n         * @param {Highcharts.WordcloudFieldObject} field\n         * The bounding box of a playing field.\n         *\n         * @param {Highcharts.PolygonBoxObject} rectangle\n         * The bounding box for a placed point.\n         *\n         * @return {Highcharts.WordcloudFieldObject}\n         * Returns a modified field object.\n         */\n        function updateFieldBoundaries(field, rectangle) {\n            // @todo improve type checking.\n            if (!isNumber(field.left) || field.left > rectangle.left) {\n                field.left = rectangle.left;\n            }\n            if (!isNumber(field.right) || field.right < rectangle.right) {\n                field.right = rectangle.right;\n            }\n            if (!isNumber(field.top) || field.top > rectangle.top) {\n                field.top = rectangle.top;\n            }\n            if (!isNumber(field.bottom) || field.bottom < rectangle.bottom) {\n                field.bottom = rectangle.bottom;\n            }\n            return field;\n        }\n        /**\n         * Alternative solution to correctFloat.\n         * E.g Highcharts.correctFloat(123, 2) returns 120, when it should be 123.\n         *\n         * @private\n         * @function correctFloat\n         */\n        function correctFloat(number, precision) {\n            const p = isNumber(precision) ? precision : 14, magnitude = Math.pow(10, p);\n            return Math.round(number * magnitude) / magnitude;\n        }\n        /**\n         * @private\n         */\n        function getBoundingBoxFromPolygon(points) {\n            return points.reduce(function (obj, point) {\n                const x = point[0], y = point[1];\n                obj.left = Math.min(x, obj.left);\n                obj.right = Math.max(x, obj.right);\n                obj.bottom = Math.max(y, obj.bottom);\n                obj.top = Math.min(y, obj.top);\n                return obj;\n            }, {\n                left: Number.MAX_VALUE,\n                right: -Number.MAX_VALUE,\n                bottom: -Number.MAX_VALUE,\n                top: Number.MAX_VALUE\n            });\n        }\n        /**\n         * @private\n         */\n        function getPolygon(x, y, width, height, rotation) {\n            const origin = [x, y], left = x - (width / 2), right = x + (width / 2), top = y - (height / 2), bottom = y + (height / 2), polygon = [\n                [left, top],\n                [right, top],\n                [right, bottom],\n                [left, bottom]\n            ];\n            return polygon.map(function (point) {\n                return rotate2DToPoint(point, origin, -rotation);\n            });\n        }\n        /**\n         * Rotates a point clockwise around the origin.\n         *\n         * @private\n         * @function rotate2DToOrigin\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToOrigin(point, angle) {\n            const x = point[0], y = point[1], rad = deg2rad * -angle, cosAngle = Math.cos(rad), sinAngle = Math.sin(rad);\n            return [\n                correctFloat(x * cosAngle - y * sinAngle),\n                correctFloat(x * sinAngle + y * cosAngle)\n            ];\n        }\n        /**\n         * Rotate a point clockwise around another point.\n         *\n         * @private\n         * @function rotate2DToPoint\n         * @param {Highcharts.PolygonPointObject} point\n         *        The x and y coordinates for the point.\n         * @param {Highcharts.PolygonPointObject} origin\n         *        The point to rotate around.\n         * @param {number} angle\n         *        The angle of rotation.\n         * @return {Highcharts.PolygonPointObject}\n         *         The x and y coordinate for the rotated point.\n         */\n        function rotate2DToPoint(point, origin, angle) {\n            const x = point[0] - origin[0], y = point[1] - origin[1], rotated = rotate2DToOrigin([x, y], angle);\n            return [\n                rotated[0] + origin[0],\n                rotated[1] + origin[1]\n            ];\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const WordcloudUtils = {\n            archimedeanSpiral,\n            extendPlayingField,\n            getBoundingBoxFromPolygon,\n            getPlayingField,\n            getPolygon,\n            getRandomPosition,\n            getRotation,\n            getScale,\n            getSpiral,\n            intersectionTesting,\n            isPolygonsColliding,\n            isRectanglesIntersecting,\n            rectangularSpiral,\n            rotate2DToOrigin,\n            rotate2DToPoint,\n            squareSpiral,\n            updateFieldBoundaries\n        };\n\n        return WordcloudUtils;\n    });\n    _registerModule(_modules, 'Series/Wordcloud/WordcloudSeries.js', [_modules['Series/DrawPointUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/Wordcloud/WordcloudPoint.js'], _modules['Series/Wordcloud/WordcloudSeriesDefaults.js'], _modules['Series/Wordcloud/WordcloudUtils.js']], function (DPU, H, SeriesRegistry, U, WordcloudPoint, WordcloudSeriesDefaults, WU) {\n        /* *\n         *\n         *  Experimental Highcharts module which enables visualization of a word cloud.\n         *\n         *  (c) 2016-2021 Highsoft AS\n         *  Authors: Jon Arild Nygard\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         * */\n        const { noop } = H;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { extend, isArray, isNumber, isObject, merge } = U;\n        const { archimedeanSpiral, extendPlayingField, getBoundingBoxFromPolygon, getPlayingField, getPolygon, getRandomPosition, getRotation, getScale, getSpiral, intersectionTesting, isPolygonsColliding, rectangularSpiral, rotate2DToOrigin, rotate2DToPoint, squareSpiral, updateFieldBoundaries } = WU;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.wordcloud\n         *\n         * @augments Highcharts.Series\n         */\n        class WordcloudSeries extends ColumnSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n            }\n            /**\n             *\n             * Functions\n             *\n             */\n            pointAttribs(point, state) {\n                const attribs = H.seriesTypes.column.prototype\n                    .pointAttribs.call(this, point, state);\n                delete attribs.stroke;\n                delete attribs['stroke-width'];\n                return attribs;\n            }\n            /**\n             * Calculates the fontSize of a word based on its weight.\n             *\n             * @private\n             * @function Highcharts.Series#deriveFontSize\n             *\n             * @param {number} [relativeWeight=0]\n             * The weight of the word, on a scale 0-1.\n             *\n             * @param {number} [maxFontSize=1]\n             * The maximum font size of a word.\n             *\n             * @param {number} [minFontSize=1]\n             * The minimum font size of a word.\n             *\n             * @return {number}\n             * Returns the resulting fontSize of a word. If minFontSize is larger then\n             * maxFontSize the result will equal minFontSize.\n             */\n            deriveFontSize(relativeWeight, maxFontSize, minFontSize) {\n                const weight = isNumber(relativeWeight) ? relativeWeight : 0, max = isNumber(maxFontSize) ? maxFontSize : 1, min = isNumber(minFontSize) ? minFontSize : 1;\n                return Math.floor(Math.max(min, weight * max));\n            }\n            drawPoints() {\n                const series = this, hasRendered = series.hasRendered, xAxis = series.xAxis, yAxis = series.yAxis, chart = series.chart, group = series.group, options = series.options, animation = options.animation, allowExtendPlayingField = options.allowExtendPlayingField, renderer = chart.renderer, placed = [], placementStrategy = series.placementStrategy[options.placementStrategy], rotation = options.rotation, weights = series.points.map(function (p) {\n                    return p.weight;\n                }), maxWeight = Math.max.apply(null, weights), \n                // concat() prevents from sorting the original array.\n                data = series.points.concat().sort((a, b) => (b.weight - a.weight // Sort descending\n                ));\n                let testElement = renderer.text().add(group), field;\n                // Reset the scale before finding the dimensions (#11993).\n                // SVGGRaphicsElement.getBBox() (used in SVGElement.getBBox(boolean))\n                // returns slightly different values for the same element depending on\n                // whether it is rendered in a group which has already defined scale\n                // (e.g. 6) or in the group without a scale (scale = 1).\n                series.group.attr({\n                    scaleX: 1,\n                    scaleY: 1\n                });\n                // Get the dimensions for each word.\n                // Used in calculating the playing field.\n                for (const point of data) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style);\n                    testElement.css(css).attr({\n                        x: 0,\n                        y: 0,\n                        text: point.name\n                    });\n                    const bBox = testElement.getBBox(true);\n                    point.dimensions = {\n                        height: bBox.height,\n                        width: bBox.width\n                    };\n                }\n                // Calculate the playing field.\n                field = getPlayingField(xAxis.len, yAxis.len, data);\n                const spiral = getSpiral(series.spirals[options.spiral], {\n                    field: field\n                });\n                // Draw all the points.\n                for (const point of data) {\n                    const relativeWeight = 1 / maxWeight * point.weight, fontSize = series.deriveFontSize(relativeWeight, options.maxFontSize, options.minFontSize), css = extend({\n                        fontSize: fontSize + 'px'\n                    }, options.style), placement = placementStrategy(point, {\n                        data: data,\n                        field: field,\n                        placed: placed,\n                        rotation: rotation\n                    }), attr = extend(series.pointAttribs(point, (point.selected && 'select')), {\n                        align: 'center',\n                        'alignment-baseline': 'middle',\n                        'dominant-baseline': 'middle',\n                        x: placement.x,\n                        y: placement.y,\n                        text: point.name,\n                        rotation: isNumber(placement.rotation) ?\n                            placement.rotation :\n                            void 0\n                    }), polygon = getPolygon(placement.x, placement.y, point.dimensions.width, point.dimensions.height, placement.rotation), rectangle = getBoundingBoxFromPolygon(polygon);\n                    let delta = intersectionTesting(point, {\n                        rectangle: rectangle,\n                        polygon: polygon,\n                        field: field,\n                        placed: placed,\n                        spiral: spiral,\n                        rotation: placement.rotation\n                    }), animate;\n                    // If there is no space for the word, extend the playing field.\n                    if (!delta && allowExtendPlayingField) {\n                        // Extend the playing field to fit the word.\n                        field = extendPlayingField(field, rectangle);\n                        // Run intersection testing one more time to place the word.\n                        delta = intersectionTesting(point, {\n                            rectangle: rectangle,\n                            polygon: polygon,\n                            field: field,\n                            placed: placed,\n                            spiral: spiral,\n                            rotation: placement.rotation\n                        });\n                    }\n                    // Check if point was placed, if so delete it, otherwise place it\n                    // on the correct positions.\n                    if (isObject(delta)) {\n                        attr.x = (attr.x || 0) + delta.x;\n                        attr.y = (attr.y || 0) + delta.y;\n                        rectangle.left += delta.x;\n                        rectangle.right += delta.x;\n                        rectangle.top += delta.y;\n                        rectangle.bottom += delta.y;\n                        field = updateFieldBoundaries(field, rectangle);\n                        placed.push(point);\n                        point.isNull = false;\n                        point.isInside = true; // #15447\n                    }\n                    else {\n                        point.isNull = true;\n                    }\n                    if (animation) {\n                        // Animate to new positions\n                        animate = {\n                            x: attr.x,\n                            y: attr.y\n                        };\n                        // Animate from center of chart\n                        if (!hasRendered) {\n                            attr.x = 0;\n                            attr.y = 0;\n                            // or animate from previous position\n                        }\n                        else {\n                            delete attr.x;\n                            delete attr.y;\n                        }\n                    }\n                    DPU.draw(point, {\n                        animatableAttribs: animate,\n                        attribs: attr,\n                        css: css,\n                        group: group,\n                        renderer: renderer,\n                        shapeArgs: void 0,\n                        shapeType: 'text'\n                    });\n                }\n                // Destroy the element after use.\n                testElement = testElement.destroy();\n                // Scale the series group to fit within the plotArea.\n                const scale = getScale(xAxis.len, yAxis.len, field);\n                series.group.attr({\n                    scaleX: scale,\n                    scaleY: scale\n                });\n            }\n            hasData() {\n                const series = this;\n                return (isObject(series) &&\n                    series.visible === true &&\n                    isArray(series.points) &&\n                    series.points.length > 0);\n            }\n            getPlotBox() {\n                const series = this, chart = series.chart, inverted = chart.inverted, \n                // Swap axes for inverted (#2339)\n                xAxis = series[(inverted ? 'yAxis' : 'xAxis')], yAxis = series[(inverted ? 'xAxis' : 'yAxis')], width = xAxis ? xAxis.len : chart.plotWidth, height = yAxis ? yAxis.len : chart.plotHeight, x = xAxis ? xAxis.left : chart.plotLeft, y = yAxis ? yAxis.top : chart.plotTop;\n                return {\n                    translateX: x + (width / 2),\n                    translateY: y + (height / 2),\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            }\n        }\n        WordcloudSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WordcloudSeriesDefaults);\n        extend(WordcloudSeries.prototype, {\n            animate: noop,\n            animateDrilldown: noop,\n            animateDrillupFrom: noop,\n            isCartesian: false,\n            pointClass: WordcloudPoint,\n            setClip: noop,\n            // Strategies used for deciding rotation and initial position of a word. To\n            // implement a custom strategy, have a look at the function random for\n            // example.\n            placementStrategy: {\n                random: function (point, options) {\n                    const field = options.field, r = options.rotation;\n                    return {\n                        x: getRandomPosition(field.width) - (field.width / 2),\n                        y: getRandomPosition(field.height) - (field.height / 2),\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                },\n                center: function (point, options) {\n                    const r = options.rotation;\n                    return {\n                        x: 0,\n                        y: 0,\n                        rotation: getRotation(r.orientations, point.index, r.from, r.to)\n                    };\n                }\n            },\n            pointArrayMap: ['weight'],\n            // Spirals used for placing a word after the initial position experienced a\n            // collision with either another word or the borders. To implement a custom\n            // spiral, look at the function archimedeanSpiral for example.\n            spirals: {\n                'archimedean': archimedeanSpiral,\n                'rectangular': rectangularSpiral,\n                'square': squareSpiral\n            },\n            utils: {\n                extendPlayingField: extendPlayingField,\n                getRotation: getRotation,\n                isPolygonsColliding: isPolygonsColliding,\n                rotate2DToOrigin: rotate2DToOrigin,\n                rotate2DToPoint: rotate2DToPoint\n            }\n        });\n        SeriesRegistry.registerSeriesType('wordcloud', WordcloudSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WordcloudSeries;\n    });\n    _registerModule(_modules, 'masters/modules/wordcloud.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","U","isNumber","draw","point","params","animatableAttribs","onComplete","css","renderer","animation","series","chart","hasRendered","options","graphic","attribs","getClassName","shouldDraw","shapeType","text","image","imageUrl","attr","shapeArgs","add","group","animate","isNew","destroy","Object","keys","length","SeriesRegistry","column","prototype","pointClass","ColumnPoint","seriesTypes","extend","WordcloudPoint","constructor","arguments","dimensions","polygon","rect","isValid","weight","allowExtendPlayingField","duration","borderWidth","clip","colorByPoint","cropThreshold","Infinity","minFontSize","maxFontSize","placementStrategy","rotation","from","orientations","to","showInLegend","spiral","style","fontFamily","fontWeight","whiteSpace","tooltip","followPointer","pointFormat","H","deg2rad","find","isObject","merge","isRectanglesIntersecting","r1","r2","left","right","top","bottom","getAxesFromPolygon","points","axes","concat","reduce","p1","p2","normals","getNormals","dx","dy","axis","existing","push","project","target","products","map","ax","ay","bx","by","min","Math","max","isPolygonsColliding","polygon1","polygon2","axes1","axes2","overlappingOnAllAxes","isPolygonsOverlappingOnAxis","projection1","projection2","isOverlapping","squareSpiral","attempt","a","k","ceil","sqrt","t","m","pow","result","x","y","correctFloat","number","precision","p","magnitude","round","rotate2DToOrigin","angle","rad","cosAngle","cos","sinAngle","sin","rotate2DToPoint","origin","rotated","archimedeanSpiral","field","maxDelta","width","height","abs","extendPlayingField","rectangle","ratioX","ratioY","extendWidth","extendHeight","getBoundingBoxFromPolygon","Number","MAX_VALUE","getPlayingField","targetWidth","targetHeight","data","info","maxHeight","maxWidth","area","getPolygon","getRandomPosition","size","random","getRotation","index","intervals","range","orientation","getScale","getSpiral","arr","i","intersectionTesting","placed","delta","intersectsAnyWord","lastCollidedWith","isIntersecting","intersects","outsidePlayingField","playingField","movePolygon","deltaX","deltaY","rectangularSpiral","updateFieldBoundaries","DPU","WordcloudSeriesDefaults","WU","noop","ColumnSeries","isArray","WordcloudSeries","pointAttribs","state","call","stroke","deriveFontSize","relativeWeight","floor","drawPoints","xAxis","yAxis","weights","maxWeight","sort","b","testElement","scaleX","scaleY","fontSize","name","bBox","getBBox","len","spirals","placement","selected","align","isNull","isInside","scale","hasData","visible","getPlotBox","inverted","plotWidth","plotHeight","plotLeft","plotTop","translateX","translateY","defaultOptions","animateDrilldown","animateDrillupFrom","isCartesian","setClip","r","center","pointArrayMap","utils","registerSeriesType"],"mappings":"AAAA;;;;;;;CAOC,GACA,SAAUA,CAAO,EACV,AAAkB,UAAlB,OAAOC,QAAuBA,OAAOC,OAAO,EAC5CF,EAAQ,OAAU,CAAGA,EACrBC,OAAOC,OAAO,CAAGF,GACV,AAAkB,YAAlB,OAAOG,QAAyBA,OAAOC,GAAG,CACjDD,OAAO,+BAAgC,CAAC,aAAa,CAAE,SAAUE,CAAU,EAGvE,OAFAL,EAAQK,GACRL,EAAQK,UAAU,CAAGA,EACdL,CACX,GAEAA,EAAQ,AAAsB,aAAtB,OAAOK,WAA6BA,WAAaC,KAAAA,EAEjE,EAAE,SAAUD,CAAU,EAClB,aACA,IAAIE,EAAWF,EAAaA,EAAWE,QAAQ,CAAG,CAAC,EACnD,SAASC,EAAgBC,CAAG,CAAEC,CAAI,CAAEC,CAAI,CAAEC,CAAE,EACnCH,EAAII,cAAc,CAACH,KACpBD,CAAG,CAACC,EAAK,CAAGE,EAAGE,KAAK,CAAC,KAAMH,GAEA,YAAvB,OAAOI,aACPC,OAAOC,aAAa,CAAC,IAAIF,YACrB,yBACA,CAAEG,OAAQ,CAAER,KAAMA,EAAMT,OAAQQ,CAAG,CAACC,EAAK,AAAC,CAAE,IAI5D,CACAF,EAAgBD,EAAU,+BAAgC,CAACA,CAAQ,CAAC,oBAAoB,CAAC,CAAE,SAAUY,CAAC,EAMlG,GAAM,CAAEC,SAAAA,CAAQ,CAAE,CAAGD,EA4ErB,MAJ2B,CACvBE,KAzDJ,SAAcC,CAAK,CAAEC,CAAM,EACvB,GAAM,CAAEC,kBAAAA,CAAiB,CAAEC,WAAAA,CAAU,CAAEC,IAAAA,CAAG,CAAEC,SAAAA,CAAQ,CAAE,CAAGJ,EACnDK,EAAY,AAACN,EAAMO,MAAM,EAAIP,EAAMO,MAAM,CAACC,KAAK,CAACC,WAAW,CAE7D,KAAK,EAEJT,EAAMO,MAAM,EACTP,EAAMO,MAAM,CAACG,OAAO,CAACJ,SAAS,CAClCK,EAAUX,EAAMW,OAAO,CAK3B,GAJAV,EAAOW,OAAO,CAAG,CACb,GAAGX,EAAOW,OAAO,CACjB,MAASZ,EAAMa,YAAY,EAC/B,EACKb,EAAMc,UAAU,GACZH,IAEGA,EADAV,AAAqB,SAArBA,EAAOc,SAAS,CACNV,EAASW,IAAI,GAElBf,AAAqB,UAArBA,EAAOc,SAAS,CACXV,EAASY,KAAK,CAAChB,EAAOiB,QAAQ,EAAI,IACvCC,IAAI,CAAClB,EAAOmB,SAAS,EAAI,CAAC,GAGrBf,CAAQ,CAACJ,EAAOc,SAAS,CAAC,CAACd,EAAOmB,SAAS,EAAI,CAAC,GAE9DpB,EAAMW,OAAO,CAAGA,EAChBA,EAAQU,GAAG,CAACpB,EAAOqB,KAAK,GAExBlB,GACAO,EAAQP,GAAG,CAACA,GAEhBO,EACKQ,IAAI,CAAClB,EAAOW,OAAO,EACnBW,OAAO,CAACrB,EAAmBD,CAAAA,EAAOuB,KAAK,EAAWlB,EAAWH,QAEjE,GAAIQ,EAAS,CACd,IAAMc,EAAU,KACZzB,EAAMW,OAAO,CAAGA,EAAWA,GAAWA,EAAQc,OAAO,GAC3B,YAAtB,OAAOtB,GACPA,GAER,CAEIuB,CAAAA,OAAOC,IAAI,CAACzB,GAAmB0B,MAAM,CACrCjB,EAAQY,OAAO,CAACrB,EAAmB,KAAK,EAAG,IAAMuB,KAGjDA,GAER,CACJ,CAQA,CAGJ,GACAvC,EAAgBD,EAAU,qCAAsC,CAACA,CAAQ,CAAC,gCAAgC,CAAEA,CAAQ,CAAC,oBAAoB,CAAC,CAAE,SAAU4C,CAAc,CAAEhC,CAAC,EAYnK,GAAM,CAAEiC,OAAQ,CAAEC,UAAW,CAAEC,WAAYC,CAAW,CAAE,CAAE,CAAE,CAAGJ,EAAeK,WAAW,CACnF,CAAEC,OAAAA,CAAM,CAAE,CAAGtC,CAMnB,OAAMuC,UAAuBH,EACzBI,aAAc,CAMV,KAAK,IAAIC,WACT,IAAI,CAACC,UAAU,CAAG,KAAK,EACvB,IAAI,CAAC7B,OAAO,CAAG,KAAK,EACpB,IAAI,CAAC8B,OAAO,CAAG,KAAK,EACpB,IAAI,CAACC,IAAI,CAAG,KAAK,EACjB,IAAI,CAAClC,MAAM,CAAG,KAAK,CACvB,CAMAmC,SAAU,CACN,MAAO,CAAA,CACX,CACJ,CAUA,OATAP,EAAOC,EAAeL,SAAS,CAAE,CAC7BY,OAAQ,CACZ,GAOOP,CACX,GACAlD,EAAgBD,EAAU,8CAA+C,EAAE,CAAE,WA6MzE,MAtKgC,CAW5B2D,wBAAyB,CAAA,EACzBtC,UAAW,CAEPuC,SAAU,GACd,EACAC,YAAa,EAIbC,KAAM,CAAA,EACNC,aAAc,CAAA,EACdC,cAAeC,IAKfC,YAAa,EAObC,YAAa,GAWbC,kBAAmB,SAOnBC,SAAU,CAINC,KAAM,EAMNC,aAAc,EAIdC,GAAI,EACR,EACAC,aAAc,CAAA,EAUdC,OAAQ,cAORC,MAAO,CAEHC,WAAY,aAEZC,WAAY,MAEZC,WAAY,QAChB,EACAC,QAAS,CACLC,cAAe,CAAA,EACfC,YAAa,sFACjB,CACJ,CAsEJ,GACAhF,EAAgBD,EAAU,qCAAsC,CAACA,CAAQ,CAAC,kBAAkB,CAAEA,CAAQ,CAAC,oBAAoB,CAAC,CAAE,SAAUkF,CAAC,CAAEtE,CAAC,EAYxI,GAAM,CAAEuE,QAAAA,CAAO,CAAE,CAAGD,EACd,CAAEhC,OAAAA,CAAM,CAAEkC,KAAAA,CAAI,CAAEvE,SAAAA,CAAQ,CAAEwE,SAAAA,CAAQ,CAAEC,MAAAA,CAAK,CAAE,CAAG1E,EAqBpD,SAAS2E,EAAyBC,CAAE,CAAEC,CAAE,EACpC,MAAO,CAAEA,CAAAA,EAAGC,IAAI,CAAGF,EAAGG,KAAK,EACvBF,EAAGE,KAAK,CAAGH,EAAGE,IAAI,EAClBD,EAAGG,GAAG,CAAGJ,EAAGK,MAAM,EAClBJ,EAAGI,MAAM,CAAGL,EAAGI,GAAG,AAAD,CACzB,CAwBA,SAASE,EAAmBvC,CAAO,EAC/B,IAAIwC,EAAQC,EAAOzC,EAAQyC,IAAI,EAAI,EAAE,CAgBrC,OAfKA,EAAKrD,MAAM,GACZqD,EAAO,EAAE,CAETD,AADkBxC,EAAQ0C,MAAM,CAAC,CAAC1C,CAAO,CAAC,EAAE,CAAC,EACtC2C,MAAM,CAAC,CAACC,EAAIC,KACf,IAAMC,EAAUC,AAjB5B,SAAoBH,CAAE,CAAEC,CAAE,EACtB,IAAMG,EAAKH,CAAE,CAAC,EAAE,CAAGD,CAAE,CAAC,EAAE,CACxBK,EAAKJ,CAAE,CAAC,EAAE,CAAGD,CAAE,CAAC,EAAE,CAClB,MAAO,CACH,CAAC,CAACK,EAAID,EAAG,CACT,CAACC,EAAI,CAACD,EAAG,CACZ,AACL,EAUuCJ,EAAIC,GAAKK,EAAOJ,CAAO,CAAC,EAAE,CAOrD,OALKjB,EAAKY,EAAM,AAACU,GAAaA,CAAQ,CAAC,EAAE,GAAKD,CAAI,CAAC,EAAE,EACjDC,CAAQ,CAAC,EAAE,GAAKD,CAAI,CAAC,EAAE,GACvBT,EAAKW,IAAI,CAACF,GAGPL,CACX,GACA7C,EAAQyC,IAAI,CAAGA,GAEZA,CACX,CAWA,SAASY,EAAQrD,CAAO,CAAEsD,CAAM,EAC5B,IAAMC,EAAWvD,EAAQwD,GAAG,CAAC,AAAChG,IAC1B,IAAMiG,EAAKjG,CAAK,CAAC,EAAE,CAAEkG,EAAKlG,CAAK,CAAC,EAAE,CAAEmG,EAAKL,CAAM,CAAC,EAAE,CAAEM,EAAKN,CAAM,CAAC,EAAE,CAClE,OAAOG,EAAKE,EAAKD,EAAKE,CAC1B,GACA,MAAO,CACHC,IAAKC,KAAKD,GAAG,CAAC7G,KAAK,CAAC,IAAI,CAAEuG,GAC1BQ,IAAKD,KAAKC,GAAG,CAAC/G,KAAK,CAAC,IAAI,CAAEuG,EAC9B,CACJ,CAwBA,SAASS,EAAoBC,CAAQ,CAAEC,CAAQ,EAE3C,IAAMC,EAAQ5B,EAAmB0B,GAAWG,EAAQ7B,EAAmB2B,GAAWzB,EAAO0B,EAAMzB,MAAM,CAAC0B,GAAQC,EAAuB,CAACxC,EAAKY,EAAM,AAACS,GAASoB,AAtB/J,CAAA,SAAqCpB,CAAI,CAAEe,CAAQ,CAAEC,CAAQ,EACzD,IAAMK,EAAclB,EAAQY,EAAUf,GAAOsB,EAAcnB,EAAQa,EAAUhB,GAAOuB,EAAgB,CAAED,CAAAA,EAAYX,GAAG,CAAGU,EAAYR,GAAG,EACnIS,EAAYT,GAAG,CAAGQ,EAAYV,GAAG,AAAD,EACpC,MAAO,CAACY,CACZ,CAAA,EAkB2LvB,EAAMe,EAAUC,IACvM,OAAOG,CACX,CAgGA,SAASK,EAAaC,CAAO,CAAElH,CAAM,EACjC,IAAMmH,EAAID,AAAU,EAAVA,EAAaE,EAAIf,KAAKgB,IAAI,CAAC,AAAChB,CAAAA,KAAKiB,IAAI,CAACH,GAAK,CAAA,EAAK,GACtDI,EAAI,EAAIH,EAAI,EAAGI,EAAInB,KAAKoB,GAAG,CAACF,EAAG,GAAIG,EAAS,CAAA,EAkChD,OAjCAH,GAAK,EACDL,GAAW,MAHgF,WAAb,OAIhEQ,GAAWP,GAAKK,EAAID,GAC9BG,CAAAA,EAAS,CACLC,EAAGP,EAAKI,CAAAA,EAAIL,CAAAA,EACZS,EAAG,CAACR,CACR,CAAA,EAEJI,GAAKD,EAVsF,WAAb,OAWhEG,GAAWP,GAAKK,EAAID,GAC9BG,CAAAA,EAAS,CACLC,EAAG,CAACP,EACJQ,EAAG,CAACR,EAAKI,CAAAA,EAAIL,CAAAA,CACjB,CAAA,EAEJK,GAAKD,EAjBsF,WAAb,OAkBhEG,IAENA,EADAP,GAAKK,EAAID,EACA,CACLI,EAAG,CAACP,EAAKI,CAAAA,EAAIL,CAAAA,EACbS,EAAGR,CACP,EAGS,CACLO,EAAGP,EACHQ,EAAGR,EAAKI,CAAAA,EAAIL,EAAII,CAAAA,CACpB,GAGRG,EAAOC,CAAC,EAAI,EACZD,EAAOE,CAAC,EAAI,GAETF,CACX,CA2VA,SAASG,EAAaC,CAAM,CAAEC,CAAS,EACnC,IAAMC,EAAInI,EAASkI,GAAaA,EAAY,GAAIE,EAAY5B,KAAKoB,GAAG,CAAC,GAAIO,GACzE,OAAO3B,KAAK6B,KAAK,CAACJ,EAASG,GAAaA,CAC5C,CA6CA,SAASE,EAAiBpI,CAAK,CAAEqI,CAAK,EAClC,IAAMT,EAAI5H,CAAK,CAAC,EAAE,CAAE6H,EAAI7H,CAAK,CAAC,EAAE,CAAEsI,EAAMlE,CAAAA,CAAAA,EAAWiE,CAAI,EAAGE,EAAWjC,KAAKkC,GAAG,CAACF,GAAMG,EAAWnC,KAAKoC,GAAG,CAACJ,GACxG,MAAO,CACHR,EAAaF,EAAIW,EAAWV,EAAIY,GAChCX,EAAaF,EAAIa,EAAWZ,EAAIU,GACnC,AACL,CAeA,SAASI,EAAgB3I,CAAK,CAAE4I,CAAM,CAAEP,CAAK,EACzC,IAAMT,EAAI5H,CAAK,CAAC,EAAE,CAAG4I,CAAM,CAAC,EAAE,CAAEf,EAAI7H,CAAK,CAAC,EAAE,CAAG4I,CAAM,CAAC,EAAE,CAAEC,EAAUT,EAAiB,CAACR,EAAGC,EAAE,CAAEQ,GAC7F,MAAO,CACHQ,CAAO,CAAC,EAAE,CAAGD,CAAM,CAAC,EAAE,CACtBC,CAAO,CAAC,EAAE,CAAGD,CAAM,CAAC,EAAE,CACzB,AACL,CA0BA,MApBuB,CACnBE,kBAjfJ,SAA2B3B,CAAO,CAAElH,CAAM,EACtC,IAAM8I,EAAQ9I,EAAO8I,KAAK,CAAEC,EAAW,AAACD,EAAME,KAAK,CAAGF,EAAME,KAAK,CAAKF,EAAMG,MAAM,CAAGH,EAAMG,MAAM,CAAG1B,EAAIL,AAAU,GAAVA,EACpGQ,EAAS,CAAA,EAWb,OATIR,GAAW,KAKP,CAAEb,CAAAA,KAAKD,GAAG,CAACC,KAAK6C,GAAG,CAACxB,AAJxBA,CAAAA,EAAS,CACLC,EAAGJ,EAAIlB,KAAKkC,GAAG,CAAChB,GAChBK,EAAGL,EAAIlB,KAAKoC,GAAG,CAAClB,EACpB,CAAA,EAC+BI,CAAC,EAAGtB,KAAK6C,GAAG,CAACxB,EAAOE,CAAC,GAAKmB,CAAO,GAC5DrB,CAAAA,EAAS,CAAA,CAAI,EAGdA,CACX,EAoeIyB,mBAtJJ,SAA4BL,CAAK,CAAEM,CAAS,EACxC,IAAIH,EAAQD,EAAOK,EAAQC,EAAQ3B,EAA8BD,EAwBjE,OAvBIrD,EAASyE,IAAUzE,EAAS+E,IAC5BH,EAAUG,EAAUvE,MAAM,CAAGuE,EAAUxE,GAAG,CAK1C+C,EAAI,AAAC,AAJLqB,CAAAA,EAASI,EAAUzE,KAAK,CAAGyE,EAAU1E,IAAI,EACzC2E,CAAAA,EAASP,EAAMO,MAAM,AAAD,EAGKJ,EAFzBK,CAAAA,EAASR,EAAMQ,MAAM,AAAD,EAEyBN,EAAQC,EAMrDvB,EAASpD,EAAMwE,EAAO,CAElBE,MAAOF,EAAME,KAAK,CAAIO,AAAc,EAN1B5B,CAAAA,EAAI0B,CAAK,EAQnBJ,OAAQH,EAAMG,MAAM,CAAIO,AAAe,EAP5B7B,CAAAA,EAAI2B,CAAK,CAQxB,IAGA5B,EAASoB,EAGNpB,CACX,EA6HI+B,0BA7EJ,SAAmC1E,CAAM,EACrC,OAAOA,EAAOG,MAAM,CAAC,SAAUhG,CAAG,CAAEa,CAAK,EACrC,IAAM4H,EAAI5H,CAAK,CAAC,EAAE,CAAE6H,EAAI7H,CAAK,CAAC,EAAE,CAKhC,OAJAb,EAAIwF,IAAI,CAAG2B,KAAKD,GAAG,CAACuB,EAAGzI,EAAIwF,IAAI,EAC/BxF,EAAIyF,KAAK,CAAG0B,KAAKC,GAAG,CAACqB,EAAGzI,EAAIyF,KAAK,EACjCzF,EAAI2F,MAAM,CAAGwB,KAAKC,GAAG,CAACsB,EAAG1I,EAAI2F,MAAM,EACnC3F,EAAI0F,GAAG,CAAGyB,KAAKD,GAAG,CAACwB,EAAG1I,EAAI0F,GAAG,EACtB1F,CACX,EAAG,CACCwF,KAAMgF,OAAOC,SAAS,CACtBhF,MAAO,CAAC+E,OAAOC,SAAS,CACxB9E,OAAQ,CAAC6E,OAAOC,SAAS,CACzB/E,IAAK8E,OAAOC,SAAS,AACzB,EACJ,EAgEIC,gBA5VJ,SAAyBC,CAAW,CAAEC,CAAY,CAAEC,CAAI,EACpD,IAAMC,EAAOD,EAAK7E,MAAM,CAAC,SAAUhG,CAAG,CAAEa,CAAK,EACzC,IAAMuC,EAAavC,EAAMuC,UAAU,CAAEqF,EAAItB,KAAKC,GAAG,CAAChE,EAAW0G,KAAK,CAAE1G,EAAW2G,MAAM,EAOrF,OALA/J,EAAI+K,SAAS,CAAG5D,KAAKC,GAAG,CAACpH,EAAI+K,SAAS,CAAE3H,EAAW2G,MAAM,EAEzD/J,EAAIgL,QAAQ,CAAG7D,KAAKC,GAAG,CAACpH,EAAIgL,QAAQ,CAAE5H,EAAW0G,KAAK,EAEtD9J,EAAIiL,IAAI,EAAIxC,EAAIA,EACTzI,CACX,EAAG,CACC+K,UAAW,EACXC,SAAU,EACVC,KAAM,CACV,GAKAxC,EAAItB,KAAKC,GAAG,CAAC0D,EAAKC,SAAS,CAC3BD,EAAKE,QAAQ,CAEb7D,AAAuB,IAAvBA,KAAKiB,IAAI,CAAC0C,EAAKG,IAAI,GAAWd,EAASQ,EAAcC,EAAeD,EAAcC,EAAe,EAAGR,EAASQ,EAAeD,EAAcC,EAAeD,EAAc,EACvK,MAAO,CACHb,MAAOrB,EAAI0B,EACXJ,OAAQtB,EAAI2B,EACZD,OAAQA,EACRC,OAAQA,CACZ,CACJ,EAgUIc,WA7DJ,SAAoBzC,CAAC,CAAEC,CAAC,CAAEoB,CAAK,CAAEC,CAAM,CAAE5F,CAAQ,EAC7C,IAAMsF,EAAS,CAAChB,EAAGC,EAAE,CAAElD,EAAOiD,EAAKqB,EAAQ,EAAIrE,EAAQgD,EAAKqB,EAAQ,EAAIpE,EAAMgD,EAAKqB,EAAS,EAAIpE,EAAS+C,EAAKqB,EAAS,EAMvH,MAAO1G,AAN8H,CACjI,CAACmC,EAAME,EAAI,CACX,CAACD,EAAOC,EAAI,CACZ,CAACD,EAAOE,EAAO,CACf,CAACH,EAAMG,EAAO,CACjB,CACckB,GAAG,CAAC,SAAUhG,CAAK,EAC9B,OAAO2I,EAAgB3I,EAAO4I,EAAQ,CAACtF,EAC3C,EACJ,EAoDIgH,kBA/YJ,SAA2BC,CAAI,EAC3B,OAAOjE,KAAK6B,KAAK,CAAC,AAACoC,EAAQjE,CAAAA,KAAKkE,MAAM,GAAK,EAAE,EAAM,EACvD,EA8YIC,YA1SJ,SAAqBjH,CAAY,CAAEkH,CAAK,CAAEnH,CAAI,CAAEE,CAAE,EAC9C,IAAIkE,EAAS,CAAA,EACNgD,EAcP,OAZI7K,EAAS0D,IACT1D,EAAS4K,IACT5K,EAASyD,IACTzD,EAAS2D,IACTD,EAAe,GACfkH,EAAQ,IACRjH,EAAKF,IAELoH,EAAYC,AADJnH,CAAAA,EAAKF,CAAG,EACKC,CAAAA,EAAe,GAAK,CAAA,EAEzCmE,EAASpE,EAAQsH,AADHH,EAAQlH,EACSmH,GAE5BhD,CACX,EA0RImD,SA3XJ,SAAkBhB,CAAW,CAAEC,CAAY,CAAEhB,CAAK,EAC9C,IAAMG,EAAS5C,AAAwD,EAAxDA,KAAKC,GAAG,CAACD,KAAK6C,GAAG,CAACJ,EAAMlE,GAAG,EAAGyB,KAAK6C,GAAG,CAACJ,EAAMjE,MAAM,GAAQmE,EAAQ3C,AAAwD,EAAxDA,KAAKC,GAAG,CAACD,KAAK6C,GAAG,CAACJ,EAAMpE,IAAI,EAAG2B,KAAK6C,GAAG,CAACJ,EAAMnE,KAAK,GACrI,OAAO0B,KAAKD,GAAG,CADuI4C,EAAQ,EAAI,EAAIA,EAAQa,EAAc,EAAYZ,EAAS,EAAI,EAAIA,EAASa,EAAe,EAErP,EAyXIgB,UA3QJ,SAAmBzL,CAAE,CAAEW,CAAM,EACzB,IAAsB+K,EAAM,EAAE,CAC9B,IAAK,IAAIC,EAAI,EAAGA,EADD,IACaA,IAExBD,EAAIpF,IAAI,CAACtG,EAAG2L,EAAGhL,IAEnB,OAAO,AAACkH,GAAaA,GALN,KAK0B6D,CAAG,CAAC7D,EAAU,EAAE,AAC7D,EAqQI+D,oBA5MJ,SAA6BlL,CAAK,CAAEU,CAAO,EACvC,IAAMyK,EAASzK,EAAQyK,MAAM,CAAEpC,EAAQrI,EAAQqI,KAAK,CAAEM,EAAY3I,EAAQ2I,SAAS,CAAE7G,EAAU9B,EAAQ8B,OAAO,CAAEmB,EAASjD,EAAQiD,MAAM,CAEvIlB,EAAOzC,EAAMyC,IAAI,CAAGN,EAAO,CAAC,EAAGkH,GAC3BlC,EAAU,EAAGiE,EAAQ,CACrBxD,EAAG,EACHC,EAAG,CACP,EAQA,IAPA7H,EAAMwC,OAAO,CAAGA,EAChBxC,EAAMsD,QAAQ,CAAG5C,EAAQ4C,QAAQ,CAM1B8H,AAAU,CAAA,IAAVA,GACFC,CAAAA,AA/WT,SAA2BrL,CAAK,CAAEgF,CAAM,EACpC,IAAMvC,EAAOzC,EAAMyC,IAAI,CAAED,EAAUxC,EAAMwC,OAAO,CAAE8I,EAAmBtL,EAAMsL,gBAAgB,CAAEC,EAAiB,SAAUtD,CAAC,EACrH,IAAIN,EAASnD,EAAyB/B,EAAMwF,EAAExF,IAAI,EAKlD,OAJIkF,GACC3H,CAAAA,EAAMsD,QAAQ,CAAG,IAAM2E,EAAE3E,QAAQ,CAAG,EAAC,GACtCqE,CAAAA,EAASnB,EAAoBhE,EAASyF,EAAEzF,OAAO,CAAA,EAE5CmF,CACX,EACI6D,EAAa,CAAA,EAsBjB,OAlBIF,GACAE,CAAAA,EAAaD,EAAeD,EAAgB,GAGxC,OAAOtL,EAAMsL,gBAAgB,CAKhCE,GACDA,CAAAA,EAAa,CAAC,CAACnH,EAAKW,EAAQ,SAAUiD,CAAC,EACnC,IAAMN,EAAS4D,EAAetD,GAI9B,OAHIN,GACA3H,CAAAA,EAAMsL,gBAAgB,CAAGrD,CAAAA,EAEtBN,CACX,EAAC,EAEE6D,CACX,EA+U2BxL,EAAOmL,IACtBM,AA1DZ,SAA6BhJ,CAAI,CAAEsG,CAAK,EACpC,IAAM2C,EAAe,CACjB/G,KAAM,CAAEoE,CAAAA,EAAME,KAAK,CAAG,CAAA,EACtBrE,MAAOmE,EAAME,KAAK,CAAG,EACrBpE,IAAK,CAAEkE,CAAAA,EAAMG,MAAM,CAAG,CAAA,EACtBpE,OAAQiE,EAAMG,MAAM,CAAG,CAC3B,EACA,MAAO,CAAEwC,CAAAA,EAAa/G,IAAI,CAAGlC,EAAKkC,IAAI,EAClC+G,EAAa9G,KAAK,CAAGnC,EAAKmC,KAAK,EAC/B8G,EAAa7G,GAAG,CAAGpC,EAAKoC,GAAG,EAC3B6G,EAAa5G,MAAM,CAAGrC,EAAKqC,MAAM,AAAD,CACxC,EA+CgCrC,EAAMsG,EAAK,GAE/BzE,EADJ8G,EAAQzH,EAAOwD,MAGX1E,EAAKkC,IAAI,CAAG0E,EAAU1E,IAAI,CAAGyG,EAAMxD,CAAC,CACpCnF,EAAKmC,KAAK,CAAGyE,EAAUzE,KAAK,CAAGwG,EAAMxD,CAAC,CACtCnF,EAAKoC,GAAG,CAAGwE,EAAUxE,GAAG,CAAGuG,EAAMvD,CAAC,CAClCpF,EAAKqC,MAAM,CAAGuE,EAAUvE,MAAM,CAAGsG,EAAMvD,CAAC,CACxC7H,EAAMwC,OAAO,CAAGmJ,AAnD5B,SAAqBC,CAAM,CAAEC,CAAM,CAAErJ,CAAO,EACxC,OAAOA,EAAQwD,GAAG,CAAC,SAAUhG,CAAK,EAC9B,MAAO,CACHA,CAAK,CAAC,EAAE,CAAG4L,EACX5L,CAAK,CAAC,EAAE,CAAG6L,EACd,AACL,EACJ,EA4CwCT,EAAMxD,CAAC,CAAEwD,EAAMvD,CAAC,CAAErF,IAElD2E,IAEJ,OAAOiE,CACX,EA+KI5E,oBAAAA,EACAhC,yBAAAA,EACAsH,kBAxaJ,SAA2B3E,CAAO,CAAElH,CAAM,EACtC,IAAM0H,EAAST,EAAaC,EAASlH,GAAS8I,EAAQ9I,EAAO8I,KAAK,CAKlE,OAJIpB,IACAA,EAAOC,CAAC,EAAImB,EAAMO,MAAM,CACxB3B,EAAOE,CAAC,EAAIkB,EAAMQ,MAAM,EAErB5B,CACX,EAkaIS,iBAAAA,EACAO,gBAAAA,EACAzB,aAAAA,EACA6E,sBAzHJ,SAA+BhD,CAAK,CAAEM,CAAS,EAc3C,MAZI,CAAA,CAACvJ,EAASiJ,EAAMpE,IAAI,GAAKoE,EAAMpE,IAAI,CAAG0E,EAAU1E,IAAI,AAAD,GACnDoE,CAAAA,EAAMpE,IAAI,CAAG0E,EAAU1E,IAAI,AAAD,EAE1B,CAAA,CAAC7E,EAASiJ,EAAMnE,KAAK,GAAKmE,EAAMnE,KAAK,CAAGyE,EAAUzE,KAAK,AAAD,GACtDmE,CAAAA,EAAMnE,KAAK,CAAGyE,EAAUzE,KAAK,AAAD,EAE5B,CAAA,CAAC9E,EAASiJ,EAAMlE,GAAG,GAAKkE,EAAMlE,GAAG,CAAGwE,EAAUxE,GAAG,AAAD,GAChDkE,CAAAA,EAAMlE,GAAG,CAAGwE,EAAUxE,GAAG,AAAD,EAExB,CAAA,CAAC/E,EAASiJ,EAAMjE,MAAM,GAAKiE,EAAMjE,MAAM,CAAGuE,EAAUvE,MAAM,AAAD,GACzDiE,CAAAA,EAAMjE,MAAM,CAAGuE,EAAUvE,MAAM,AAAD,EAE3BiE,CACX,CA2GA,CAGJ,GACA7J,EAAgBD,EAAU,sCAAuC,CAACA,CAAQ,CAAC,+BAA+B,CAAEA,CAAQ,CAAC,kBAAkB,CAAEA,CAAQ,CAAC,gCAAgC,CAAEA,CAAQ,CAAC,oBAAoB,CAAEA,CAAQ,CAAC,qCAAqC,CAAEA,CAAQ,CAAC,8CAA8C,CAAEA,CAAQ,CAAC,qCAAqC,CAAC,CAAE,SAAU+M,CAAG,CAAE7H,CAAC,CAAEtC,CAAc,CAAEhC,CAAC,CAAEuC,CAAc,CAAE6J,CAAuB,CAAEC,CAAE,EAYzb,GAAM,CAAEC,KAAAA,CAAI,CAAE,CAAGhI,EACX,CAAErC,OAAQsK,CAAY,CAAE,CAAGvK,EAAeK,WAAW,CACrD,CAAEC,OAAAA,CAAM,CAAEkK,QAAAA,CAAO,CAAEvM,SAAAA,CAAQ,CAAEwE,SAAAA,CAAQ,CAAEC,MAAAA,CAAK,CAAE,CAAG1E,EACjD,CAAEiJ,kBAAAA,CAAiB,CAAEM,mBAAAA,CAAkB,CAAEM,0BAAAA,CAAyB,CAAEG,gBAAAA,CAAe,CAAEQ,WAAAA,CAAU,CAAEC,kBAAAA,CAAiB,CAAEG,YAAAA,CAAW,CAAEK,SAAAA,CAAQ,CAAEC,UAAAA,CAAS,CAAEG,oBAAAA,CAAmB,CAAE1E,oBAAAA,CAAmB,CAAEsF,kBAAAA,CAAiB,CAAE1D,iBAAAA,CAAgB,CAAEO,gBAAAA,CAAe,CAAEzB,aAAAA,CAAY,CAAE6E,sBAAAA,CAAqB,CAAE,CAAGG,CAapS,OAAMI,UAAwBF,EAC1B/J,aAAc,CAMV,KAAK,IAAIC,WAMT,IAAI,CAAC0H,IAAI,CAAG,KAAK,EACjB,IAAI,CAACtJ,OAAO,CAAG,KAAK,EACpB,IAAI,CAACsE,MAAM,CAAG,KAAK,CACvB,CAMAuH,aAAavM,CAAK,CAAEwM,CAAK,CAAE,CACvB,IAAM5L,EAAUuD,EAAEjC,WAAW,CAACJ,MAAM,CAACC,SAAS,CACzCwK,YAAY,CAACE,IAAI,CAAC,IAAI,CAAEzM,EAAOwM,GAGpC,OAFA,OAAO5L,EAAQ8L,MAAM,CACrB,OAAO9L,CAAO,CAAC,eAAe,CACvBA,CACX,CAoBA+L,eAAeC,CAAc,CAAExJ,CAAW,CAAED,CAAW,CAAE,CACrD,IAAMR,EAAS7C,EAAS8M,GAAkBA,EAAiB,EAAGrG,EAAMzG,EAASsD,GAAeA,EAAc,EAAGiD,EAAMvG,EAASqD,GAAeA,EAAc,EACzJ,OAAOmD,KAAKuG,KAAK,CAACvG,KAAKC,GAAG,CAACF,EAAK1D,EAAS4D,GAC7C,CACAuG,YAAa,CACT,IAAqBrM,EAAcF,AAApB,IAAI,CAAuBE,WAAW,CAAEsM,EAAQxM,AAAhD,IAAI,CAAmDwM,KAAK,CAAEC,EAAQzM,AAAtE,IAAI,CAAyEyM,KAAK,CAAExM,EAAQD,AAA5F,IAAI,CAA+FC,KAAK,CAAEc,EAAQf,AAAlH,IAAI,CAAqHe,KAAK,CAAEZ,EAAUH,AAA1I,IAAI,CAA6IG,OAAO,CAAEJ,EAAYI,EAAQJ,SAAS,CAAEsC,EAA0BlC,EAAQkC,uBAAuB,CAAEvC,EAAWG,EAAMH,QAAQ,CAAE8K,EAAS,EAAE,CAAE9H,EAAoB9C,AAAhT,IAAI,CAAmT8C,iBAAiB,CAAC3C,EAAQ2C,iBAAiB,CAAC,CAAEC,EAAW5C,EAAQ4C,QAAQ,CAAE2J,EAAU1M,AAA5Y,IAAI,CAA+YyE,MAAM,CAACgB,GAAG,CAAC,SAAUiC,CAAC,EACpb,OAAOA,EAAEtF,MAAM,AACnB,GAAIuK,EAAY5G,KAAKC,GAAG,CAAC/G,KAAK,CAAC,KAAMyN,GAErCjD,EAAOzJ,AAJQ,IAAI,CAILyE,MAAM,CAACE,MAAM,GAAGiI,IAAI,CAAC,CAAC/F,EAAGgG,IAAOA,EAAEzK,MAAM,CAAGyE,EAAEzE,MAAM,EAE7D0K,EAAchN,EAASW,IAAI,GAAGK,GAAG,CAACC,GAAQyH,EAY9C,IAAK,IAAM/I,KANXO,AAZe,IAAI,CAYZe,KAAK,CAACH,IAAI,CAAC,CACdmM,OAAQ,EACRC,OAAQ,CACZ,GAGoBvD,GAAM,CACtB,IAAM4C,EAAiB,EAAIM,EAAYlN,EAAM2C,MAAM,CAAE6K,EAAWjN,AAnBrD,IAAI,CAmBwDoM,cAAc,CAACC,EAAgBlM,EAAQ0C,WAAW,CAAE1C,EAAQyC,WAAW,EAAG/C,EAAM+B,EAAO,CAC1JqL,SAAUA,EAAW,IACzB,EAAG9M,EAAQkD,KAAK,EAChByJ,EAAYjN,GAAG,CAACA,GAAKe,IAAI,CAAC,CACtByG,EAAG,EACHC,EAAG,EACH7G,KAAMhB,EAAMyN,IAAI,AACpB,GACA,IAAMC,EAAOL,EAAYM,OAAO,CAAC,CAAA,EACjC3N,CAAAA,EAAMuC,UAAU,CAAG,CACf2G,OAAQwE,EAAKxE,MAAM,CACnBD,MAAOyE,EAAKzE,KAAK,AACrB,CACJ,CAEAF,EAAQc,EAAgBkD,EAAMa,GAAG,CAAEZ,EAAMY,GAAG,CAAE5D,GAC9C,IAAMrG,EAASoH,EAAUxK,AAnCV,IAAI,CAmCasN,OAAO,CAACnN,EAAQiD,MAAM,CAAC,CAAE,CACrDoF,MAAOA,CACX,GAEA,IAAK,IAAM/I,KAASgK,EAAM,CACtB,IAAM4C,EAAiB,EAAIM,EAAYlN,EAAM2C,MAAM,CAAE6K,EAAWjN,AAxCrD,IAAI,CAwCwDoM,cAAc,CAACC,EAAgBlM,EAAQ0C,WAAW,CAAE1C,EAAQyC,WAAW,EAAG/C,EAAM+B,EAAO,CAC1JqL,SAAUA,EAAW,IACzB,EAAG9M,EAAQkD,KAAK,EAAGkK,EAAYzK,EAAkBrD,EAAO,CACpDgK,KAAMA,EACNjB,MAAOA,EACPoC,OAAQA,EACR7H,SAAUA,CACd,GAAInC,EAAOgB,EAAO5B,AA/CP,IAAI,CA+CUgM,YAAY,CAACvM,EAAQA,EAAM+N,QAAQ,EAAI,UAAY,CACxEC,MAAO,SACP,qBAAsB,SACtB,oBAAqB,SACrBpG,EAAGkG,EAAUlG,CAAC,CACdC,EAAGiG,EAAUjG,CAAC,CACd7G,KAAMhB,EAAMyN,IAAI,CAChBnK,SAAUxD,EAASgO,EAAUxK,QAAQ,EACjCwK,EAAUxK,QAAQ,CAClB,KAAK,CACb,GAAId,EAAU6H,EAAWyD,EAAUlG,CAAC,CAAEkG,EAAUjG,CAAC,CAAE7H,EAAMuC,UAAU,CAAC0G,KAAK,CAAEjJ,EAAMuC,UAAU,CAAC2G,MAAM,CAAE4E,EAAUxK,QAAQ,EAAG+F,EAAYK,EAA0BlH,GAC3J4I,EAAQF,EAAoBlL,EAAO,CACnCqJ,UAAWA,EACX7G,QAASA,EACTuG,MAAOA,EACPoC,OAAQA,EACRxH,OAAQA,EACRL,SAAUwK,EAAUxK,QAAQ,AAChC,GAAI/B,CAEA,EAAC6J,GAASxI,IAEVmG,EAAQK,EAAmBL,EAAOM,GAElC+B,EAAQF,EAAoBlL,EAAO,CAC/BqJ,UAAWA,EACX7G,QAASA,EACTuG,MAAOA,EACPoC,OAAQA,EACRxH,OAAQA,EACRL,SAAUwK,EAAUxK,QAAQ,AAChC,IAIAgB,EAAS8G,IACTjK,EAAKyG,CAAC,CAAG,AAACzG,CAAAA,EAAKyG,CAAC,EAAI,CAAA,EAAKwD,EAAMxD,CAAC,CAChCzG,EAAK0G,CAAC,CAAG,AAAC1G,CAAAA,EAAK0G,CAAC,EAAI,CAAA,EAAKuD,EAAMvD,CAAC,CAChCwB,EAAU1E,IAAI,EAAIyG,EAAMxD,CAAC,CACzByB,EAAUzE,KAAK,EAAIwG,EAAMxD,CAAC,CAC1ByB,EAAUxE,GAAG,EAAIuG,EAAMvD,CAAC,CACxBwB,EAAUvE,MAAM,EAAIsG,EAAMvD,CAAC,CAC3BkB,EAAQgD,EAAsBhD,EAAOM,GACrC8B,EAAOvF,IAAI,CAAC5F,GACZA,EAAMiO,MAAM,CAAG,CAAA,EACfjO,EAAMkO,QAAQ,CAAG,CAAA,GAGjBlO,EAAMiO,MAAM,CAAG,CAAA,EAEf3N,IAEAiB,EAAU,CACNqG,EAAGzG,EAAKyG,CAAC,CACTC,EAAG1G,EAAK0G,CAAC,AACb,EAEKpH,GAMD,OAAOU,EAAKyG,CAAC,CACb,OAAOzG,EAAK0G,CAAC,GANb1G,EAAKyG,CAAC,CAAG,EACTzG,EAAK0G,CAAC,CAAG,IAQjBmE,EAAIjM,IAAI,CAACC,EAAO,CACZE,kBAAmBqB,EACnBX,QAASO,EACTf,IAAKA,EACLkB,MAAOA,EACPjB,SAAUA,EACVe,UAAW,KAAK,EAChBL,UAAW,MACf,EACJ,CAEAsM,EAAcA,EAAY5L,OAAO,GAEjC,IAAM0M,EAAQrD,EAASiC,EAAMa,GAAG,CAAEZ,EAAMY,GAAG,CAAE7E,GAC7CxI,AAhIe,IAAI,CAgIZe,KAAK,CAACH,IAAI,CAAC,CACdmM,OAAQa,EACRZ,OAAQY,CACZ,EACJ,CACAC,SAAU,CAEN,OAAQ9J,EADO,IAAI,GAEf/D,AAAmB,CAAA,IAAnBA,AAFW,IAAI,CAER8N,OAAO,EACdhC,EAAQ9L,AAHG,IAAI,CAGAyE,MAAM,GACrBzE,AAJW,IAAI,CAIRyE,MAAM,CAACpD,MAAM,CAAG,CAC/B,CACA0M,YAAa,CACT,IAAqB9N,EAAQD,AAAd,IAAI,CAAiBC,KAAK,CAAE+N,EAAW/N,EAAM+N,QAAQ,CAEpExB,EAAQxM,AAFO,IAAI,AAEL,CAAEgO,EAAW,QAAU,QAAS,CAAEvB,EAAQzM,AAFzC,IAAI,AAE2C,CAAEgO,EAAW,QAAU,QAAS,CAAEtF,EAAQ8D,EAAQA,EAAMa,GAAG,CAAGpN,EAAMgO,SAAS,CAAEtF,EAAS8D,EAAQA,EAAMY,GAAG,CAAGpN,EAAMiO,UAAU,CAAE7G,EAAImF,EAAQA,EAAMpI,IAAI,CAAGnE,EAAMkO,QAAQ,CAAE7G,EAAImF,EAAQA,EAAMnI,GAAG,CAAGrE,EAAMmO,OAAO,CAC1Q,MAAO,CACHC,WAAYhH,EAAKqB,EAAQ,EACzB4F,WAAYhH,EAAKqB,EAAS,EAC1BoE,OAAQ,EACRC,OAAQ,CACZ,CACJ,CACJ,CAsDA,OArDAjB,EAAgBwC,cAAc,CAAGvK,EAAM6H,EAAa0C,cAAc,CAAE7C,GACpE9J,EAAOmK,EAAgBvK,SAAS,CAAE,CAC9BR,QAAS4K,EACT4C,iBAAkB5C,EAClB6C,mBAAoB7C,EACpB8C,YAAa,CAAA,EACbjN,WAAYI,EACZ8M,QAAS/C,EAIT9I,kBAAmB,CACfmH,OAAQ,SAAUxK,CAAK,CAAEU,CAAO,EAC5B,IAAMqI,EAAQrI,EAAQqI,KAAK,CAAEoG,EAAIzO,EAAQ4C,QAAQ,CACjD,MAAO,CACHsE,EAAG0C,EAAkBvB,EAAME,KAAK,EAAKF,EAAME,KAAK,CAAG,EACnDpB,EAAGyC,EAAkBvB,EAAMG,MAAM,EAAKH,EAAMG,MAAM,CAAG,EACrD5F,SAAUmH,EAAY0E,EAAE3L,YAAY,CAAExD,EAAM0K,KAAK,CAAEyE,EAAE5L,IAAI,CAAE4L,EAAE1L,EAAE,CACnE,CACJ,EACA2L,OAAQ,SAAUpP,CAAK,CAAEU,CAAO,EAC5B,IAAMyO,EAAIzO,EAAQ4C,QAAQ,CAC1B,MAAO,CACHsE,EAAG,EACHC,EAAG,EACHvE,SAAUmH,EAAY0E,EAAE3L,YAAY,CAAExD,EAAM0K,KAAK,CAAEyE,EAAE5L,IAAI,CAAE4L,EAAE1L,EAAE,CACnE,CACJ,CACJ,EACA4L,cAAe,CAAC,SAAS,CAIzBxB,QAAS,CACL,YAAe/E,EACf,YAAegD,EACf,OAAU5E,CACd,EACAoI,MAAO,CACHlG,mBAAoBA,EACpBqB,YAAaA,EACbjE,oBAAqBA,EACrB4B,iBAAkBA,EAClBO,gBAAiBA,CACrB,CACJ,GACA9G,EAAe0N,kBAAkB,CAAC,YAAajD,GAOxCA,CACX,GACApN,EAAgBD,EAAU,mCAAoC,EAAE,CAAE,WAGlE,EACJ"}