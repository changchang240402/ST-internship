{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2021 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/marker-clusters', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterDefaults.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Options for marker clusters, the concept of sampling the data\n         * values into larger blocks in order to ease readability and\n         * increase performance of the JavaScript charts.\n         *\n         * Note: marker clusters module is not working with `boost`\n         * and `draggable-points` modules.\n         *\n         * The marker clusters feature requires the marker-clusters.js\n         * file to be loaded, found in the modules directory of the download\n         * package, or online at [code.highcharts.com/modules/marker-clusters.js\n         * ](code.highcharts.com/modules/marker-clusters.js).\n         *\n         * @sample maps/marker-clusters/europe\n         *         Maps marker clusters\n         * @sample highcharts/marker-clusters/basic\n         *         Scatter marker clusters\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Marker clusters with colorAxis\n         *\n         * @product      highcharts highmaps\n         * @since 8.0.0\n         * @optionparent plotOptions.scatter.cluster\n         *\n         * @private\n         */\n        const cluster = {\n            /**\n             * Whether to enable the marker-clusters module.\n             *\n             * @sample maps/marker-clusters/basic\n             *         Maps marker clusters\n             * @sample highcharts/marker-clusters/basic\n             *         Scatter marker clusters\n             */\n            enabled: false,\n            /**\n             * When set to `false` prevent cluster overlapping - this option\n             * works only when `layoutAlgorithm.type = \"grid\"`.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Prevent overlapping\n             */\n            allowOverlap: true,\n            /**\n             * Options for the cluster marker animation.\n             * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n             * @default { \"duration\": 500 }\n             */\n            animation: {\n                /** @ignore-option */\n                duration: 500\n            },\n            /**\n             * Zoom the plot area to the cluster points range when a cluster is clicked.\n             */\n            drillToCluster: true,\n            /**\n             * The minimum amount of points to be combined into a cluster.\n             * This value has to be greater or equal to 2.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         At least three points in the cluster\n             */\n            minimumClusterSize: 2,\n            /**\n             * Options for layout algorithm. Inside there\n             * are options to change the type of the algorithm, gridSize,\n             * distance or iterations.\n             */\n            layoutAlgorithm: {\n                /**\n                 * Type of the algorithm used to combine points into a cluster.\n                 * There are three available algorithms:\n                 *\n                 * 1) `grid` - grid-based clustering technique. Points are assigned\n                 * to squares of set size depending on their position on the plot\n                 * area. Points inside the grid square are combined into a cluster.\n                 * The grid size can be controlled by `gridSize` property\n                 * (grid size changes at certain zoom levels).\n                 *\n                 * 2) `kmeans` - based on K-Means clustering technique. In the\n                 * first step, points are divided using the grid method (distance\n                 * property is a grid size) to find the initial amount of clusters.\n                 * Next, each point is classified by computing the distance between\n                 * each cluster center and that point. When the closest cluster\n                 * distance is lower than distance property set by a user the point\n                 * is added to this cluster otherwise is classified as `noise`. The\n                 * algorithm is repeated until each cluster center not change its\n                 * previous position more than one pixel. This technique is more\n                 * accurate but also more time consuming than the `grid` algorithm,\n                 * especially for big datasets.\n                 *\n                 * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n                 * algorithm uses k-means algorithm only on the chart initialization\n                 * or when chart extremes have greater range than on initialization.\n                 * When a chart is redrawn the algorithm checks only clustered points\n                 * distance from the cluster center and rebuild it when the point is\n                 * spaced enough to be outside the cluster. It provides performance\n                 * improvement and more stable clusters position yet can be used rather\n                 * on small and sparse datasets.\n                 *\n                 * By default, the algorithm depends on visible quantity of points\n                 * and `kmeansThreshold`. When there are more visible points than the\n                 * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n                 *\n                 * The custom clustering algorithm can be added by assigning a callback\n                 * function as the type property. This function takes an array of\n                 * `processedXData`, `processedYData`, `processedXData` indexes and\n                 * `layoutAlgorithm` options as arguments and should return an object\n                 * with grouped data.\n                 *\n                 * The algorithm should return an object like that:\n                 * <pre>{\n                 *  clusterId1: [{\n                 *      x: 573,\n                 *      y: 285,\n                 *      index: 1 // point index in the data array\n                 *  }, {\n                 *      x: 521,\n                 *      y: 197,\n                 *      index: 2\n                 *  }],\n                 *  clusterId2: [{\n                 *      ...\n                 *  }]\n                 *  ...\n                 * }</pre>\n                 *\n                 * `clusterId` (example above - unique id of a cluster or noise)\n                 * is an array of points belonging to a cluster. If the\n                 * array has only one point or fewer points than set in\n                 * `cluster.minimumClusterSize` it won't be combined into a cluster.\n                 *\n                 * @sample maps/marker-clusters/optimized-kmeans\n                 *         Optimized K-Means algorithm\n                 * @sample highcharts/marker-clusters/kmeans\n                 *         K-Means algorithm\n                 * @sample highcharts/marker-clusters/grid\n                 *         Grid algorithm\n                 * @sample maps/marker-clusters/custom-alg\n                 *         Custom algorithm\n                 *\n                 * @type {string|Function}\n                 * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n                 */\n                /**\n                 * When `type` is set to the `grid`,\n                 * `gridSize` is a size of a grid square element either as a number\n                 * defining pixels, or a percentage defining a percentage\n                 * of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                gridSize: 50,\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `iterations` are the number of iterations that this algorithm will be\n                 * repeated to find clusters positions.\n                 *\n                 * @type    {number}\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n                 */\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `distance` is a maximum distance between point and cluster center\n                 * so that this point will be inside the cluster. The distance\n                 * is either a number defining pixels or a percentage\n                 * defining a percentage of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                distance: 40,\n                /**\n                 * When `type` is set to `undefined` and there are more visible points\n                 * than the kmeansThreshold the `grid` algorithm is used to find\n                 * clusters, otherwise `kmeans`. It ensures good performance on\n                 * large datasets and better clusters arrangement after the zoom.\n                 */\n                kmeansThreshold: 100\n            },\n            /**\n             * Options for the cluster marker.\n             * @type      {Highcharts.PointMarkerOptionsObject}\n             * @extends   plotOptions.series.marker\n             * @excluding enabledThreshold, states\n             */\n            marker: {\n                /** @internal */\n                symbol: 'cluster',\n                /** @internal */\n                radius: 15,\n                /** @internal */\n                lineWidth: 0,\n                /** @internal */\n                lineColor: \"#ffffff\" /* Palette.backgroundColor */\n            },\n            /**\n             * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n             * One parameter, `event`, is passed to the function. The default action\n             * is to zoom to the cluster points range. This can be prevented\n             * by calling `event.preventDefault()`.\n             *\n             * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n             * @product   highcharts highmaps\n             * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n             * @apioption plotOptions.scatter.cluster.events.drillToCluster\n             */\n            /**\n             * An array defining zones within marker clusters.\n             *\n             * In styled mode, the color zones are styled with the\n             * `.highcharts-cluster-zone-{n}` class, or custom\n             * classed from the `className`\n             * option.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         Marker clusters zones\n             * @sample maps/marker-clusters/custom-alg\n             *         Zones on maps\n             *\n             * @type      {Array<*>}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones\n             */\n            /**\n             * Styled mode only. A custom class name for the zone.\n             *\n             * @sample highcharts/css/color-zones/\n             *         Zones styled by class name\n             *\n             * @type      {string}\n             * @apioption plotOptions.scatter.cluster.zones.className\n             */\n            /**\n             * Settings for the cluster marker belonging to the zone.\n             *\n             * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n             * @extends   plotOptions.scatter.cluster.marker\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.marker\n             */\n            /**\n             * The value where the zone starts.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.from\n             */\n            /**\n             * The value where the zone ends.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.to\n             */\n            /**\n             * The fill color of the cluster marker in hover state. When\n             * `undefined`, the series' or point's fillColor for normal\n             * state is used.\n             *\n             * @type      {Highcharts.ColorType}\n             * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n             */\n            /**\n             * Options for the cluster data labels.\n             * @type    {Highcharts.DataLabelsOptions}\n             */\n            dataLabels: {\n                /** @internal */\n                enabled: true,\n                /** @internal */\n                format: '{point.clusterPointsAmount}',\n                /** @internal */\n                verticalAlign: 'middle',\n                /** @internal */\n                align: 'center',\n                /** @internal */\n                style: {\n                    color: 'contrast'\n                },\n                /** @internal */\n                inside: true\n            }\n        };\n        const tooltip = {\n            /**\n             * The HTML of the cluster point's in the tooltip. Works only with\n             * marker-clusters module and analogously to\n             * [pointFormat](#tooltip.pointFormat).\n             *\n             * The cluster tooltip can be also formatted using\n             * `tooltip.formatter` callback function and `point.isCluster` flag.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Format tooltip for cluster points.\n             *\n             * @sample maps/marker-clusters/europe/\n             *         Format tooltip for clusters using tooltip.formatter\n             *\n             * @type      {string}\n             * @default   Clustered points: {point.clusterPointsAmount}\n             * @apioption tooltip.clusterFormat\n             */\n            clusterFormat: '<span>Clustered points: ' +\n                '{point.clusterPointsAmount}</span><br/>'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterDefaults = {\n            cluster,\n            tooltip\n        };\n\n        return MarkerClusterDefaults;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterScatter.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Core/Utilities.js']], function (A, MarkerClusterDefaults, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { cluster: clusterDefaults } = MarkerClusterDefaults;\n        const { addEvent, defined, error, isArray, isFunction, isObject, isNumber, merge, objectEach, pushUnique, relativeLength, syncTimeout } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        const markerClusterAlgorithms = {\n            grid: function (dataX, dataY, dataIndexes, options) {\n                const series = this, grid = {}, gridOffset = this.getGridOffset();\n                let x, y, gridX, gridY, key, i;\n                // drawGridLines(series, options);\n                const scaledGridSize = series.getScaledGridSize(options);\n                for (i = 0; i < dataX.length; i++) {\n                    const p = valuesToPixels(series, { x: dataX[i], y: dataY[i] });\n                    x = p.x - gridOffset.plotLeft;\n                    y = p.y - gridOffset.plotTop;\n                    gridX = Math.floor(x / scaledGridSize);\n                    gridY = Math.floor(y / scaledGridSize);\n                    key = gridY + '-' + gridX;\n                    if (!grid[key]) {\n                        grid[key] = [];\n                    }\n                    grid[key].push({\n                        dataIndex: dataIndexes[i],\n                        x: dataX[i],\n                        y: dataY[i]\n                    });\n                }\n                return grid;\n            },\n            kmeans: function (dataX, dataY, dataIndexes, options) {\n                const series = this, clusters = [], noise = [], group = {}, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.distance, iterations = options.iterations, \n                // Max pixel difference beetwen new and old cluster position.\n                maxClusterShift = 1;\n                let currentIteration = 0, repeat = true, pointX = 0, pointY = 0, tempPos, pointClusterDistance = [];\n                options.processedGridSize = options.processedDistance;\n                // Use grid method to get groupedData object.\n                const groupedData = series.markerClusterAlgorithms ?\n                    series.markerClusterAlgorithms.grid.call(series, dataX, dataY, dataIndexes, options) : {};\n                // Find clusters amount and its start positions\n                // based on grid grouped data.\n                for (const key in groupedData) {\n                    if (groupedData[key].length > 1) {\n                        tempPos = getClusterPosition(groupedData[key]);\n                        clusters.push({\n                            posX: tempPos.x,\n                            posY: tempPos.y,\n                            oldX: 0,\n                            oldY: 0,\n                            startPointsLen: groupedData[key].length,\n                            points: []\n                        });\n                    }\n                }\n                // Start kmeans iteration process.\n                while (repeat) {\n                    for (const c of clusters) {\n                        c.points.length = 0;\n                    }\n                    noise.length = 0;\n                    for (let i = 0; i < dataX.length; i++) {\n                        pointX = dataX[i];\n                        pointY = dataY[i];\n                        pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                        if (pointClusterDistance.length &&\n                            pointClusterDistance[0].distance < pointMaxDistance) {\n                            clusters[pointClusterDistance[0].clusterIndex].points.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                        else {\n                            noise.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                    }\n                    // When cluster points array has only one point the\n                    // point should be classified again.\n                    for (let i = 0; i < clusters.length; i++) {\n                        if (clusters[i].points.length === 1) {\n                            pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                            if (pointClusterDistance[1].distance < pointMaxDistance) {\n                                // Add point to the next closest cluster.\n                                clusters[pointClusterDistance[1].clusterIndex].points\n                                    .push(clusters[i].points[0]);\n                                // Clear points array.\n                                clusters[pointClusterDistance[0].clusterIndex]\n                                    .points.length = 0;\n                            }\n                        }\n                    }\n                    // Compute a new clusters position and check if it\n                    // is different than the old one.\n                    repeat = false;\n                    for (let i = 0; i < clusters.length; i++) {\n                        tempPos = getClusterPosition(clusters[i].points);\n                        clusters[i].oldX = clusters[i].posX;\n                        clusters[i].oldY = clusters[i].posY;\n                        clusters[i].posX = tempPos.x;\n                        clusters[i].posY = tempPos.y;\n                        // Repeat the algorithm if at least one cluster\n                        // is shifted more than maxClusterShift property.\n                        if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                            clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                            clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                            clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                            repeat = true;\n                        }\n                    }\n                    // If iterations property is set repeat the algorithm\n                    // specified amount of times.\n                    if (iterations) {\n                        repeat = currentIteration < iterations - 1;\n                    }\n                    currentIteration++;\n                }\n                for (let i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n                    group['cluster' + i] = clusters[i].points;\n                }\n                for (let i = 0, iEnd = noise.length; i < iEnd; ++i) {\n                    group['noise' + i] = [noise[i]];\n                }\n                return group;\n            },\n            optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n                const series = this, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.gridSize, extremes = series.getRealExtremes(), clusterMarkerOptions = (series.options.cluster || {}).marker;\n                let distance, group = {}, offset, radius;\n                if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n                    series.initMinX && series.initMinX > extremes.minX ||\n                    series.initMaxY && series.initMaxY < extremes.maxY ||\n                    series.initMinY && series.initMinY > extremes.minY)) {\n                    series.initMaxX = extremes.maxX;\n                    series.initMinX = extremes.minX;\n                    series.initMaxY = extremes.maxY;\n                    series.initMinY = extremes.minY;\n                    group = series.markerClusterAlgorithms ?\n                        series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n                    series.baseClusters = null;\n                }\n                else {\n                    if (!series.baseClusters) {\n                        series.baseClusters = {\n                            clusters: series.markerClusterInfo.clusters,\n                            noise: series.markerClusterInfo.noise\n                        };\n                    }\n                    for (const cluster of series.baseClusters.clusters) {\n                        cluster.pointsOutside = [];\n                        cluster.pointsInside = [];\n                        for (const dataPoint of cluster.data) {\n                            const dataPointPx = valuesToPixels(series, dataPoint), clusterPx = valuesToPixels(series, cluster);\n                            distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                                Math.pow(dataPointPx.y - clusterPx.y, 2));\n                            if (cluster.clusterZone &&\n                                cluster.clusterZone.marker &&\n                                cluster.clusterZone.marker.radius) {\n                                radius = cluster.clusterZone.marker.radius;\n                            }\n                            else if (clusterMarkerOptions &&\n                                clusterMarkerOptions.radius) {\n                                radius = clusterMarkerOptions.radius;\n                            }\n                            else {\n                                radius = clusterDefaults.marker.radius;\n                            }\n                            offset = pointMaxDistance - radius >= 0 ?\n                                pointMaxDistance - radius : radius;\n                            if (distance > radius + offset &&\n                                defined(cluster.pointsOutside)) {\n                                cluster.pointsOutside.push(dataPoint);\n                            }\n                            else if (defined(cluster.pointsInside)) {\n                                cluster.pointsInside.push(dataPoint);\n                            }\n                        }\n                        if (cluster.pointsInside.length) {\n                            group[cluster.id] = cluster.pointsInside;\n                        }\n                        let i = 0;\n                        for (const p of cluster.pointsOutside) {\n                            group[cluster.id + '_noise' + i++] = [p];\n                        }\n                    }\n                    for (const noise of series.baseClusters.noise) {\n                        group[noise.id] = noise.data;\n                    }\n                }\n                return group;\n            }\n        };\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let baseGeneratePoints;\n        /**\n         * Points that ids are included in the oldPointsStateId array are hidden before\n         * animation. Other ones are destroyed.\n         * @private\n         */\n        let oldPointsStateId = [];\n        let stateIdCounter = 0;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(highchartsDefaultOptions, ScatterSeriesClass) {\n            if (pushUnique(composedMembers, ScatterSeriesClass)) {\n                const scatterProto = ScatterSeriesClass.prototype;\n                baseGeneratePoints = scatterProto.generatePoints;\n                scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n                scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n                scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n                scatterProto.generatePoints = seriesGeneratePoints;\n                scatterProto.getClusterDistancesFromPoint =\n                    seriesGetClusterDistancesFromPoint;\n                scatterProto.getClusteredData = seriesGetClusteredData;\n                scatterProto.getGridOffset = seriesGetGridOffset;\n                scatterProto.getPointsState = seriesGetPointsState;\n                scatterProto.getRealExtremes = seriesGetRealExtremes;\n                scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n                scatterProto.hideClusteredData = seriesHideClusteredData;\n                scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n                scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n                // Destroy grouped data on series destroy.\n                addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n            }\n            if (pushUnique(composedMembers, highchartsDefaultOptions)) {\n                (highchartsDefaultOptions.plotOptions || {}).series = merge((highchartsDefaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function destroyOldPoints(oldState) {\n            if (oldState) {\n                let state;\n                for (const key of Object.keys(oldState)) {\n                    state = oldState[key];\n                    if (state.point && state.point.destroy) {\n                        state.point.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInElement(elem, opacity, animation) {\n            elem\n                .attr({\n                opacity: opacity\n            })\n                .animate({\n                opacity: 1\n            }, animation);\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n            // Fade in new point.\n            fadeInStatePoint(newPointObj, opacity, animation, true, true);\n            // Destroy old animated points.\n            for (const p of oldPoints) {\n                if (p.point && p.point.destroy) {\n                    p.point.destroy();\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n            if (stateObj.point) {\n                if (fadeinGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.show();\n                    fadeInElement(stateObj.point.graphic, opacity, animation);\n                }\n                if (fadeinDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.show();\n                    fadeInElement(stateObj.point.dataLabel, opacity, animation);\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function getClusterPosition(points) {\n            const pointsLen = points.length;\n            let sumX = 0, sumY = 0;\n            for (let i = 0; i < pointsLen; i++) {\n                sumX += points[i].x;\n                sumY += points[i].y;\n            }\n            return {\n                x: sumX / pointsLen,\n                y: sumY / pointsLen\n            };\n        }\n        /**\n         * Util function.Prepare array with sorted data objects to be compared in\n         * getPointsState method.\n         * @private\n         */\n        function getDataState(clusteredData, stateDataLen) {\n            const state = [];\n            state.length = stateDataLen;\n            clusteredData.clusters.forEach(function (cluster) {\n                cluster.data.forEach(function (elem) {\n                    state[elem.dataIndex] = elem;\n                });\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.data[0].dataIndex] = noise.data[0];\n            });\n            return state;\n        }\n        /**\n         * Util function. Generate unique stateId for a state element.\n         * @private\n         */\n        function getStateId() {\n            return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n            if (stateObj.point) {\n                if (hideGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.hide();\n                }\n                if (hideDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.hide();\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            const point = event.point || event.target;\n            point.firePointEvent('drillToCluster', event, function (e) {\n                const point = e.point || e.target, series = point.series, xAxis = point.series.xAxis, yAxis = point.series.yAxis, chart = point.series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, drillToCluster = (clusterOptions || {}).drillToCluster;\n                if (drillToCluster && point.clusteredData) {\n                    const sortedDataX = point.clusteredData\n                        .map((data) => data.x)\n                        .sort((a, b) => a - b), sortedDataY = point.clusteredData\n                        .map((data) => data.y)\n                        .sort((a, b) => a - b), minX = sortedDataX[0], maxX = sortedDataX[sortedDataX.length - 1], minY = sortedDataY[0], maxY = sortedDataY[sortedDataY.length - 1], offsetX = Math.abs((maxX - minX) * 0.1), offsetY = Math.abs((maxY - minY) * 0.1), x1 = Math.min(minX, maxX) - offsetX, x2 = Math.max(minX, maxX) + offsetX, y1 = Math.min(minY, maxY) - offsetY, y2 = Math.max(minY, maxY) + offsetY;\n                    if (mapView) {\n                        mapView.fitToBounds({ x1, x2, y1, y2 });\n                    }\n                    else if (xAxis && yAxis) {\n                        chart.pointer.zoomX = true;\n                        chart.pointer.zoomY = true;\n                        chart.zoom({\n                            originalEvent: e,\n                            xAxis: [{\n                                    axis: xAxis,\n                                    min: x1,\n                                    max: x2\n                                }],\n                            yAxis: [{\n                                    axis: yAxis,\n                                    min: y1,\n                                    max: y2\n                                }]\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function pixelsToValues(series, pos) {\n            const { chart, xAxis, yAxis } = series;\n            if (chart.mapView) {\n                return chart.mapView.pixelsToProjectedUnits(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toValue(pos.x) : 0,\n                y: yAxis ? yAxis.toValue(pos.y) : 0\n            };\n        }\n        /** @private */\n        function seriesAnimateClusterPoint(clusterObj) {\n            const series = this, chart = series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, animation = animObject((clusterOptions || {}).animation), animDuration = animation.duration || 500, pointsState = (series.markerClusterInfo || {}).pointsState, newState = (pointsState || {}).newState, oldState = (pointsState || {}).oldState, oldPoints = [];\n            let parentId, oldPointObj, newPointObj, newPointBBox, offset = 0, newX = 0, newY = 0, isOldPointGrahic = false, isCbHandled = false;\n            if (oldState && newState) {\n                newPointObj = newState[clusterObj.stateId];\n                const newPos = valuesToPixels(series, newPointObj);\n                newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n                newY = newPos.y - (mapView ? 0 : chart.plotTop);\n                // Point has one ancestor.\n                if (newPointObj.parentsId.length === 1) {\n                    parentId = (newState || {})[clusterObj.stateId].parentsId[0];\n                    oldPointObj = oldState[parentId];\n                    // If old and new poistions are the same do not animate.\n                    if (newPointObj.point &&\n                        newPointObj.point.graphic &&\n                        oldPointObj &&\n                        oldPointObj.point &&\n                        oldPointObj.point.plotX &&\n                        oldPointObj.point.plotY &&\n                        oldPointObj.point.plotX !== newPointObj.point.plotX &&\n                        oldPointObj.point.plotY !== newPointObj.point.plotY) {\n                        newPointBBox = newPointObj.point.graphic.getBBox();\n                        // Marker image does not have the offset (#14342).\n                        offset = (newPointObj.point.graphic &&\n                            newPointObj.point.graphic.isImg) ?\n                            0 : newPointBBox.width / 2;\n                        newPointObj.point.graphic.attr({\n                            x: oldPointObj.point.plotX - offset,\n                            y: oldPointObj.point.plotY - offset\n                        });\n                        newPointObj.point.graphic.animate({\n                            x: newX - (newPointObj.point.graphic.radius || 0),\n                            y: newY - (newPointObj.point.graphic.radius || 0)\n                        }, animation, function () {\n                            isCbHandled = true;\n                            // Destroy old point.\n                            if (oldPointObj.point && oldPointObj.point.destroy) {\n                                oldPointObj.point.destroy();\n                            }\n                        });\n                        // Data label animation.\n                        if (newPointObj.point.dataLabel &&\n                            newPointObj.point.dataLabel.alignAttr &&\n                            oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.alignAttr) {\n                            newPointObj.point.dataLabel.attr({\n                                x: oldPointObj.point.dataLabel.alignAttr.x,\n                                y: oldPointObj.point.dataLabel.alignAttr.y\n                            });\n                            newPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y\n                            }, animation);\n                        }\n                    }\n                }\n                else if (newPointObj.parentsId.length === 0) {\n                    // Point has no ancestors - new point.\n                    // Hide new point.\n                    hideStatePoint(newPointObj, true, true);\n                    syncTimeout(function () {\n                        // Fade in new point.\n                        fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n                    }, animDuration / 2);\n                }\n                else {\n                    // Point has many ancestors.\n                    // Hide new point before animation.\n                    hideStatePoint(newPointObj, true, true);\n                    newPointObj.parentsId.forEach(function (elem) {\n                        if (oldState && oldState[elem]) {\n                            oldPointObj = oldState[elem];\n                            oldPoints.push(oldPointObj);\n                            if (oldPointObj.point &&\n                                oldPointObj.point.graphic) {\n                                isOldPointGrahic = true;\n                                oldPointObj.point.graphic.show();\n                                oldPointObj.point.graphic.animate({\n                                    x: newX - (oldPointObj.point.graphic.radius || 0),\n                                    y: newY - (oldPointObj.point.graphic.radius || 0),\n                                    opacity: 0.4\n                                }, animation, function () {\n                                    isCbHandled = true;\n                                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                                });\n                                if (oldPointObj.point.dataLabel &&\n                                    oldPointObj.point.dataLabel.y !== -9999 &&\n                                    newPointObj.point &&\n                                    newPointObj.point.dataLabel &&\n                                    newPointObj.point.dataLabel.alignAttr) {\n                                    oldPointObj.point.dataLabel.show();\n                                    oldPointObj.point.dataLabel.animate({\n                                        x: newPointObj.point.dataLabel.alignAttr.x,\n                                        y: newPointObj.point.dataLabel.alignAttr.y,\n                                        opacity: 0.4\n                                    }, animation);\n                                }\n                            }\n                        }\n                    });\n                    // Make sure point is faded in.\n                    syncTimeout(function () {\n                        if (!isCbHandled) {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                        }\n                    }, animDuration);\n                    if (!isOldPointGrahic) {\n                        syncTimeout(function () {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                        }, animDuration / 2);\n                    }\n                }\n            }\n        }\n        /**\n         * Destroy clustered data points.\n         * @private\n         */\n        function seriesDestroyClusteredData() {\n            const clusteredSeriesData = this.markerClusterSeriesData;\n            // Clear previous groups.\n            (clusteredSeriesData || []).forEach(function (point) {\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            });\n            this.markerClusterSeriesData = null;\n        }\n        /**\n         * Override the generatePoints method by adding a reference to grouped data.\n         * @private\n         */\n        function seriesGeneratePoints() {\n            const series = this, chart = series.chart, mapView = chart.mapView, xData = series.xData, yData = series.yData, clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n            let oldPointsState, oldDataLen, oldMarkerClusterInfo, kmeansThreshold, cropDataOffsetX, cropDataOffsetY, seriesMinX, seriesMaxX, seriesMinY, seriesMaxY, type, algorithm, clusteredData, groupedData, layoutAlgOptions, point, i;\n            // For map point series, we need to resolve lon, lat and geometry options\n            // and project them on the plane in order to get x and y. In the regular\n            // series flow, this is not done until the `translate` method because the\n            // resulting [x, y] position depends on inset positions in the MapView.\n            if (mapView && series.is('mappoint') && xData && yData) {\n                (series.options.data || []).forEach((p, i) => {\n                    const xy = series.projectPoint(p);\n                    if (xy) {\n                        xData[i] = xy.x;\n                        yData[i] = xy.y;\n                    }\n                });\n            }\n            if (clusterOptions &&\n                clusterOptions.enabled &&\n                xData &&\n                xData.length &&\n                yData &&\n                yData.length &&\n                !chart.polar) {\n                type = clusterOptions.layoutAlgorithm.type;\n                layoutAlgOptions = clusterOptions.layoutAlgorithm;\n                // Get processed algorithm properties.\n                layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n                    clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n                layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n                    clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n                kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n                    clusterDefaults.layoutAlgorithm.kmeansThreshold;\n                // Offset to prevent cluster size changes.\n                const halfGrid = layoutAlgOptions.processedGridSize / 2, p1 = pixelsToValues(series, { x: 0, y: 0 }), p2 = pixelsToValues(series, { x: halfGrid, y: halfGrid });\n                cropDataOffsetX = Math.abs(p1.x - p2.x);\n                cropDataOffsetY = Math.abs(p1.y - p2.y);\n                // Get only visible data.\n                for (i = 0; i < xData.length; i++) {\n                    if (!series.dataMaxX) {\n                        if (!defined(seriesMaxX) ||\n                            !defined(seriesMinX) ||\n                            !defined(seriesMaxY) ||\n                            !defined(seriesMinY)) {\n                            seriesMaxX = seriesMinX = xData[i];\n                            seriesMaxY = seriesMinY = yData[i];\n                        }\n                        else if (isNumber(yData[i]) &&\n                            isNumber(seriesMaxY) &&\n                            isNumber(seriesMinY)) {\n                            seriesMaxX = Math.max(xData[i], seriesMaxX);\n                            seriesMinX = Math.min(xData[i], seriesMinX);\n                            seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                            seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                        }\n                    }\n                    // Crop data to visible ones with appropriate offset to prevent\n                    // cluster size changes on the edge of the plot area.\n                    if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                        xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                        (yData[i] || realExtremes.minY) >=\n                            (realExtremes.minY - cropDataOffsetY) &&\n                        (yData[i] || realExtremes.maxY) <=\n                            (realExtremes.maxY + cropDataOffsetY)) {\n                        visibleXData.push(xData[i]);\n                        visibleYData.push(yData[i]);\n                        visibleDataIndexes.push(i);\n                    }\n                }\n                // Save data max values.\n                if (defined(seriesMaxX) && defined(seriesMinX) &&\n                    isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n                    series.dataMaxX = seriesMaxX;\n                    series.dataMinX = seriesMinX;\n                    series.dataMaxY = seriesMaxY;\n                    series.dataMinY = seriesMinY;\n                }\n                if (isFunction(type)) {\n                    algorithm = type;\n                }\n                else if (series.markerClusterAlgorithms) {\n                    if (type && series.markerClusterAlgorithms[type]) {\n                        algorithm = series.markerClusterAlgorithms[type];\n                    }\n                    else {\n                        algorithm = visibleXData.length < kmeansThreshold ?\n                            series.markerClusterAlgorithms.kmeans :\n                            series.markerClusterAlgorithms.grid;\n                    }\n                }\n                else {\n                    algorithm = function () {\n                        return false;\n                    };\n                }\n                groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n                clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n                // When animation is enabled get old points state.\n                if (clusterOptions.animation &&\n                    series.markerClusterInfo &&\n                    series.markerClusterInfo.pointsState &&\n                    series.markerClusterInfo.pointsState.oldState) {\n                    // Destroy old points.\n                    destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n                    oldPointsState = series.markerClusterInfo.pointsState.newState;\n                }\n                else {\n                    oldPointsState = {};\n                }\n                // Save points old state info.\n                oldDataLen = xData.length;\n                oldMarkerClusterInfo = series.markerClusterInfo;\n                if (clusteredData) {\n                    series.processedXData = clusteredData.groupedXData;\n                    series.processedYData = clusteredData.groupedYData;\n                    series.hasGroupedData = true;\n                    series.markerClusterInfo = clusteredData;\n                    series.groupMap = clusteredData.groupMap;\n                }\n                baseGeneratePoints.apply(this);\n                if (clusteredData && series.markerClusterInfo) {\n                    // Mark cluster points. Safe point reference in the cluster object.\n                    (series.markerClusterInfo.clusters || []).forEach(function (cluster) {\n                        point = series.points[cluster.index];\n                        point.isCluster = true;\n                        point.clusteredData = cluster.data;\n                        point.clusterPointsAmount = cluster.data.length;\n                        cluster.point = point;\n                        // Add zoom to cluster range.\n                        addEvent(point, 'click', onPointDrillToCluster);\n                    });\n                    // Safe point reference in the noise object.\n                    (series.markerClusterInfo.noise || []).forEach(function (noise) {\n                        noise.point = series.points[noise.index];\n                    });\n                    // When animation is enabled save points state.\n                    if (clusterOptions.animation &&\n                        series.markerClusterInfo) {\n                        series.markerClusterInfo.pointsState = {\n                            oldState: oldPointsState,\n                            newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                        };\n                    }\n                    // Record grouped data in order to let it be destroyed the next time\n                    // processData runs.\n                    if (!clusterOptions.animation) {\n                        this.destroyClusteredData();\n                    }\n                    else {\n                        this.hideClusteredData();\n                    }\n                    this.markerClusterSeriesData =\n                        this.hasGroupedData ? this.points : null;\n                }\n            }\n            else {\n                baseGeneratePoints.apply(this);\n            }\n        }\n        /** @private */\n        function seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n            const pointClusterDistance = [];\n            for (let clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n                const p1 = valuesToPixels(this, { x: pointX, y: pointY }), p2 = valuesToPixels(this, {\n                    x: clusters[clusterIndex].posX,\n                    y: clusters[clusterIndex].posY\n                }), distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n                    Math.pow(p1.y - p2.y, 2));\n                pointClusterDistance.push({ clusterIndex, distance });\n            }\n            return pointClusterDistance.sort((a, b) => a.distance - b.distance);\n        }\n        /** @private */\n        function seriesGetClusteredData(groupedData, options) {\n            const series = this, groupedXData = [], groupedYData = [], clusters = [], // Container for clusters.\n            noise = [], // Container for points not belonging to any cluster.\n            groupMap = [], \n            // Prevent minimumClusterSize lower than 2.\n            minimumClusterSize = Math.max(2, options.minimumClusterSize || 2);\n            let index = 0, stateId, point, points, pointUserOptions, pointsLen, marker, clusterPos, pointOptions, clusterTempPos, zoneOptions, clusterZone, clusterZoneClassName, i, k;\n            // Check if groupedData is valid when user uses a custom algorithm.\n            if (isFunction(options.layoutAlgorithm.type) &&\n                !series.isValidGroupedDataObject(groupedData)) {\n                error('Highcharts marker-clusters module: ' +\n                    'The custom algorithm result is not valid!', false, series.chart);\n                return false;\n            }\n            for (k in groupedData) {\n                if (groupedData[k].length >= minimumClusterSize) {\n                    points = groupedData[k];\n                    stateId = getStateId();\n                    pointsLen = points.length;\n                    // Get zone options for cluster.\n                    if (options.zones) {\n                        for (i = 0; i < options.zones.length; i++) {\n                            if (pointsLen >= options.zones[i].from &&\n                                pointsLen <= options.zones[i].to) {\n                                clusterZone = options.zones[i];\n                                clusterZone.zoneIndex = i;\n                                zoneOptions = options.zones[i].marker;\n                                clusterZoneClassName = options.zones[i].className;\n                            }\n                        }\n                    }\n                    clusterTempPos = getClusterPosition(points);\n                    if (options.layoutAlgorithm.type === 'grid' &&\n                        !options.allowOverlap) {\n                        marker = series.options.marker || {};\n                        clusterPos = series.preventClusterCollisions({\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y,\n                            key: k,\n                            groupedData: groupedData,\n                            gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                            defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                            clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                                zoneOptions.radius :\n                                (options.marker || {}).radius ||\n                                    clusterDefaults.marker.radius\n                        });\n                    }\n                    else {\n                        clusterPos = {\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y\n                        };\n                    }\n                    for (i = 0; i < pointsLen; i++) {\n                        points[i].parentStateId = stateId;\n                    }\n                    clusters.push({\n                        x: clusterPos.x,\n                        y: clusterPos.y,\n                        id: k,\n                        stateId: stateId,\n                        index: index,\n                        data: points,\n                        clusterZone: clusterZone,\n                        clusterZoneClassName: clusterZoneClassName\n                    });\n                    groupedXData.push(clusterPos.x);\n                    groupedYData.push(clusterPos.y);\n                    groupMap.push({\n                        options: {\n                            formatPrefix: 'cluster',\n                            dataLabels: options.dataLabels,\n                            marker: merge(options.marker, {\n                                states: options.states\n                            }, zoneOptions || {})\n                        }\n                    });\n                    // Save cluster data points options.\n                    if (series.options.data && series.options.data.length) {\n                        for (i = 0; i < pointsLen; i++) {\n                            if (isObject(series.options.data[points[i].dataIndex])) {\n                                points[i].options =\n                                    series.options.data[points[i].dataIndex];\n                            }\n                        }\n                    }\n                    index++;\n                    zoneOptions = null;\n                }\n                else {\n                    for (i = 0; i < groupedData[k].length; i++) {\n                        // Points not belonging to any cluster.\n                        point = groupedData[k][i];\n                        stateId = getStateId();\n                        pointOptions = null;\n                        pointUserOptions =\n                            ((series.options || {}).data || [])[point.dataIndex];\n                        groupedXData.push(point.x);\n                        groupedYData.push(point.y);\n                        point.parentStateId = stateId;\n                        noise.push({\n                            x: point.x,\n                            y: point.y,\n                            id: k,\n                            stateId: stateId,\n                            index: index,\n                            data: groupedData[k]\n                        });\n                        if (pointUserOptions &&\n                            typeof pointUserOptions === 'object' &&\n                            !isArray(pointUserOptions)) {\n                            pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                        }\n                        else {\n                            pointOptions = {\n                                userOptions: pointUserOptions,\n                                x: point.x,\n                                y: point.y\n                            };\n                        }\n                        groupMap.push({ options: pointOptions });\n                        index++;\n                    }\n                }\n            }\n            return {\n                clusters: clusters,\n                noise: noise,\n                groupedXData: groupedXData,\n                groupedYData: groupedYData,\n                groupMap: groupMap\n            };\n        }\n        /** @private */\n        function seriesGetGridOffset() {\n            const series = this, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            let plotLeft = 0, plotTop = 0;\n            if (xAxis && series.dataMinX && series.dataMaxX) {\n                plotLeft = xAxis.reversed ?\n                    xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n            }\n            else {\n                plotLeft = chart.plotLeft;\n            }\n            if (yAxis && series.dataMinY && series.dataMaxY) {\n                plotTop = yAxis.reversed ?\n                    yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n            }\n            else {\n                plotTop = chart.plotTop;\n            }\n            return { plotLeft, plotTop };\n        }\n        /**\n         * Point state used when animation is enabled to compare and bind old points\n         * with new ones.\n         * @private\n         */\n        function seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n            const oldDataStateArr = oldMarkerClusterInfo ?\n                getDataState(oldMarkerClusterInfo, dataLength) : [], newDataStateArr = getDataState(clusteredData, dataLength), state = {};\n            // Clear global array before populate with new ids.\n            oldPointsStateId = [];\n            // Build points state structure.\n            clusteredData.clusters.forEach(function (cluster) {\n                state[cluster.stateId] = {\n                    x: cluster.x,\n                    y: cluster.y,\n                    id: cluster.stateId,\n                    point: cluster.point,\n                    parentsId: []\n                };\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.stateId] = {\n                    x: noise.x,\n                    y: noise.y,\n                    id: noise.stateId,\n                    point: noise.point,\n                    parentsId: []\n                };\n            });\n            let newState, oldState;\n            // Bind new and old state.\n            for (let i = 0; i < newDataStateArr.length; i++) {\n                newState = newDataStateArr[i];\n                oldState = oldDataStateArr[i];\n                if (newState &&\n                    oldState &&\n                    newState.parentStateId &&\n                    oldState.parentStateId &&\n                    state[newState.parentStateId] &&\n                    state[newState.parentStateId].parentsId.indexOf(oldState.parentStateId) === -1) {\n                    state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n                    if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                        oldPointsStateId.push(oldState.parentStateId);\n                    }\n                }\n            }\n            return state;\n        }\n        /** @private */\n        function seriesGetRealExtremes() {\n            const chart = this.chart, x = chart.mapView ? 0 : chart.plotLeft, y = chart.mapView ? 0 : chart.plotTop, p1 = pixelsToValues(this, {\n                x,\n                y\n            }), p2 = pixelsToValues(this, {\n                x: x + chart.plotWidth,\n                y: x + chart.plotHeight\n            }), realMinX = p1.x, realMaxX = p2.x, realMinY = p1.y, realMaxY = p2.y;\n            return {\n                minX: Math.min(realMinX, realMaxX),\n                maxX: Math.max(realMinX, realMaxX),\n                minY: Math.min(realMinY, realMaxY),\n                maxY: Math.max(realMinY, realMaxY)\n            };\n        }\n        /** @private */\n        function seriesGetScaledGridSize(options) {\n            const series = this, xAxis = series.xAxis, mapView = this.chart.mapView, processedGridSize = options.processedGridSize ||\n                clusterDefaults.layoutAlgorithm.gridSize;\n            let search = true, k = 1, divider = 1;\n            if (!series.gridValueSize) {\n                if (mapView) {\n                    series.gridValueSize = processedGridSize / mapView.getScale();\n                }\n                else {\n                    series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n                }\n            }\n            const gridSize = mapView ?\n                series.gridValueSize * mapView.getScale() :\n                xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n            const scale = +(processedGridSize / gridSize).toFixed(14);\n            // Find the level and its divider.\n            while (search && scale !== 1) {\n                const level = Math.pow(2, k);\n                if (scale > 0.75 && scale < 1.25) {\n                    search = false;\n                }\n                else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n                    search = false;\n                    divider = level;\n                }\n                else if (scale <= level && scale > level / 2) {\n                    search = false;\n                    divider = 1 / level;\n                }\n                k++;\n            }\n            return (processedGridSize / divider) / scale;\n        }\n        /**\n         * Hide clustered data points.\n         * @private\n         */\n        function seriesHideClusteredData() {\n            const series = this, clusteredSeriesData = this.markerClusterSeriesData, oldState = ((series.markerClusterInfo || {}).pointsState || {}).oldState || {}, oldPointsId = oldPointsStateId.map((elem) => (oldState[elem].point || {}).id || '');\n            (clusteredSeriesData || []).forEach(function (point) {\n                // If an old point is used in animation hide it, otherwise destroy.\n                if (point &&\n                    oldPointsId.indexOf(point.id) !== -1) {\n                    if (point.graphic) {\n                        point.graphic.hide();\n                    }\n                    if (point.dataLabel) {\n                        point.dataLabel.hide();\n                    }\n                }\n                else {\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n            });\n        }\n        /**\n         * Check if user algorithm result is valid groupedDataObject.\n         * @private\n         */\n        function seriesIsValidGroupedDataObject(groupedData) {\n            let result = false, i;\n            if (!isObject(groupedData)) {\n                return false;\n            }\n            objectEach(groupedData, function (elem) {\n                result = true;\n                if (!isArray(elem) || !elem.length) {\n                    result = false;\n                    return;\n                }\n                for (i = 0; i < elem.length; i++) {\n                    if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                        result = false;\n                        return;\n                    }\n                }\n            });\n            return result;\n        }\n        /** @private */\n        function seriesPreventClusterCollisions(props) {\n            const series = this, [gridY, gridX] = props.key.split('-').map(parseFloat), gridSize = props.gridSize, groupedData = props.groupedData, defaultRadius = props.defaultRadius, clusterRadius = props.clusterRadius, gridXPx = gridX * gridSize, gridYPx = gridY * gridSize, propsPx = valuesToPixels(series, props), gridsToCheckCollision = [], clusterMarkerOptions = (series.options.cluster || {}).marker, zoneOptions = (series.options.cluster || {}).zones, gridOffset = series.getGridOffset();\n            let xPixel = propsPx.x, yPixel = propsPx.y, pointsLen = 0, radius = 0, nextXPixel, nextYPixel, signX, signY, cornerGridX, cornerGridY, i, j, itemX, itemY, nextClusterPos, maxDist, keys;\n            // Distance to the grid start.\n            xPixel -= gridOffset.plotLeft;\n            yPixel -= gridOffset.plotTop;\n            for (i = 1; i < 5; i++) {\n                signX = i % 2 ? -1 : 1;\n                signY = i < 3 ? -1 : 1;\n                cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n                cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n                keys = [\n                    cornerGridY + '-' + cornerGridX,\n                    cornerGridY + '-' + gridX,\n                    gridY + '-' + cornerGridX\n                ];\n                for (j = 0; j < keys.length; j++) {\n                    if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                        keys[j] !== props.key) {\n                        gridsToCheckCollision.push(keys[j]);\n                    }\n                }\n            }\n            for (const item of gridsToCheckCollision) {\n                if (groupedData[item]) {\n                    // Cluster or noise position is already computed.\n                    if (!groupedData[item].posX) {\n                        nextClusterPos = getClusterPosition(groupedData[item]);\n                        groupedData[item].posX = nextClusterPos.x;\n                        groupedData[item].posY = nextClusterPos.y;\n                    }\n                    const pos = valuesToPixels(series, {\n                        x: groupedData[item].posX || 0,\n                        y: groupedData[item].posY || 0\n                    });\n                    nextXPixel = pos.x - gridOffset.plotLeft;\n                    nextYPixel = pos.y - gridOffset.plotTop;\n                    [itemY, itemX] = item.split('-').map(parseFloat);\n                    if (zoneOptions) {\n                        pointsLen = groupedData[item].length;\n                        for (i = 0; i < zoneOptions.length; i++) {\n                            if (pointsLen >= zoneOptions[i].from &&\n                                pointsLen <= zoneOptions[i].to) {\n                                if (defined((zoneOptions[i].marker || {}).radius)) {\n                                    radius = zoneOptions[i].marker.radius || 0;\n                                }\n                                else if (clusterMarkerOptions &&\n                                    clusterMarkerOptions.radius) {\n                                    radius = clusterMarkerOptions.radius;\n                                }\n                                else {\n                                    radius =\n                                        clusterDefaults.marker.radius;\n                                }\n                            }\n                        }\n                    }\n                    if (groupedData[item].length > 1 &&\n                        radius === 0 &&\n                        clusterMarkerOptions &&\n                        clusterMarkerOptions.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else if (groupedData[item].length === 1) {\n                        radius = defaultRadius;\n                    }\n                    maxDist = clusterRadius + radius;\n                    radius = 0;\n                    if (itemX !== gridX &&\n                        Math.abs(xPixel - nextXPixel) < maxDist) {\n                        xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                            gridXPx + gridSize - clusterRadius;\n                    }\n                    if (itemY !== gridY &&\n                        Math.abs(yPixel - nextYPixel) < maxDist) {\n                        yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                            gridYPx + gridSize - clusterRadius;\n                    }\n                }\n            }\n            const pos = pixelsToValues(series, {\n                x: xPixel + gridOffset.plotLeft,\n                y: yPixel + gridOffset.plotTop\n            });\n            groupedData[props.key].posX = pos.x;\n            groupedData[props.key].posY = pos.y;\n            return pos;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function valuesToPixels(series, pos) {\n            const { chart, xAxis, yAxis } = series;\n            if (chart.mapView) {\n                return chart.mapView.projectedUnitsToPixels(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toPixels(pos.x) : 0,\n                y: yAxis ? yAxis.toPixels(pos.y) : 0\n            };\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterScatter = {\n            compose\n        };\n\n        return MarkerClusterScatter;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusters.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterScatter.js'], _modules['Core/Utilities.js']], function (A, D, MarkerClusterDefaults, MarkerClusterScatter, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { defaultOptions } = D;\n        const { addEvent, defined, error, isFunction, merge, pushUnique, syncTimeout } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        (defaultOptions.plotOptions || {}).series = merge((defaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n            const PointClass = SeriesClass.prototype.pointClass;\n            if (pushUnique(composedMembers, AxisClass)) {\n                addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n            }\n            if (pushUnique(composedMembers, ChartClass)) {\n                addEvent(ChartClass, 'render', onChartRender);\n            }\n            if (pushUnique(composedMembers, PointClass)) {\n                addEvent(PointClass, 'drillToCluster', onPointDrillToCluster);\n                addEvent(PointClass, 'update', onPointUpdate);\n            }\n            if (pushUnique(composedMembers, SeriesClass)) {\n                addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n            }\n            const { scatter: ScatterSeries } = SeriesClass.types;\n            if (ScatterSeries) {\n                MarkerClusterScatter.compose(highchartsDefaultOptions, ScatterSeries);\n            }\n        }\n        /**\n         * Destroy the old tooltip after zoom.\n         * @private\n         */\n        function onAxisSetExtremes() {\n            const chart = this.chart;\n            let animationDuration = 0;\n            for (const series of chart.series) {\n                if (series.markerClusterInfo) {\n                    animationDuration = (animObject((series.options.cluster || {}).animation).duration ||\n                        0);\n                }\n            }\n            syncTimeout(() => {\n                if (chart.tooltip) {\n                    chart.tooltip.destroy();\n                }\n            }, animationDuration);\n        }\n        /**\n         * Handle animation.\n         * @private\n         */\n        function onChartRender() {\n            const chart = this;\n            for (const series of (chart.series || [])) {\n                if (series.markerClusterInfo) {\n                    const options = series.options.cluster, pointsState = (series.markerClusterInfo || {}).pointsState, oldState = (pointsState || {}).oldState;\n                    if ((options || {}).animation &&\n                        series.markerClusterInfo &&\n                        series.chart.pointer.pinchDown.length === 0 &&\n                        ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                        oldState &&\n                        Object.keys(oldState).length) {\n                        for (const cluster of series.markerClusterInfo.clusters) {\n                            series.animateClusterPoint(cluster);\n                        }\n                        for (const noise of series.markerClusterInfo.noise) {\n                            series.animateClusterPoint(noise);\n                        }\n                    }\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            const point = event.point || event.target, series = point.series, clusterOptions = series.options.cluster, onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n            if (isFunction(onDrillToCluster)) {\n                onDrillToCluster.call(this, event);\n            }\n        }\n        /**\n         * Override point prototype to throw a warning when trying to update\n         * clustered point.\n         * @private\n         */\n        function onPointUpdate() {\n            const point = this;\n            if (point.dataGroup) {\n                error('Highcharts marker-clusters module: ' +\n                    'Running `Point.update` when point belongs to clustered series' +\n                    ' is not supported.', false, point.series.chart);\n                return false;\n            }\n        }\n        /**\n         * Add classes, change mouse cursor.\n         * @private\n         */\n        function onSeriesAfterRender() {\n            const series = this, clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n            if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n                for (const cluster of series.markerClusterInfo.clusters) {\n                    if (cluster.point && cluster.point.graphic) {\n                        cluster.point.graphic.addClass('highcharts-cluster-point');\n                        // Change cursor to pointer when drillToCluster is enabled.\n                        if (clusterZoomEnabled && cluster.point) {\n                            cluster.point.graphic.css({\n                                cursor: 'pointer'\n                            });\n                            if (cluster.point.dataLabel) {\n                                cluster.point.dataLabel.css({\n                                    cursor: 'pointer'\n                                });\n                            }\n                        }\n                        if (defined(cluster.clusterZone)) {\n                            cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                                'highcharts-cluster-zone-' +\n                                    cluster.clusterZone.zoneIndex);\n                        }\n                    }\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusters = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Function callback when a cluster is clicked.\n         *\n         * @callback Highcharts.MarkerClusterDrillCallbackFunction\n         *\n         * @param {Highcharts.Point} this\n         *        The point where the event occured.\n         *\n         * @param {Highcharts.PointClickEventObject} event\n         *        Event arguments.\n         */\n        ''; // keeps doclets above in JS file\n\n        return MarkerClusters;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterSymbols.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pushUnique } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const modifiedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let symbols;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Cluster symbol.\n         * @private\n         */\n        function cluster(x, y, width, height) {\n            const w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                open: false\n            }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w - outerWidth * 2,\n                open: false\n            }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w,\n                open: false\n            });\n            return outer2.concat(outer1, inner);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            if (pushUnique(modifiedMembers, SVGRendererClass)) {\n                symbols = SVGRendererClass.prototype.symbols;\n                symbols.cluster = cluster;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MarkerClusterSymbols = {\n            compose\n        };\n\n        return MarkerClusterSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/marker-clusters.src.js', [_modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusters.js'], _modules['Extensions/MarkerClusters/MarkerClusterSymbols.js']], function (Highcharts, MarkerClusters, MarkerClusterSymbols) {\n\n        const G = Highcharts;\n        MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\n        MarkerClusterSymbols.compose(G.SVGRenderer);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","A","MarkerClusterDefaults","U","baseGeneratePoints","animObject","clusterDefaults","addEvent","defined","error","isArray","isFunction","isObject","isNumber","merge","objectEach","pushUnique","relativeLength","syncTimeout","composedMembers","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","options","x","y","gridX","key","i","gridOffset","getGridOffset","scaledGridSize","series","getScaledGridSize","length","p","valuesToPixels","plotLeft","plotTop","Math","floor","gridY","push","dataIndex","kmeans","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","tempPos","pointClusterDistance","processedGridSize","groupedData","call","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","extremes","getRealExtremes","clusterMarkerOptions","offset","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","dataPoint","pointsOutside","pointsInside","data","dataPointPx","clusterPx","sqrt","pow","clusterZone","id","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","mapView","clusterOptions","sortedDataX","map","sort","a","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","max","y1","y2","fitToBounds","pointer","zoomX","zoomY","zoom","originalEvent","axis","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","animDuration","pointsState","newState","oldState","oldPointObj","newPointBBox","newX","newY","isOldPointGrahic","isCbHandled","stateId","newPos","parentsId","plotX","plotY","getBBox","isImg","width","alignAttr","seriesDestroyClusteredData","clusteredSeriesData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","layoutAlgOptions","xData","yData","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","algorithm","getClusteredData","destroyOldPoints","Object","keys","groupedXData","groupedYData","hasGroupedData","groupMap","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","k","isValidGroupedDataObject","zones","from","to","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","toPixels","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","oldPointsId","seriesIsValidGroupedDataObject","result","seriesPreventClusterCollisions","props","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","item","projectedUnitsToPixels","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","prototype","generatePoints","animateClusterPoint","plotOptions","D","MarkerClusterScatter","defaultOptions","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","scatter","ScatterSeries","types","symbols","modifiedMembers","height","w","h","inner","arc","space","start","PI","end","open","outer1","innerR","outerWidth","outer2","concat","SVGRendererClass","MarkerClusters","MarkerClusterSymbols","G","Axis","Chart","Series","SVGRenderer"],"mappings":"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"}