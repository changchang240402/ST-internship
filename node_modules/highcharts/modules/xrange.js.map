{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * X-range series\n *\n * (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/xrange', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/XRange/XRangeSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { correctFloat, isNumber, isObject } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The X-range series displays ranges on the X axis, typically time\n         * intervals with a start and end date.\n         *\n         * @sample {highcharts} highcharts/demo/x-range/\n         *         X-range\n         * @sample {highcharts} highcharts/css/x-range/\n         *         Styled mode X-range\n         * @sample {highcharts} highcharts/chart/inverted-xrange/\n         *         Inverted X-range\n         *\n         * @extends      plotOptions.column\n         * @since        6.0.0\n         * @product      highcharts highstock gantt\n         * @excluding    boostThreshold, crisp, cropThreshold, depth, edgeColor,\n         *               edgeWidth, findNearestPointBy, getExtremesFromAll,\n         *               negativeColor, pointInterval, pointIntervalUnit,\n         *               pointPlacement, pointRange, pointStart, softThreshold,\n         *               stacking, threshold, data, dataSorting, boostBlending\n         * @requires     modules/xrange\n         * @optionparent plotOptions.xrange\n         */\n        const XRangeSeriesDefaults = {\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. The partial fill object can be set either on\n             * series or point level.\n             *\n             * @sample {highcharts} highcharts/demo/x-range\n             *         X-range with partial fill\n             *\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill\n             */\n            /**\n             * The fill color to be used for partial fills. Defaults to a darker\n             * shade of the point color.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @product   highcharts highstock gantt\n             * @apioption plotOptions.xrange.partialFill.fill\n             */\n            /**\n             * A partial fill for each point, typically used to visualize how much\n             * of a task is performed. See [completed](series.gantt.data.completed).\n             *\n             * @sample gantt/demo/progress-indicator\n             *         Gantt with progress indicator\n             *\n             * @product   gantt\n             * @apioption plotOptions.gantt.partialFill\n             */\n            /**\n             * In an X-range series, this option makes all points of the same Y-axis\n             * category the same color.\n             */\n            colorByPoint: true,\n            dataLabels: {\n                formatter: function () {\n                    let point = this.point, amount = point.partialFill;\n                    if (isObject(amount)) {\n                        amount = amount.amount;\n                    }\n                    if (isNumber(amount) && amount > 0) {\n                        return correctFloat(amount * 100) + '%';\n                    }\n                },\n                inside: true,\n                verticalAlign: 'middle'\n            },\n            tooltip: {\n                headerFormat: '<span style=\"font-size: 0.8em\">{point.x} - {point.x2}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.yCategory}</b><br/>'\n            },\n            borderRadius: 3,\n            pointRange: 0\n        };\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * An `xrange` series. If the [type](#series.xrange.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.xrange\n         * @excluding boostThreshold, crisp, cropThreshold, depth, edgeColor, edgeWidth,\n         *            findNearestPointBy, getExtremesFromAll, negativeColor,\n         *            pointInterval, pointIntervalUnit, pointPlacement, pointRange,\n         *            pointStart, softThreshold, stacking, threshold, dataSorting,\n         *            boostBlending\n         * @product   highcharts highstock gantt\n         * @requires  modules/xrange\n         * @apioption series.xrange\n         */\n        /**\n         * An array of data points for the series. For the `xrange` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of objects with named values. The objects are point configuration\n         *    objects as seen below.\n         *    ```js\n         *    data: [{\n         *        x: Date.UTC(2017, 0, 1),\n         *        x2: Date.UTC(2017, 0, 3),\n         *        name: \"Test\",\n         *        y: 0,\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: Date.UTC(2017, 0, 4),\n         *        x2: Date.UTC(2017, 0, 5),\n         *        name: \"Deploy\",\n         *        y: 1,\n         *        color: \"#FF0000\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @declare   Highcharts.XrangePointOptionsObject\n         * @type      {Array<*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data\n         */\n        /**\n         * The starting X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x\n         */\n        /**\n         * The ending X value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.x2\n         */\n        /**\n         * The Y value of the range point.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.y\n         */\n        /**\n         * A partial fill for each point, typically used to visualize how much of\n         * a task is performed. The partial fill object can be set either on series\n         * or point level.\n         *\n         * @sample {highcharts} highcharts/demo/x-range\n         *         X-range with partial fill\n         *\n         * @declare   Highcharts.XrangePointPartialFillOptionsObject\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill\n         */\n        /**\n         * The amount of the X-range point to be filled. Values can be 0-1 and are\n         * converted to percentages in the default data label formatter.\n         *\n         * @type      {number}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.amount\n         */\n        /**\n         * The fill color to be used for partial fills. Defaults to a darker shade\n         * of the point color.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @product   highcharts highstock gantt\n         * @apioption series.xrange.data.partialFill.fill\n         */\n        (''); // adds doclets above to transpiled file\n\n        return XRangeSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { column: { prototype: { pointClass: ColumnPoint } } } = SeriesRegistry.seriesTypes;\n        const { extend } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class XRangePoint extends ColumnPoint {\n            constructor() {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.options = void 0;\n                this.series = void 0;\n            }\n            /**\n             * Return color of a point based on its category.\n             *\n             * @private\n             * @function getColorByCategory\n             *\n             * @param {object} series\n             *        The series which the point belongs to.\n             *\n             * @param {object} point\n             *        The point to calculate its color for.\n             *\n             * @return {object}\n             *         Returns an object containing the properties color and colorIndex.\n             */\n            static getColorByCategory(series, point) {\n                const colors = series.options.colors || series.chart.options.colors, colorCount = colors ?\n                    colors.length :\n                    series.chart.options.chart.colorCount, colorIndex = point.y % colorCount, color = colors && colors[colorIndex];\n                return {\n                    colorIndex: colorIndex,\n                    color: color\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            resolveColor() {\n                const series = this.series;\n                if (series.options.colorByPoint && !this.options.color) {\n                    const colorByPoint = XRangePoint.getColorByCategory(series, this);\n                    if (!series.chart.styledMode) {\n                        this.color = colorByPoint.color;\n                    }\n                    if (!this.options.colorIndex) {\n                        this.colorIndex = colorByPoint.colorIndex;\n                    }\n                }\n                else if (!this.color) {\n                    this.color = series.color;\n                }\n            }\n            /**\n             * Extend init to have y default to 0.\n             *\n             * @private\n             */\n            init() {\n                super.init.apply(this, arguments);\n                if (!this.y) {\n                    this.y = 0;\n                }\n                return this;\n            }\n            /**\n             * @private\n             */\n            setState() {\n                super.setState.apply(this, arguments);\n                this.series.drawPoint(this, this.series.getAnimationVerb());\n            }\n            /**\n             * Add x2 and yCategory to the available properties for tooltip formats.\n             *\n             * @private\n             */\n            getLabelConfig() {\n                const cfg = super.getLabelConfig.call(this), yCats = this.series.yAxis.categories;\n                cfg.x2 = this.x2;\n                cfg.yCategory = this.yCategory = yCats && yCats[this.y];\n                // Use 'category' as 'key' to ensure tooltip datetime formatting.\n                // Use 'name' only when 'category' is undefined.\n                cfg.key = this.category || this.name;\n                return cfg;\n            }\n            /**\n             * @private\n             */\n            isValid() {\n                return typeof this.x === 'number' &&\n                    typeof this.x2 === 'number';\n            }\n        }\n        extend(XRangePoint.prototype, {\n            ttBelow: false,\n            tooltipDateKeys: ['x', 'x2']\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The ending X value of the range point.\n         * @name Highcharts.Point#x2\n         * @type {number|undefined}\n         * @requires modules/xrange\n         */\n        /**\n         * Extend applyOptions so that `colorByPoint` for x-range means that one\n         * color is applied per Y axis category.\n         *\n         * @private\n         * @function Highcharts.Point#applyOptions\n         *\n         * @return {Highcharts.Series}\n         */\n        /**\n         * @interface Highcharts.PointOptionsObject in parts/Point.ts\n         */ /**\n        * The ending X value of the range point.\n        * @name Highcharts.PointOptionsObject#x2\n        * @type {number|undefined}\n        * @requires modules/xrange\n        */\n        (''); // keeps doclets above in JS file\n\n        return XRangePoint;\n    });\n    _registerModule(_modules, 'Series/XRange/XRangeSeries.js', [_modules['Core/Globals.js'], _modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/XRange/XRangeSeriesDefaults.js'], _modules['Series/XRange/XRangePoint.js']], function (H, Color, SeriesRegistry, U, XRangeSeriesDefaults, XRangePoint) {\n        /* *\n         *\n         *  X-range series module\n         *\n         *  (c) 2010-2021 Torstein Honsi, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { noop } = H;\n        const { parse: color } = Color;\n        const { column: ColumnSeries } = SeriesRegistry.seriesTypes;\n        const { addEvent, clamp, defined, extend, find, isNumber, isObject, merge, pick, relativeLength } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Max x2 should be considered in xAxis extremes\n         * @private\n         */\n        function onAxisAfterGetSeriesExtremes() {\n            let dataMax, modMax;\n            if (this.isXAxis) {\n                dataMax = pick(this.dataMax, -Number.MAX_VALUE);\n                for (const series of this.series) {\n                    if (series.x2Data) {\n                        for (const val of series.x2Data) {\n                            if (val && val > dataMax) {\n                                dataMax = val;\n                                modMax = true;\n                            }\n                        }\n                    }\n                }\n                if (modMax) {\n                    this.dataMax = dataMax;\n                }\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.xrange\n         *\n         * @augments Highcharts.Series\n         */\n        class XRangeSeries extends ColumnSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n                /*\n                // Override to remove stroke from points. For partial fill.\n                pointAttribs: function () {\n                    let series = this,\n                        retVal = columnType.prototype.pointAttribs\n                            .apply(series, arguments);\n    \n                    //retVal['stroke-width'] = 0;\n                    return retVal;\n                }\n                //*/\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(AxisClass) {\n                if (U.pushUnique(composedMembers, AxisClass)) {\n                    addEvent(AxisClass, 'afterGetSeriesExtremes', onAxisAfterGetSeriesExtremes);\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            init() {\n                super.init.apply(this, arguments);\n                this.options.stacking = void 0; // #13161\n            }\n            /**\n             * Borrow the column series metrics, but with swapped axes. This gives\n             * free access to features like groupPadding, grouping, pointWidth etc.\n             * @private\n             */\n            getColumnMetrics() {\n                const swapAxes = () => {\n                    for (const series of this.chart.series) {\n                        const xAxis = series.xAxis;\n                        series.xAxis = series.yAxis;\n                        series.yAxis = xAxis;\n                    }\n                };\n                swapAxes();\n                const metrics = super.getColumnMetrics();\n                swapAxes();\n                return metrics;\n            }\n            /**\n             * Override cropData to show a point where x or x2 is outside visible range,\n             * but one of them is inside.\n             * @private\n             */\n            cropData(xData, yData, min, max) {\n                // Replace xData with x2Data to find the appropriate cropStart\n                const crop = super.cropData(this.x2Data, yData, min, max);\n                // Re-insert the cropped xData\n                crop.xData = xData.slice(crop.start, crop.end);\n                return crop;\n            }\n            /**\n             * Finds the index of an existing point that matches the given point\n             * options.\n             *\n             * @private\n             *\n             * @param {Highcharts.XRangePointOptions} options\n             *        The options of the point.\n             *\n             * @return {number|undefined}\n             *         Returns index of a matching point, or undefined if no match is\n             *         found.\n             */\n            findPointIndex(options) {\n                const { cropStart, points } = this;\n                const { id } = options;\n                let pointIndex;\n                if (id) {\n                    const point = find(points, (point) => point.id === id);\n                    pointIndex = point ? point.index : void 0;\n                }\n                if (typeof pointIndex === 'undefined') {\n                    const point = find(points, (point) => (point.x === options.x &&\n                        point.x2 === options.x2 &&\n                        !point.touched));\n                    pointIndex = point ? point.index : void 0;\n                }\n                // Reduce pointIndex if data is cropped\n                if (this.cropped &&\n                    isNumber(pointIndex) &&\n                    isNumber(cropStart) &&\n                    pointIndex >= cropStart) {\n                    pointIndex -= cropStart;\n                }\n                return pointIndex;\n            }\n            alignDataLabel(point) {\n                const oldPlotX = point.plotX;\n                point.plotX = pick(point.dlBox && point.dlBox.centerX, point.plotX);\n                super.alignDataLabel.apply(this, arguments);\n                point.plotX = oldPlotX;\n            }\n            /**\n             * @private\n             */\n            translatePoint(point) {\n                const xAxis = this.xAxis, yAxis = this.yAxis, metrics = this.columnMetrics, options = this.options, minPointLength = options.minPointLength || 0, oldColWidth = (point.shapeArgs && point.shapeArgs.width || 0) / 2, seriesXOffset = this.pointXOffset = metrics.offset, posX = pick(point.x2, point.x + (point.len || 0)), borderRadius = options.borderRadius, plotTop = this.chart.plotTop, plotLeft = this.chart.plotLeft;\n                let plotX = point.plotX, plotX2 = xAxis.translate(posX, 0, 0, 0, 1);\n                const length = Math.abs(plotX2 - plotX), inverted = this.chart.inverted, borderWidth = pick(options.borderWidth, 1), crisper = borderWidth % 2 / 2;\n                let widthDifference, partialFill, yOffset = metrics.offset, pointHeight = Math.round(metrics.width), dlLeft, dlRight, dlWidth, clipRectWidth;\n                if (minPointLength) {\n                    widthDifference = minPointLength - length;\n                    if (widthDifference < 0) {\n                        widthDifference = 0;\n                    }\n                    plotX -= widthDifference / 2;\n                    plotX2 += widthDifference / 2;\n                }\n                plotX = Math.max(plotX, -10);\n                plotX2 = clamp(plotX2, -10, xAxis.len + 10);\n                // Handle individual pointWidth\n                if (defined(point.options.pointWidth)) {\n                    yOffset -= ((Math.ceil(point.options.pointWidth) - pointHeight) / 2);\n                    pointHeight = Math.ceil(point.options.pointWidth);\n                }\n                // Apply pointPlacement to the Y axis\n                if (options.pointPlacement &&\n                    isNumber(point.plotY) &&\n                    yAxis.categories) {\n                    point.plotY = yAxis.translate(point.y, 0, 1, 0, 1, options.pointPlacement);\n                }\n                const x = Math.floor(Math.min(plotX, plotX2)) + crisper, x2 = Math.floor(Math.max(plotX, plotX2)) + crisper, width = x2 - x;\n                const r = Math.min(relativeLength((typeof borderRadius === 'object' ?\n                    borderRadius.radius :\n                    borderRadius || 0), pointHeight), Math.min(width, pointHeight) / 2);\n                const shapeArgs = {\n                    x,\n                    y: Math.floor(point.plotY + yOffset) + crisper,\n                    width,\n                    height: pointHeight,\n                    r\n                };\n                point.shapeArgs = shapeArgs;\n                // Move tooltip to default position\n                if (!inverted) {\n                    point.tooltipPos[0] -= oldColWidth +\n                        seriesXOffset -\n                        shapeArgs.width / 2;\n                }\n                else {\n                    point.tooltipPos[1] += seriesXOffset +\n                        oldColWidth;\n                }\n                // Align data labels inside the shape and inside the plot area\n                dlLeft = shapeArgs.x;\n                dlRight = dlLeft + shapeArgs.width;\n                if (dlLeft < 0 || dlRight > xAxis.len) {\n                    dlLeft = clamp(dlLeft, 0, xAxis.len);\n                    dlRight = clamp(dlRight, 0, xAxis.len);\n                    dlWidth = dlRight - dlLeft;\n                    point.dlBox = merge(shapeArgs, {\n                        x: dlLeft,\n                        width: dlRight - dlLeft,\n                        centerX: dlWidth ? dlWidth / 2 : null\n                    });\n                }\n                else {\n                    point.dlBox = null;\n                }\n                // Tooltip position\n                const tooltipPos = point.tooltipPos;\n                const xIndex = !inverted ? 0 : 1;\n                const yIndex = !inverted ? 1 : 0;\n                const tooltipYOffset = (this.columnMetrics ?\n                    this.columnMetrics.offset :\n                    -metrics.width / 2);\n                // Centering tooltip position (#14147)\n                if (inverted) {\n                    tooltipPos[xIndex] += shapeArgs.width / 2;\n                }\n                else {\n                    tooltipPos[xIndex] = clamp(tooltipPos[xIndex] +\n                        (xAxis.reversed ? -1 : 0) * shapeArgs.width, xAxis.left - plotLeft, xAxis.left + xAxis.len - plotLeft - 1);\n                }\n                tooltipPos[yIndex] = clamp(tooltipPos[yIndex] + ((inverted ? -1 : 1) * tooltipYOffset), yAxis.top - plotTop, yAxis.top + yAxis.len - plotTop - 1);\n                // Add a partShapeArgs to the point, based on the shapeArgs property\n                partialFill = point.partialFill;\n                if (partialFill) {\n                    // Get the partial fill amount\n                    if (isObject(partialFill)) {\n                        partialFill = partialFill.amount;\n                    }\n                    // If it was not a number, assume 0\n                    if (!isNumber(partialFill)) {\n                        partialFill = 0;\n                    }\n                    point.partShapeArgs = merge(shapeArgs);\n                    clipRectWidth = Math.max(Math.round(length * partialFill + point.plotX -\n                        plotX), 0);\n                    point.clipRectArgs = {\n                        x: xAxis.reversed ? // #10717\n                            shapeArgs.x + length - clipRectWidth :\n                            shapeArgs.x,\n                        y: shapeArgs.y,\n                        width: clipRectWidth,\n                        height: shapeArgs.height\n                    };\n                }\n            }\n            /**\n             * @private\n             */\n            translate() {\n                super.translate.apply(this, arguments);\n                for (const point of this.points) {\n                    this.translatePoint(point);\n                }\n            }\n            /**\n             * Draws a single point in the series. Needed for partial fill.\n             *\n             * This override turns point.graphic into a group containing the\n             * original graphic and an overlay displaying the partial fill.\n             *\n             * @private\n             *\n             * @param {Highcharts.Point} point\n             *        An instance of Point in the series.\n             *\n             * @param {\"animate\"|\"attr\"} verb\n             *        'animate' (animates changes) or 'attr' (sets options)\n             */\n            drawPoint(point, verb) {\n                const seriesOpts = this.options, renderer = this.chart.renderer, type = point.shapeType, shapeArgs = point.shapeArgs, partShapeArgs = point.partShapeArgs, clipRectArgs = point.clipRectArgs, pointState = point.state, stateOpts = (seriesOpts.states[pointState || 'normal'] ||\n                    {}), pointStateVerb = typeof pointState === 'undefined' ?\n                    'attr' : verb, pointAttr = this.pointAttribs(point, pointState), animation = pick(this.chart.options.chart.animation, stateOpts.animation);\n                let graphic = point.graphic, pfOptions = point.partialFill;\n                if (!point.isNull && point.visible !== false) {\n                    // Original graphic\n                    if (graphic) { // update\n                        graphic.rect[verb](shapeArgs);\n                    }\n                    else {\n                        point.graphic = graphic = renderer.g('point')\n                            .addClass(point.getClassName())\n                            .add(point.group || this.group);\n                        graphic.rect = renderer[type](merge(shapeArgs))\n                            .addClass(point.getClassName())\n                            .addClass('highcharts-partfill-original')\n                            .add(graphic);\n                    }\n                    // Partial fill graphic\n                    if (partShapeArgs) {\n                        if (graphic.partRect) {\n                            graphic.partRect[verb](merge(partShapeArgs));\n                            graphic.partialClipRect[verb](merge(clipRectArgs));\n                        }\n                        else {\n                            graphic.partialClipRect = renderer.clipRect(clipRectArgs.x, clipRectArgs.y, clipRectArgs.width, clipRectArgs.height);\n                            graphic.partRect =\n                                renderer[type](partShapeArgs)\n                                    .addClass('highcharts-partfill-overlay')\n                                    .add(graphic)\n                                    .clip(graphic.partialClipRect);\n                        }\n                    }\n                    // Presentational\n                    if (!this.chart.styledMode) {\n                        graphic\n                            .rect[verb](pointAttr, animation)\n                            .shadow(seriesOpts.shadow);\n                        if (partShapeArgs) {\n                            // Ensure pfOptions is an object\n                            if (!isObject(pfOptions)) {\n                                pfOptions = {};\n                            }\n                            if (isObject(seriesOpts.partialFill)) {\n                                pfOptions = merge(seriesOpts.partialFill, pfOptions);\n                            }\n                            const fill = (pfOptions.fill ||\n                                color(pointAttr.fill).brighten(-0.3).get() ||\n                                color(point.color || this.color)\n                                    .brighten(-0.3).get());\n                            pointAttr.fill = fill;\n                            graphic\n                                .partRect[pointStateVerb](pointAttr, animation)\n                                .shadow(seriesOpts.shadow);\n                        }\n                    }\n                }\n                else if (graphic) {\n                    point.graphic = graphic.destroy(); // #1269\n                }\n            }\n            /**\n             * @private\n             */\n            drawPoints() {\n                const verb = this.getAnimationVerb();\n                // Draw the columns\n                for (const point of this.points) {\n                    this.drawPoint(point, verb);\n                }\n            }\n            /**\n             * Returns \"animate\", or \"attr\" if the number of points is above the\n             * animation limit.\n             *\n             * @private\n             */\n            getAnimationVerb() {\n                return (this.chart.pointCount < (this.options.animationLimit || 250) ?\n                    'animate' :\n                    'attr');\n            }\n            /**\n             * @private\n             */\n            isPointInside(point) {\n                const shapeArgs = point.shapeArgs, plotX = point.plotX, plotY = point.plotY;\n                if (!shapeArgs) {\n                    return super.isPointInside.apply(this, arguments);\n                }\n                const isInside = typeof plotX !== 'undefined' &&\n                    typeof plotY !== 'undefined' &&\n                    plotY >= 0 &&\n                    plotY <= this.yAxis.len &&\n                    (shapeArgs.x || 0) + (shapeArgs.width || 0) >= 0 &&\n                    plotX <= this.xAxis.len;\n                return isInside;\n            }\n        }\n        XRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, XRangeSeriesDefaults);\n        extend(XRangeSeries.prototype, {\n            pointClass: XRangePoint,\n            pointArrayMap: ['x2', 'y'],\n            getExtremesFromAll: true,\n            parallelArrays: ['x', 'x2', 'y'],\n            requireSorting: false,\n            type: 'xrange',\n            animate: SeriesRegistry.series.prototype.animate,\n            autoIncrement: noop,\n            buildKDTree: noop\n        });\n        SeriesRegistry.registerSeriesType('xrange', XRangeSeries);\n        /* *\n         *\n         * Default Export\n         *\n         * */\n\n        return XRangeSeries;\n    });\n    _registerModule(_modules, 'masters/modules/xrange.src.js', [_modules['Core/Globals.js'], _modules['Series/XRange/XRangeSeries.js']], function (Highcharts, XRangeSeries) {\n\n        const G = Highcharts;\n        XRangeSeries.compose(G.Axis);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","U","correctFloat","isNumber","isObject","colorByPoint","dataLabels","formatter","amount","point","partialFill","inside","verticalAlign","tooltip","headerFormat","pointFormat","borderRadius","pointRange","SeriesRegistry","column","prototype","pointClass","ColumnPoint","seriesTypes","extend","XRangePoint","constructor","arguments","options","series","getColorByCategory","colors","chart","colorCount","length","colorIndex","y","color","resolveColor","styledMode","init","setState","drawPoint","getAnimationVerb","getLabelConfig","cfg","call","yCats","yAxis","categories","x2","yCategory","key","category","name","isValid","x","ttBelow","tooltipDateKeys","H","Color","XRangeSeriesDefaults","noop","parse","ColumnSeries","addEvent","clamp","defined","find","merge","pick","relativeLength","composedMembers","onAxisAfterGetSeriesExtremes","dataMax","modMax","isXAxis","Number","MAX_VALUE","x2Data","val","XRangeSeries","data","points","compose","AxisClass","pushUnique","stacking","getColumnMetrics","swapAxes","xAxis","metrics","cropData","xData","yData","min","max","crop","slice","start","end","findPointIndex","pointIndex","cropStart","id","index","touched","cropped","alignDataLabel","oldPlotX","plotX","dlBox","centerX","translatePoint","columnMetrics","minPointLength","oldColWidth","shapeArgs","width","seriesXOffset","pointXOffset","offset","posX","len","plotTop","plotLeft","plotX2","translate","Math","abs","inverted","borderWidth","crisper","widthDifference","yOffset","pointHeight","round","dlLeft","dlRight","dlWidth","clipRectWidth","pointWidth","ceil","pointPlacement","plotY","floor","r","radius","height","tooltipPos","xIndex","yIndex","tooltipYOffset","reversed","left","top","partShapeArgs","clipRectArgs","verb","seriesOpts","renderer","type","shapeType","pointState","state","stateOpts","states","pointStateVerb","pointAttr","pointAttribs","animation","graphic","pfOptions","isNull","visible","destroy","rect","g","addClass","getClassName","add","group","partRect","partialClipRect","clipRect","clip","shadow","fill","brighten","get","drawPoints","pointCount","animationLimit","isPointInside","isInside","defaultOptions","pointArrayMap","getExtremesFromAll","parallelArrays","requireSorting","animate","autoIncrement","buildKDTree","registerSeriesType","G","Axis"],"mappings":"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"}