{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * (c) 2009-2022\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/geoheatmap', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/GeoHeatmap/GeoHeatmapPoint.js', [_modules['Core/Utilities.js'], _modules['Core/Series/SeriesRegistry.js']], function (U, SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2023 Highsoft AS\n         *\n         *  Authors: Magdalena Gut, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { map: { prototype: { pointClass: MapPoint } } } = SeriesRegistry.seriesTypes;\n        const { isNumber } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class GeoHeatmapPoint extends MapPoint {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.lat = void 0;\n                this.lon = void 0;\n                this.options = void 0;\n                this.series = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            applyOptions(options, x) {\n                const point = super.applyOptions.call(this, options, x), { lat, lon } = point.options;\n                if (isNumber(lon) && isNumber(lat)) {\n                    const { colsize = 1, rowsize = 1 } = this.series.options, x1 = lon - colsize / 2, y1 = lat - rowsize / 2;\n                    point.geometry = point.options.geometry = {\n                        type: 'Polygon',\n                        // A rectangle centered in lon/lat\n                        coordinates: [\n                            [\n                                [x1, y1],\n                                [x1 + colsize, y1],\n                                [x1 + colsize, y1 + rowsize],\n                                [x1, y1 + rowsize],\n                                [x1, y1]\n                            ]\n                        ]\n                    };\n                }\n                return point;\n                /* eslint-enable valid-jsdoc */\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GeoHeatmapPoint;\n    });\n    _registerModule(_modules, 'Series/InterpolationUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2023 Hubert Kozik\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { doc } = H;\n        const { defined, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Find color of point based on color axis.\n         *\n         * @function Highcharts.colorFromPoint\n         *\n         * @param {number | null} value\n         *        Value to find corresponding color on the color axis.\n         *\n         * @param {Highcharts.Point} point\n         *        Point to find it's color from color axis.\n         *\n         * @return {number[]}\n         *        Color in RGBa array.\n         */\n        function colorFromPoint(value, point) {\n            const colorAxis = point.series.colorAxis;\n            if (colorAxis) {\n                const rgba = (colorAxis.toColor(value || 0, point)\n                    .split(')')[0]\n                    .split('(')[1]\n                    .split(',')\n                    .map((s) => pick(parseFloat(s), parseInt(s, 10))));\n                rgba[3] = pick(rgba[3], 1.0) * 255;\n                if (!defined(value) || !point.visible) {\n                    rgba[3] = 0;\n                }\n                return rgba;\n            }\n            return [0, 0, 0, 0];\n        }\n        /**\n         * Method responsible for creating a canvas for interpolation image.\n         * @private\n         */\n        function getContext(series) {\n            const { canvas, context } = series;\n            if (canvas && context) {\n                context.clearRect(0, 0, canvas.width, canvas.height);\n            }\n            else {\n                series.canvas = doc.createElement('canvas');\n                series.context = series.canvas.getContext('2d', {\n                    willReadFrequently: true\n                }) || void 0;\n                return series.context;\n            }\n            return context;\n        }\n        const InterpolationUtilities = {\n            colorFromPoint,\n            getContext\n        };\n\n        return InterpolationUtilities;\n    });\n    _registerModule(_modules, 'Series/GeoHeatmap/GeoHeatmapSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Series/GeoHeatmap/GeoHeatmapPoint.js'], _modules['Core/Globals.js'], _modules['Series/InterpolationUtilities.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (A, GeoHeatmapPoint, H, IU, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2023 Highsoft AS\n         *\n         *  Authors: Magdalena Gut, Piotr Madej\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject, stop } = A;\n        const { noop } = H;\n        const { colorFromPoint, getContext } = IU;\n        const { seriesTypes: { map: MapSeries } } = SeriesRegistry;\n        const { addEvent, extend, isNumber, isObject, merge, pick } = U;\n        /**\n         * Normalize longitute value to -180:180 range.\n         * @private\n         */\n        function normalizeLonValue(lon) {\n            return lon - Math.floor((lon + 180) / 360) * 360;\n        }\n        /**\n         * Get proper point's position for PixelData array.\n         * @private\n         */\n        function scaledPointPos(lon, lat, canvasWidth, canvasHeight, colsize, rowsize) {\n            return Math.ceil((canvasWidth * (canvasHeight - 1 - (lat + 90) / rowsize)) +\n                ((lon + 180) / colsize));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Geo Heatmap series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.geoheatmap\n         *\n         * @augments Highcharts.Series\n         */\n        class GeoHeatmapSeries extends MapSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.options = void 0;\n                this.data = void 0;\n                this.points = void 0;\n                this.canvas = void 0;\n                this.context = void 0;\n                this.isDirtyCanvas = true;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * For updated colsize and rowsize options\n             * @private\n             */\n            update() {\n                const series = this;\n                series.options = merge(series.options, arguments[0]);\n                if (series.getInterpolation().enabled) {\n                    series.isDirtyCanvas = true;\n                    series.points.forEach((point) => {\n                        if (point.graphic) {\n                            point.graphic.destroy();\n                            delete point.graphic;\n                        }\n                    });\n                }\n                super.update.apply(series, arguments);\n            }\n            /**\n             * Override translate method to not fire if not needed.\n             * @private\n             */\n            translate() {\n                if (this.getInterpolation().enabled &&\n                    this.image &&\n                    !this.isDirty &&\n                    !this.isDirtyData) {\n                    return;\n                }\n                super.translate.apply(this, arguments);\n            }\n            /**\n             * Create the extended object out of the boolean\n             * @private\n             */\n            getInterpolation() {\n                if (!isObject(this.options.interpolation)) {\n                    return {\n                        blur: 1,\n                        enabled: this.options.interpolation\n                    };\n                }\n                return this.options.interpolation;\n            }\n            /**\n             * Overriding drawPoints original method to apply new features.\n             * @private\n             */\n            drawPoints() {\n                const series = this, chart = series.chart, mapView = chart.mapView, seriesOptions = series.options;\n                if (series.getInterpolation().enabled && mapView && series.bounds) {\n                    const ctx = series.context || getContext(series), { canvas, colorAxis, image, chart, points } = series, [colsize, rowsize] = [\n                        pick(seriesOptions.colsize, 1),\n                        pick(seriesOptions.rowsize, 1)\n                    ], \n                    // Calculate dimensions based on series bounds\n                    topLeft = mapView.projectedUnitsToPixels({\n                        x: series.bounds.x1,\n                        y: series.bounds.y2\n                    }), bottomRight = mapView.projectedUnitsToPixels({\n                        x: series.bounds.x2,\n                        y: series.bounds.y1\n                    });\n                    if (canvas && ctx && colorAxis && topLeft && bottomRight) {\n                        const dimensions = {\n                            x: topLeft.x,\n                            y: topLeft.y,\n                            width: bottomRight.x - topLeft.x,\n                            height: bottomRight.y - topLeft.y\n                        };\n                        if (\n                        // Do not calculate new canvas if not necessary\n                        series.isDirtyCanvas ||\n                            // Calculate new canvas if data is dirty\n                            series.isDirtyData ||\n                            // Always calculate new canvas for Orthographic projection\n                            mapView.projection.options.name === 'Orthographic') {\n                            series.isDirtyCanvas = true;\n                            const canvasWidth = canvas.width = ~~(360 / colsize) + 1, canvasHeight = canvas.height = ~~(180 / rowsize) + 1, canvasArea = canvasWidth * canvasHeight, pixelData = new Uint8ClampedArray(canvasArea * 4);\n                            series.directTouch = false; // Needed for tooltip\n                            // First pixelData represents the geo coordinates\n                            for (let i = 0; i < points.length; i++) {\n                                const p = points[i], sourceArr = new Uint8ClampedArray(colorFromPoint(p.value, p)), { lon, lat } = p.options;\n                                if (isNumber(lon) && isNumber(lat)) {\n                                    pixelData.set(sourceArr, scaledPointPos(lon, lat, canvasWidth, canvasHeight, colsize, rowsize) * 4);\n                                }\n                            }\n                            const blur = series.getInterpolation().blur, blurFactor = blur === 0 ? 1 : blur * 11, upscaledWidth = ~~(canvasWidth * blurFactor), upscaledHeight = ~~(canvasHeight * blurFactor), projectedWidth = ~~dimensions.width, projectedHeight = ~~dimensions.height, img = new ImageData(pixelData, canvasWidth, canvasHeight);\n                            canvas.width = upscaledWidth;\n                            canvas.height = upscaledHeight;\n                            // Next step is to upscale pixelData to big image to get\n                            // the blur on the interpolation\n                            ctx.putImageData(img, 0, 0);\n                            // Now we have an unscaled version of our ImageData\n                            // let's make the compositing mode to 'copy' so that\n                            // our next drawing op erases whatever was there\n                            // previously just like putImageData would have done\n                            ctx.globalCompositeOperation = 'copy';\n                            // Now we can draw ourself over ourself\n                            ctx.drawImage(canvas, 0, 0, img.width, img.height, // Grab the ImageData\n                            0, 0, canvas.width, canvas.height // Scale it\n                            );\n                            // Add projection to upscaled ImageData\n                            const cartesianImageData = ctx.getImageData(0, 0, canvas.width, canvas.height), projectedPixelData = this.getProjectedImageData(mapView, projectedWidth, projectedHeight, cartesianImageData, canvas, dimensions.x, dimensions.y), projectedImg = new ImageData(projectedPixelData, projectedWidth, projectedHeight);\n                            ctx.globalCompositeOperation = 'copy';\n                            canvas.width = projectedWidth;\n                            canvas.height = projectedHeight;\n                            ctx.putImageData(projectedImg, 0, 0);\n                        }\n                        if (image) {\n                            if (chart.renderer.globalAnimation && chart.hasRendered) {\n                                const startX = Number(image.attr('x')), startY = Number(image.attr('y')), startWidth = Number(image.attr('width')), startHeight = Number(image.attr('height'));\n                                const step = (now, fx) => {\n                                    image.attr({\n                                        x: (startX + (dimensions.x - startX) * fx.pos),\n                                        y: (startY + (dimensions.y - startY) * fx.pos),\n                                        width: (startWidth + (dimensions.width - startWidth) * fx.pos),\n                                        height: (startHeight + (dimensions.height - startHeight) * fx.pos)\n                                    });\n                                };\n                                const animOptions = merge(animObject(chart.renderer.globalAnimation)), userStep = animOptions.step;\n                                animOptions.step =\n                                    function () {\n                                        if (userStep) {\n                                            userStep.apply(this, arguments);\n                                        }\n                                        step.apply(this, arguments);\n                                    };\n                                image\n                                    .attr(merge({ animator: 0 }, series.isDirtyCanvas ? {\n                                    href: canvas.toDataURL('image/png', 1)\n                                } : void 0))\n                                    .animate({ animator: 1 }, animOptions);\n                                // When dragging or first rendering, animation is off\n                            }\n                            else {\n                                stop(image);\n                                image.attr(merge(dimensions, series.isDirtyCanvas ? {\n                                    href: canvas.toDataURL('image/png', 1)\n                                } : void 0));\n                            }\n                        }\n                        else {\n                            series.image = chart.renderer.image(canvas.toDataURL('image/png', 1))\n                                .attr(dimensions)\n                                .add(series.group);\n                        }\n                        series.isDirtyCanvas = false;\n                    }\n                }\n                else {\n                    super.drawPoints.apply(series, arguments);\n                }\n            }\n            /**\n             * Project ImageData to actual mapView projection used on a chart.\n             * @private\n             */\n            getProjectedImageData(mapView, projectedWidth, projectedHeight, cartesianImageData, canvas, horizontalShift, verticalShift) {\n                const projectedPixelData = new Uint8ClampedArray(projectedWidth * projectedHeight * 4), lambda = pick(mapView.projection.options.rotation?.[0], 0), widthFactor = canvas.width / 360, heightFactor = -1 * canvas.height / 180;\n                let y = -1;\n                // For each pixel on the map plane, find the map\n                // coordinate and get the color value\n                for (let i = 0; i < projectedPixelData.length; i += 4) {\n                    const x = (i / 4) % projectedWidth;\n                    if (x === 0) {\n                        y++;\n                    }\n                    const projectedCoords = mapView.pixelsToLonLat({\n                        x: horizontalShift + x,\n                        y: verticalShift + y\n                    });\n                    if (projectedCoords) {\n                        // Normalize lon values\n                        if (projectedCoords.lon > -180 - lambda &&\n                            projectedCoords.lon < 180 - lambda) {\n                            projectedCoords.lon =\n                                normalizeLonValue(projectedCoords.lon);\n                        }\n                        const projected = [\n                            projectedCoords.lon,\n                            projectedCoords.lat\n                        ], cvs2PixelX = projected[0] * widthFactor + canvas.width / 2, cvs2PixelY = projected[1] * heightFactor +\n                            canvas.height / 2;\n                        if (cvs2PixelX >= 0 &&\n                            cvs2PixelX <= canvas.width &&\n                            cvs2PixelY >= 0 &&\n                            cvs2PixelY <= canvas.height) {\n                            const redPos = (\n                            // Rows\n                            Math.floor(cvs2PixelY) *\n                                canvas.width * 4 +\n                                // Columns\n                                Math.round(cvs2PixelX) * 4);\n                            projectedPixelData[i] =\n                                cartesianImageData.data[redPos];\n                            projectedPixelData[i + 1] =\n                                cartesianImageData.data[redPos + 1];\n                            projectedPixelData[i + 2] =\n                                cartesianImageData.data[redPos + 2];\n                            projectedPixelData[i + 3] =\n                                cartesianImageData.data[redPos + 3];\n                        }\n                    }\n                }\n                return projectedPixelData;\n            }\n            searchPoint(e, compareX) {\n                const series = this, chart = this.chart, mapView = chart.mapView;\n                if (mapView &&\n                    series.bounds &&\n                    series.image &&\n                    chart.tooltip &&\n                    chart.tooltip.options.enabled) {\n                    if (\n                    // If user drags map do not build k-d-tree\n                    chart.pointer.hasDragged === false &&\n                        // If user zooms in/out map do not build k-d-tree\n                        (+series.image.attr('animator') <= 0.01 ||\n                            +series.image.attr('animator') >= 0.99)) {\n                        const topLeft = mapView.projectedUnitsToPixels({\n                            x: series.bounds.x1,\n                            y: series.bounds.y2\n                        }), bottomRight = mapView.projectedUnitsToPixels({\n                            x: series.bounds.x2,\n                            y: series.bounds.y1\n                        });\n                        chart.pointer.normalize(e);\n                        if (e.lon && e.lat &&\n                            topLeft && bottomRight &&\n                            e.chartX - chart.plotLeft > topLeft.x &&\n                            e.chartX - chart.plotLeft < bottomRight.x &&\n                            e.chartY - chart.plotTop > topLeft.y &&\n                            e.chartY - chart.plotTop < bottomRight.y) {\n                            return this.searchKDTree({\n                                clientX: e.chartX,\n                                lon: normalizeLonValue(e.lon),\n                                lat: e.lat\n                            }, compareX, e);\n                        }\n                    }\n                    else {\n                        chart.tooltip.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * A `geoheatmap` series is a variety of heatmap series, composed into\n         * the map projection, where the units are expressed in the latitude\n         * and longitude, and individual values contained in a matrix are\n         * represented as colors.\n         *\n         * @sample maps/demo/geoheatmap-europe/\n         *         GeoHeatmap Chart with interpolation on Europe map\n         * @sample maps/series-geoheatmap/geoheatmap-equalearth/\n         *         GeoHeatmap Chart on the Equal Earth Projection\n         *\n         * @extends      plotOptions.map\n         * @since        11.0.0\n         * @product      highmaps\n         * @excluding    allAreas, dragDrop, findNearestPointBy, geometry, joinBy,\n         * negativeColor, onPoint, stickyTracking\n         * @requires     modules/geoheatmap\n         * @optionparent plotOptions.geoheatmap\n         */\n        GeoHeatmapSeries.defaultOptions = merge(MapSeries.defaultOptions, {\n            nullColor: 'transparent',\n            tooltip: {\n                pointFormat: 'Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>'\n            },\n            /**\n             * The border width of each geoheatmap tile.\n             *\n             * In styled mode, the border stroke width is given in the\n             * `.highcharts-point` class.\n             *\n             * @sample maps/demo/geoheatmap-orthographic/\n             *         borderWidth set to 1 to create a grid\n             *\n             * @type      {number|null}\n             * @default   0\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.borderWidth\n             */\n            borderWidth: 0,\n            /**\n             * The column size - how many longitude units each column in the\n             * geoheatmap should span.\n             *\n             * @sample maps/demo/geoheatmap-europe/\n             *         1 by default, set to 5\n             *\n             * @type      {number}\n             * @default   1\n             * @since 11.0.0\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.colsize\n             */\n            colsize: 1,\n            /**\n             * The main color of the series. In heat maps this color is rarely\n             * used, as we mostly use the color to denote the value of each\n             * point. Unless options are set in the [colorAxis](#colorAxis), the\n             * default value is pulled from the [options.colors](#colors) array.\n             *\n             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n             * @since 11.0.0\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.color\n             */\n            /**\n             * The rowsize size - how many latitude units each row in the\n             * geoheatmap should span.\n             *\n             * @sample maps/demo/geoheatmap-europe/\n             *         1 by default, set to 5\n             *\n             * @type      {number}\n             * @default   1\n             * @since 11.0.0\n             * @product   highmaps\n             * @apioption plotOptions.geoheatmap.rowsize\n             */\n            rowsize: 1,\n            stickyTracking: true,\n            /**\n             * Make the geoheatmap render its data points as an interpolated\n             * image. It can be used to show a Temperature Map-like charts.\n             *\n             * @sample maps/demo/geoheatmap-earth-statistics\n             *         Advanced demo of GeoHeatmap interpolation with multiple\n             *         datasets\n             *\n             * @type      {boolean|Highcharts.InterpolationOptionsObject}\n             * @since     @next\n             * @product   highmaps\n             */\n            interpolation: {\n                /**\n                 * Enable or disable the interpolation of the geoheatmap series.\n                 *\n                 * @since     @next\n                 */\n                enabled: false,\n                /**\n                 * Represents how much blur should be added to the interpolated\n                 * image. Works best in the range of 0-1, all higher values\n                 * would need a lot more perfomance of the machine to calculate\n                 * more detailed interpolation.\n                 *\n                 *  * **Note:** Useful, if the data is spread into wide range of\n                 *  longitue and latitude values.\n                 *\n                 * @sample maps/series-geoheatmap/turkey-fire-areas\n                 *         Simple demo of GeoHeatmap interpolation\n                 *\n                 * @since     @next\n                 */\n                blur: 1\n            }\n        });\n        addEvent(GeoHeatmapSeries, 'afterDataClassLegendClick', function () {\n            this.isDirtyCanvas = true;\n            this.drawPoints();\n        });\n        extend(GeoHeatmapSeries.prototype, {\n            type: 'geoheatmap',\n            applyJitter: noop,\n            pointClass: GeoHeatmapPoint,\n            pointArrayMap: ['lon', 'lat', 'value'],\n            kdAxisArray: ['lon', 'lat'] // Search k-d-tree by lon/lat values\n        });\n        SeriesRegistry.registerSeriesType('geoheatmap', GeoHeatmapSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `geoheatmap` series. If the [type](#series.map.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.geoheatmap\n         * @excluding allAreas, dataParser, dataURL, dragDrop, findNearestPointBy,\n         *            joinBy, marker, mapData, negativeColor, onPoint, shadow,\n         *            stickyTracking\n         * @product   highmaps\n         * @apioption series.geoheatmap\n         */\n        /**\n         * An array of data points for the series. For the `geoheatmap` series\n         * type, points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 or 2 values. In this case, the values\n         * correspond to `lon,lat,value`. The `value` refers to the color on the `colorAxis`.\n         *\n         *  ```js\n         *     data: [\n         *         [51.50, -0.12, 7],\n         *         [54.59, -5.93, 4],\n         *         [55.8, -4.25, 3]\n         *     ]\n         *  ```\n         *\n         * 2.  An array of objects with named values. The following snippet shows only a\n         * few settings, see the complete options set below. If the total number of data\n         * points exceeds the series' [turboThreshold](#series.heatmap.turboThreshold),\n         * this option is not available.\n         *\n         *  ```js\n         *     data: [{\n         *         lat: 51.50,\n         *         lon: -0.12,\n         *         value: 7,\n         *         name: \"London\"\n         *     }, {\n         *         lat: 54.59,\n         *         lon: -5.93,\n         *         value: 4,\n         *         name: \"Belfast\"\n         *     }]\n         *  ```\n         *\n         * @sample maps/demo/geoheatmap-europe/\n         *         GeoHeatmap Chart with interpolation on Europe map\n         * @sample maps/series-geoheatmap/geoheatmap-equalearth/\n         *         GeoHeatmap Chart on the Equal Earth Projection\n         *\n         * @type      {Array<Array<number>|*>}\n         * @extends   series.map.data\n         * @product   highmaps\n         * @apioption series.geoheatmap.data\n         */\n        /**\n         * Individual color for the point. By default the color is either used\n         * to denote the value, or pulled from the global `colors` array.\n         *\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @product   highmaps\n         * @apioption series.geoheatmap.data.color\n         */\n        /**\n         * The value of the point, resulting in a color controled by options\n         * as set in the [colorAxis](#colorAxis) configuration.\n         *\n         * @type      {number|null}\n         * @product   highmaps\n         * @apioption series.geoheatmap.data.value\n         */\n        /**\n         * Detailed options for interpolation object.\n         *\n         * @interface Highcharts.InterpolationOptionsObject\n         */ /**\n        *  Enable or disable the interpolation.\n        *\n        * @name Highcharts.InterpolationOptionsObject#enabled\n        * @type {boolean}\n        */ /**\n        * Represents how much blur should be added to the interpolated\n        * image. Works best in the range of 0-1, all higher values\n        * would need a lot more perfomance of the machine to calculate\n        * more detailed interpolation.\n        *\n        * @name Highcharts.InterpolationOptionsObject#blur\n        * @type {number}\n        */\n        ''; // adds doclets above to the transpiled file\n\n        return GeoHeatmapSeries;\n    });\n    _registerModule(_modules, 'masters/modules/geoheatmap.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","U","SeriesRegistry","map","prototype","pointClass","MapPoint","seriesTypes","isNumber","constructor","arguments","lat","lon","options","series","applyOptions","x","point","call","colsize","rowsize","x1","y1","geometry","type","coordinates","H","doc","defined","pick","colorFromPoint","value","colorAxis","rgba","toColor","split","s","parseFloat","parseInt","visible","getContext","canvas","context","clearRect","width","height","createElement","willReadFrequently","A","GeoHeatmapPoint","IU","animObject","stop","noop","MapSeries","addEvent","extend","isObject","merge","normalizeLonValue","Math","floor","GeoHeatmapSeries","data","points","isDirtyCanvas","update","getInterpolation","enabled","forEach","graphic","destroy","translate","image","isDirty","isDirtyData","interpolation","blur","drawPoints","chart","mapView","seriesOptions","bounds","ctx","topLeft","projectedUnitsToPixels","y","y2","bottomRight","x2","dimensions","projection","name","canvasWidth","canvasHeight","canvasArea","pixelData","Uint8ClampedArray","directTouch","i","length","p","sourceArr","set","scaledPointPos","ceil","blurFactor","upscaledWidth","upscaledHeight","projectedWidth","projectedHeight","img","ImageData","putImageData","globalCompositeOperation","drawImage","cartesianImageData","getImageData","projectedPixelData","getProjectedImageData","projectedImg","renderer","globalAnimation","hasRendered","startX","Number","attr","startY","startWidth","startHeight","step","now","fx","pos","animOptions","userStep","animator","href","toDataURL","animate","add","group","horizontalShift","verticalShift","lambda","rotation","widthFactor","heightFactor","projectedCoords","pixelsToLonLat","projected","cvs2PixelX","cvs2PixelY","redPos","round","searchPoint","e","compareX","tooltip","pointer","hasDragged","normalize","chartX","plotLeft","chartY","plotTop","searchKDTree","clientX","defaultOptions","nullColor","pointFormat","borderWidth","stickyTracking","applyJitter","pointArrayMap","kdAxisArray","registerSeriesType"],"mappings":"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"}