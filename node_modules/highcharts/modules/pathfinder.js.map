{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.2.0 (2023-10-30)\n *\n * Pathfinder\n *\n * (c) 2016-2021 Øystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pathfinder', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Gantt/Connection.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defined, error, merge, objectEach } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const deg2rad = H.deg2rad, max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Connection class. Used internally to represent a connection between two\n         * points.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Connection\n         *\n         * @param {Highcharts.Point} from\n         *        Connection runs from this Point.\n         *\n         * @param {Highcharts.Point} to\n         *        Connection runs to this Point.\n         *\n         * @param {Highcharts.ConnectorsOptions} [options]\n         *        Connection options.\n         */\n        class Connection {\n            constructor(from, to, options) {\n                /* *\n                *\n                * Properties\n                *\n                * */\n                this.chart = void 0;\n                this.fromPoint = void 0;\n                this.graphics = void 0;\n                this.pathfinder = void 0;\n                this.toPoint = void 0;\n                this.init(from, to, options);\n            }\n            /**\n             * Initialize the Connection object. Used as constructor only.\n             *\n             * @function Highcharts.Connection#init\n             *\n             * @param {Highcharts.Point} from\n             *        Connection runs from this Point.\n             *\n             * @param {Highcharts.Point} to\n             *        Connection runs to this Point.\n             *\n             * @param {Highcharts.ConnectorsOptions} [options]\n             *        Connection options.\n             */\n            init(from, to, options) {\n                this.fromPoint = from;\n                this.toPoint = to;\n                this.options = options;\n                this.chart = from.series.chart;\n                this.pathfinder = this.chart.pathfinder;\n            }\n            /**\n             * Add (or update) this connection's path on chart. Stores reference to the\n             * created element on this.graphics.path.\n             *\n             * @function Highcharts.Connection#renderPath\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]\n             *\n             * @param {Highcharts.SVGAttributes} [attribs]\n             *        SVG attributes for the path.\n             *\n             * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]\n             *        Animation options for the rendering.\n             */\n            renderPath(path, attribs, animation) {\n                const connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = chart.pathfinder, animate = !chart.options.chart.forExport && animation !== false, anim = {};\n                let pathGraphic = connection.graphics && connection.graphics.path;\n                // Add the SVG element of the pathfinder group if it doesn't exist\n                if (!pathfinder.group) {\n                    pathfinder.group = chart.renderer.g()\n                        .addClass('highcharts-pathfinder-group')\n                        .attr({ zIndex: -1 })\n                        .add(chart.seriesGroup);\n                }\n                // Shift the group to compensate for plot area.\n                // Note: Do this always (even when redrawing a path) to avoid issues\n                // when updating chart in a way that changes plot metrics.\n                pathfinder.group.translate(chart.plotLeft, chart.plotTop);\n                // Create path if does not exist\n                if (!(pathGraphic && pathGraphic.renderer)) {\n                    pathGraphic = chart.renderer.path()\n                        .add(pathfinder.group);\n                    if (!styledMode) {\n                        pathGraphic.attr({\n                            opacity: 0\n                        });\n                    }\n                }\n                // Set path attribs and animate to the new path\n                pathGraphic.attr(attribs);\n                anim.d = path;\n                if (!styledMode) {\n                    anim.opacity = 1;\n                }\n                pathGraphic[animate ? 'animate' : 'attr'](anim, animation);\n                // Store reference on connection\n                this.graphics = this.graphics || {};\n                this.graphics.path = pathGraphic;\n            }\n            /**\n             * Calculate and add marker graphics for connection to the chart. The\n             * created/updated elements are stored on this.graphics.start and\n             * this.graphics.end.\n             *\n             * @function Highcharts.Connection#addMarker\n             *\n             * @param {string} type\n             *        Marker type, either 'start' or 'end'.\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} options\n             *        All options for this marker. Not calculated or merged with other\n             *        options.\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Connection path in array format. This is used to calculate the\n             *        rotation angle of the markers.\n             */\n            addMarker(type, options, path) {\n                const connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = (type === 'start' ?\n                    connection.fromPoint :\n                    connection.toPoint), anchor = point.getPathfinderAnchorPoint(options);\n                let markerVector, radians, rotation, box, width, height, pathVector, segment;\n                if (!options.enabled) {\n                    return;\n                }\n                // Last vector before start/end of path, used to get angle\n                if (type === 'start') {\n                    segment = path[1];\n                }\n                else { // 'end'\n                    segment = path[path.length - 2];\n                }\n                if (segment && segment[0] === 'M' || segment[0] === 'L') {\n                    pathVector = {\n                        x: segment[1],\n                        y: segment[2]\n                    };\n                    // Get angle between pathVector and anchor point and use it to\n                    // create marker position.\n                    radians = point.getRadiansToVector(pathVector, anchor);\n                    markerVector = point.getMarkerVector(radians, options.radius, anchor);\n                    // Rotation of marker is calculated from angle between pathVector\n                    // and markerVector.\n                    // (Note:\n                    //  Used to recalculate radians between markerVector and pathVector,\n                    //  but this should be the same as between pathVector and anchor.)\n                    rotation = -radians / deg2rad;\n                    if (options.width && options.height) {\n                        width = options.width;\n                        height = options.height;\n                    }\n                    else {\n                        width = height = options.radius * 2;\n                    }\n                    // Add graphics object if it does not exist\n                    connection.graphics = connection.graphics || {};\n                    box = {\n                        x: markerVector.x - (width / 2),\n                        y: markerVector.y - (height / 2),\n                        width: width,\n                        height: height,\n                        rotation: rotation,\n                        rotationOriginX: markerVector.x,\n                        rotationOriginY: markerVector.y\n                    };\n                    if (!connection.graphics[type]) {\n                        // Create new marker element\n                        connection.graphics[type] = renderer\n                            .symbol(options.symbol)\n                            .addClass('highcharts-point-connecting-path-' + type + '-marker' +\n                            ' highcharts-color-' + this.fromPoint.colorIndex)\n                            .attr(box)\n                            .add(pathfinder.group);\n                        if (!renderer.styledMode) {\n                            connection.graphics[type].attr({\n                                fill: options.color || connection.fromPoint.color,\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth,\n                                opacity: 0\n                            })\n                                .animate({\n                                opacity: 1\n                            }, point.series.options.animation);\n                        }\n                    }\n                    else {\n                        connection.graphics[type].animate(box);\n                    }\n                }\n            }\n            /**\n             * Calculate and return connection path.\n             * Note: Recalculates chart obstacles on demand if they aren't calculated.\n             *\n             * @function Highcharts.Connection#getPath\n             *\n             * @param {Highcharts.ConnectorsOptions} options\n             *        Connector options. Not calculated or merged with other options.\n             *\n             * @return {object|undefined}\n             *         Calculated SVG path data in array format.\n             */\n            getPath(options) {\n                const pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options.type];\n                let chartObstacles = pathfinder.chartObstacles;\n                if (typeof algorithm !== 'function') {\n                    error('\"' + options.type + '\" is not a Pathfinder algorithm.');\n                    return {\n                        path: [],\n                        obstacles: []\n                    };\n                }\n                // This function calculates obstacles on demand if they don't exist\n                if (algorithm.requiresObstacles && !chartObstacles) {\n                    chartObstacles =\n                        pathfinder.chartObstacles =\n                            pathfinder.getChartObstacles(options);\n                    // If the algorithmMargin was computed, store the result in default\n                    // options.\n                    chart.options.connectors.algorithmMargin =\n                        options.algorithmMargin;\n                    // Cache some metrics too\n                    pathfinder.chartObstacleMetrics =\n                        pathfinder.getObstacleMetrics(chartObstacles);\n                }\n                // Get the SVG path\n                return algorithm(\n                // From\n                this.fromPoint.getPathfinderAnchorPoint(options.startMarker), \n                // To\n                this.toPoint.getPathfinderAnchorPoint(options.endMarker), merge({\n                    chartObstacles: chartObstacles,\n                    lineObstacles: pathfinder.lineObstacles || [],\n                    obstacleMetrics: pathfinder.chartObstacleMetrics,\n                    hardBounds: {\n                        xMin: 0,\n                        xMax: chart.plotWidth,\n                        yMin: 0,\n                        yMax: chart.plotHeight\n                    },\n                    obstacleOptions: {\n                        margin: options.algorithmMargin\n                    },\n                    startDirectionX: pathfinder.getAlgorithmStartDirection(options.startMarker)\n                }, options));\n            }\n            /**\n             * (re)Calculate and (re)draw the connection.\n             *\n             * @function Highcharts.Connection#render\n             */\n            render() {\n                const connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};\n                let options = merge(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);\n                // Set path attribs\n                if (!chart.styledMode) {\n                    attribs.stroke = options.lineColor || fromPoint.color;\n                    attribs['stroke-width'] = options.lineWidth;\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                }\n                attribs['class'] = // eslint-disable-line dot-notation\n                    'highcharts-point-connecting-path ' +\n                        'highcharts-color-' + fromPoint.colorIndex;\n                options = merge(attribs, options);\n                // Set common marker options\n                if (!defined(options.marker.radius)) {\n                    options.marker.radius = min(max(Math.ceil((options.algorithmMargin || 8) / 2) - 1, 1), 5);\n                }\n                // Get the path\n                const pathResult = connection.getPath(options), path = pathResult.path;\n                // Always update obstacle storage with obstacles from this path.\n                // We don't know if future calls will need this for their algorithm.\n                if (pathResult.obstacles) {\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles || [];\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles.concat(pathResult.obstacles);\n                }\n                // Add the calculated path to the pathfinder group\n                connection.renderPath(path, attribs, series.options.animation);\n                // Render the markers\n                connection.addMarker('start', merge(options.marker, options.startMarker), path);\n                connection.addMarker('end', merge(options.marker, options.endMarker), path);\n            }\n            /**\n             * Destroy connection by destroying the added graphics elements.\n             *\n             * @function Highcharts.Connection#destroy\n             */\n            destroy() {\n                if (this.graphics) {\n                    objectEach(this.graphics, function (val) {\n                        val.destroy();\n                    });\n                    delete this.graphics;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Connection;\n    });\n    _registerModule(_modules, 'Series/PathUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2022 Pawel Lysy\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const getLinkPath = {\n            'default': getDefaultPath,\n            straight: getStraightPath,\n            curved: getCurvedPath\n        };\n        function getDefaultPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, radius, parentVisible } = pathParams;\n            const path = [\n                ['M', x1, y1],\n                ['L', x1, y1],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2]\n            ];\n            return parentVisible ?\n                applyRadius([\n                    ['M', x1, y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y2],\n                    ['L', x2, y2]\n                ], radius) :\n                path;\n        }\n        function getStraightPath(pathParams) {\n            const { x1, y1, x2, y2, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ? [\n                ['M', x1, y1],\n                ['L', x1 + width * (inverted ? -1 : 1), y2],\n                ['L', x2, y2]\n            ] : [\n                ['M', x1, y1],\n                ['L', x1, y2],\n                ['L', x1, y2]\n            ];\n        }\n        function getCurvedPath(pathParams) {\n            const { x1, y1, x2, y2, offset = 0, width = 0, inverted = false, parentVisible } = pathParams;\n            return parentVisible ?\n                [\n                    ['M', x1, y1],\n                    [\n                        'C',\n                        x1 + offset,\n                        y1,\n                        x1 - offset + width * (inverted ? -1 : 1),\n                        y2,\n                        x1 + width * (inverted ? -1 : 1),\n                        y2\n                    ],\n                    ['L', x2, y2]\n                ] :\n                [\n                    ['M', x1, y1],\n                    ['C', x1, y1, x1, y2, x1, y2],\n                    ['L', x2, y2]\n                ];\n        }\n        /**\n         * General function to apply corner radius to a path\n         * @private\n         */\n        function applyRadius(path, r) {\n            const d = [];\n            for (let i = 0; i < path.length; i++) {\n                const x = path[i][1];\n                const y = path[i][2];\n                if (typeof x === 'number' && typeof y === 'number') {\n                    // moveTo\n                    if (i === 0) {\n                        d.push(['M', x, y]);\n                    }\n                    else if (i === path.length - 1) {\n                        d.push(['L', x, y]);\n                        // curveTo\n                    }\n                    else if (r) {\n                        const prevSeg = path[i - 1];\n                        const nextSeg = path[i + 1];\n                        if (prevSeg && nextSeg) {\n                            const x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];\n                            // Only apply to breaks\n                            if (typeof x1 === 'number' &&\n                                typeof x2 === 'number' &&\n                                typeof y1 === 'number' &&\n                                typeof y2 === 'number' &&\n                                x1 !== x2 &&\n                                y1 !== y2) {\n                                const directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;\n                                d.push([\n                                    'L',\n                                    x - directionX * Math.min(Math.abs(x - x1), r),\n                                    y - directionY * Math.min(Math.abs(y - y1), r)\n                                ], [\n                                    'C',\n                                    x,\n                                    y,\n                                    x,\n                                    y,\n                                    x + directionX * Math.min(Math.abs(x - x2), r),\n                                    y + directionY * Math.min(Math.abs(y - y2), r)\n                                ]);\n                            }\n                        }\n                        // lineTo\n                    }\n                    else {\n                        d.push(['L', x, y]);\n                    }\n                }\n            }\n            return d;\n        }\n        const PathUtilities = {\n            applyRadius,\n            getLinkPath\n        };\n\n        return PathUtilities;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderAlgorithms.js', [_modules['Series/PathUtilities.js'], _modules['Core/Utilities.js']], function (PathUtilities, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Author: Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const { min, max, abs } = Math;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get index of last obstacle before xMin. Employs a type of binary search, and\n         * thus requires that obstacles are sorted by xMin value.\n         *\n         * @private\n         * @function findLastObstacleBefore\n         *\n         * @param {Array<object>} obstacles\n         *        Array of obstacles to search in.\n         *\n         * @param {number} xMin\n         *        The xMin threshold.\n         *\n         * @param {number} [startIx]\n         *        Starting index to search from. Must be within array range.\n         *\n         * @return {number}\n         *         The index of the last obstacle element before xMin.\n         */\n        function findLastObstacleBefore(obstacles, xMin, startIx) {\n            const min = xMin - 0.0000001; // Make sure we include all obstacles at xMin\n            let left = startIx || 0, // Left limit\n            right = obstacles.length - 1, // Right limit\n            cursor, cmp;\n            while (left <= right) {\n                cursor = (right + left) >> 1;\n                cmp = min - obstacles[cursor].xMin;\n                if (cmp > 0) {\n                    left = cursor + 1;\n                }\n                else if (cmp < 0) {\n                    right = cursor - 1;\n                }\n                else {\n                    return cursor;\n                }\n            }\n            return left > 0 ? left - 1 : 0;\n        }\n        /**\n         * Test if a point lays within an obstacle.\n         *\n         * @private\n         * @function pointWithinObstacle\n         *\n         * @param {Object} obstacle\n         *        Obstacle to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {boolean}\n         *         Whether point is within the obstacle or not.\n         */\n        function pointWithinObstacle(obstacle, point) {\n            return (point.x <= obstacle.xMax &&\n                point.x >= obstacle.xMin &&\n                point.y <= obstacle.yMax &&\n                point.y >= obstacle.yMin);\n        }\n        /**\n         * Find the index of an obstacle that wraps around a point.\n         * Returns -1 if not found.\n         *\n         * @private\n         * @function findObstacleFromPoint\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {number}\n         *         Ix of the obstacle in the array, or -1 if not found.\n         */\n        function findObstacleFromPoint(obstacles, point) {\n            let i = findLastObstacleBefore(obstacles, point.x + 1) + 1;\n            while (i--) {\n                if (obstacles[i].xMax >= point.x &&\n                    // Optimization using lazy evaluation\n                    pointWithinObstacle(obstacles[i], point)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get SVG path array from array of line segments.\n         *\n         * @private\n         * @function pathFromSegments\n         *\n         * @param {Array<object>} segments\n         *        The segments to build the path from.\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         SVG path array as accepted by the SVG Renderer.\n         */\n        function pathFromSegments(segments) {\n            const path = [];\n            if (segments.length) {\n                path.push(['M', segments[0].start.x, segments[0].start.y]);\n                for (let i = 0; i < segments.length; ++i) {\n                    path.push(['L', segments[i].end.x, segments[i].end.y]);\n                }\n            }\n            return path;\n        }\n        /**\n         * Limits obstacle max/mins in all directions to bounds. Modifies input\n         * obstacle.\n         *\n         * @private\n         * @function limitObstacleToBounds\n         *\n         * @param {Object} obstacle\n         *        Obstacle to limit.\n         *\n         * @param {Object} bounds\n         *        Bounds to use as limit.\n         *\n         * @return {void}\n         */\n        function limitObstacleToBounds(obstacle, bounds) {\n            obstacle.yMin = max(obstacle.yMin, bounds.yMin);\n            obstacle.yMax = min(obstacle.yMax, bounds.yMax);\n            obstacle.xMin = max(obstacle.xMin, bounds.xMin);\n            obstacle.xMax = min(obstacle.xMax, bounds.xMax);\n        }\n        /**\n         * Get an SVG path from a starting coordinate to an ending coordinate.\n         * Draws a straight line.\n         *\n         * @function Highcharts.Pathfinder.algorithms.straight\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function straight(start, end) {\n            return {\n                path: [\n                    ['M', start.x, start.y],\n                    ['L', end.x, end.y]\n                ],\n                obstacles: [{ start: start, end: end }]\n            };\n        }\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, using\n         * right angles only, and taking only starting/ending obstacle into\n         * consideration.\n         *\n         * @function Highcharts.Pathfinder.algorithms.simpleConnect\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm:\n         *        - chartObstacles: Array of chart obstacles to avoid\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *          If not provided, the algorithm starts in the direction that is\n         *          the furthest between start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        const simpleConnect = function (start, end, options) {\n            const segments = [], chartObstacles = options.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);\n            let endSegment, dir = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? 'x' : 'y', startObstacle, endObstacle, waypoint, useMax, endPoint;\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return a clone of a point with a property set from a target object,\n             * optionally with an offset\n             * @private\n             */\n            function copyFromPoint(from, fromKey, to, toKey, offset) {\n                const point = {\n                    x: from.x,\n                    y: from.y\n                };\n                point[fromKey] = to[toKey || fromKey] + (offset || 0);\n                return point;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return waypoint outside obstacle.\n             * @private\n             */\n            function getMeOut(obstacle, point, direction) {\n                const useMax = abs(point[direction] - obstacle[direction + 'Min']) >\n                    abs(point[direction] - obstacle[direction + 'Max']);\n                return copyFromPoint(point, direction, obstacle, direction + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1);\n            }\n            // Pull out end point\n            if (endObstacleIx > -1) {\n                endObstacle = chartObstacles[endObstacleIx];\n                waypoint = getMeOut(endObstacle, end, dir);\n                endSegment = {\n                    start: waypoint,\n                    end: end\n                };\n                endPoint = waypoint;\n            }\n            else {\n                endPoint = end;\n            }\n            // If an obstacle envelops the start point, add a segment to get out,\n            // and around it.\n            if (startObstacleIx > -1) {\n                startObstacle = chartObstacles[startObstacleIx];\n                waypoint = getMeOut(startObstacle, start, dir);\n                segments.push({\n                    start: start,\n                    end: waypoint\n                });\n                // If we are going back again, switch direction to get around start\n                // obstacle.\n                if (\n                // Going towards max from start:\n                waypoint[dir] >= start[dir] ===\n                    // Going towards min to end:\n                    waypoint[dir] >= endPoint[dir]) {\n                    dir = dir === 'y' ? 'x' : 'y';\n                    useMax = start[dir] < end[dir];\n                    segments.push({\n                        start: waypoint,\n                        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1)\n                    });\n                    // Switch direction again\n                    dir = dir === 'y' ? 'x' : 'y';\n                }\n            }\n            // We are around the start obstacle. Go towards the end in one\n            // direction.\n            const prevWaypoint = segments.length ?\n                segments[segments.length - 1].end :\n                start;\n            waypoint = copyFromPoint(prevWaypoint, dir, endPoint);\n            segments.push({\n                start: prevWaypoint,\n                end: waypoint\n            });\n            // Final run to end point in the other direction\n            dir = dir === 'y' ? 'x' : 'y';\n            const waypoint2 = copyFromPoint(waypoint, dir, endPoint);\n            segments.push({\n                start: waypoint,\n                end: waypoint2\n            });\n            // Finally add the endSegment\n            segments.push(endSegment);\n            const path = PathUtilities.applyRadius(pathFromSegments(segments), options.radius);\n            return {\n                path,\n                obstacles: segments\n            };\n        };\n        simpleConnect.requiresObstacles = true;\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, taking\n         * obstacles into consideration. Might not always find the optimal path,\n         * but is fast, and usually good enough.\n         *\n         * @function Highcharts.Pathfinder.algorithms.fastAvoid\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm.\n         *        - chartObstacles:  Array of chart obstacles to avoid\n         *        - lineObstacles:   Array of line obstacles to jump over\n         *        - obstacleMetrics: Object with metrics of chartObstacles cached\n         *        - hardBounds:      Hard boundaries to not cross\n         *        - obstacleOptions: Options for the obstacles, including margin\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *                           If not provided, the algorithm starts in the\n         *                           direction that is the furthest between\n         *                           start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function fastAvoid(start, end, options) {\n            /*\n                Algorithm rules/description\n                - Find initial direction\n                - Determine soft/hard max for each direction.\n                - Move along initial direction until obstacle.\n                - Change direction.\n                - If hitting obstacle, first try to change length of previous line\n                    before changing direction again.\n\n                Soft min/max x = start/destination x +/- widest obstacle + margin\n                Soft min/max y = start/destination y +/- tallest obstacle + margin\n\n                @todo:\n                    - Make retrospective, try changing prev segment to reduce\n                        corners\n                    - Fix logic for breaking out of end-points - not always picking\n                        the best direction currently\n                    - When going around the end obstacle we should not always go the\n                        shortest route, rather pick the one closer to the end point\n            */\n            const dirIsX = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? 'x' : 'y', endSegments = [], \n            // Boundaries to stay within. If beyond soft boundary, prefer to\n            // change direction ASAP. If at hard max, always change immediately.\n            metrics = options.obstacleMetrics, softMinX = min(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max(start.x, end.x) + metrics.maxWidth + 10, softMinY = min(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max(start.y, end.y) + metrics.maxHeight + 10;\n            let segments, useMax, extractedEndPoint, forceObstacleBreak = false, // Used in clearPathTo to keep track of\n            // when to force break through an obstacle.\n            // Obstacles\n            chartObstacles = options.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);\n            const startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * How far can you go between two points before hitting an obstacle?\n             * Does not work for diagonal lines (because it doesn't have to).\n             * @private\n             */\n            function pivotPoint(fromPoint, toPoint, directionIsX) {\n                const searchDirection = fromPoint.x < toPoint.x ? 1 : -1;\n                let firstPoint, lastPoint, highestPoint, lowestPoint;\n                if (fromPoint.x < toPoint.x) {\n                    firstPoint = fromPoint;\n                    lastPoint = toPoint;\n                }\n                else {\n                    firstPoint = toPoint;\n                    lastPoint = fromPoint;\n                }\n                if (fromPoint.y < toPoint.y) {\n                    lowestPoint = fromPoint;\n                    highestPoint = toPoint;\n                }\n                else {\n                    lowestPoint = toPoint;\n                    highestPoint = fromPoint;\n                }\n                // Go through obstacle range in reverse if toPoint is before\n                // fromPoint in the X-dimension.\n                let i = searchDirection < 0 ?\n                    // Searching backwards, start at last obstacle before last point\n                    min(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1) :\n                    // Forwards. Since we're not sorted by xMax, we have to look\n                    // at all obstacles.\n                    0;\n                // Go through obstacles in this X range\n                while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x ||\n                    searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {\n                    // If this obstacle is between from and to points in a straight\n                    // line, pivot at the intersection.\n                    if (chartObstacles[i].xMin <= lastPoint.x &&\n                        chartObstacles[i].xMax >= firstPoint.x &&\n                        chartObstacles[i].yMin <= highestPoint.y &&\n                        chartObstacles[i].yMax >= lowestPoint.y) {\n                        if (directionIsX) {\n                            return {\n                                y: fromPoint.y,\n                                x: fromPoint.x < toPoint.x ?\n                                    chartObstacles[i].xMin - 1 :\n                                    chartObstacles[i].xMax + 1,\n                                obstacle: chartObstacles[i]\n                            };\n                        }\n                        // Else ...\n                        return {\n                            x: fromPoint.x,\n                            y: fromPoint.y < toPoint.y ?\n                                chartObstacles[i].yMin - 1 :\n                                chartObstacles[i].yMax + 1,\n                            obstacle: chartObstacles[i]\n                        };\n                    }\n                    i += searchDirection;\n                }\n                return toPoint;\n            }\n            /**\n             * Decide in which direction to dodge or get out of an obstacle.\n             * Considers desired direction, which way is shortest, soft and hard\n             * bounds.\n             *\n             * (? Returns a string, either xMin, xMax, yMin or yMax.)\n             *\n             * @private\n             * @function\n             *\n             * @param {Object} obstacle\n             *        Obstacle to dodge/escape.\n             *\n             * @param {Object} fromPoint\n             *        Point with x/y props that's dodging/escaping.\n             *\n             * @param {Object} toPoint\n             *        Goal point.\n             *\n             * @param {boolean} dirIsX\n             *        Dodge in X dimension.\n             *\n             * @param {Object} bounds\n             *        Hard and soft boundaries.\n             *\n             * @return {boolean}\n             *         Use max or not.\n             */\n            function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX, bounds) {\n                const softBounds = bounds.soft, hardBounds = bounds.hard, dir = dirIsX ? 'x' : 'y', toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir + 'Max'] >=\n                    softBounds[dir + 'Max'], minOutOfSoftBounds = obstacle[dir + 'Min'] <=\n                    softBounds[dir + 'Min'], maxOutOfHardBounds = obstacle[dir + 'Max'] >=\n                    hardBounds[dir + 'Max'], minOutOfHardBounds = obstacle[dir + 'Min'] <=\n                    hardBounds[dir + 'Min'], \n                // Find out if we should prefer one direction over the other if\n                // we can choose freely\n                minDistance = abs(obstacle[dir + 'Min'] - fromPoint[dir]), maxDistance = abs(obstacle[dir + 'Max'] - fromPoint[dir]);\n                let // If it's a small difference, pick the one leading towards dest\n                // point. Otherwise pick the shortest distance\n                useMax = abs(minDistance - maxDistance) < 10 ?\n                    fromPoint[dir] < toPoint[dir] :\n                    maxDistance < minDistance;\n                // Check if we hit any obstacles trying to go around in either\n                // direction.\n                toPointMin[dir] = obstacle[dir + 'Min'];\n                toPointMax[dir] = obstacle[dir + 'Max'];\n                const minPivot = pivotPoint(fromPoint, toPointMin, dirIsX)[dir] !==\n                    toPointMin[dir], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX)[dir] !==\n                    toPointMax[dir];\n                useMax = minPivot ?\n                    (maxPivot ? useMax : true) :\n                    (maxPivot ? false : useMax);\n                // `useMax` now contains our preferred choice, bounds not taken into\n                // account. If both or neither direction is out of bounds we want to\n                // use this.\n                // Deal with soft bounds\n                useMax = minOutOfSoftBounds ?\n                    (maxOutOfSoftBounds ? useMax : true) : // Out on min\n                    (maxOutOfSoftBounds ? false : useMax); // Not out on min\n                // Deal with hard bounds\n                useMax = minOutOfHardBounds ?\n                    (maxOutOfHardBounds ? useMax : true) : // Out on min\n                    (maxOutOfHardBounds ? false : useMax); // Not out on min\n                return useMax;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Find a clear path between point.\n             * @private\n             */\n            function clearPathTo(fromPoint, toPoint, dirIsX) {\n                // Don't waste time if we've hit goal\n                if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {\n                    return [];\n                }\n                const dir = dirIsX ? 'x' : 'y', obstacleMargin = options.obstacleOptions.margin, bounds = {\n                    soft: {\n                        xMin: softMinX,\n                        xMax: softMaxX,\n                        yMin: softMinY,\n                        yMax: softMaxY\n                    },\n                    hard: options.hardBounds\n                };\n                let pivot, segments, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;\n                // If fromPoint is inside an obstacle we have a problem. Break out\n                // by just going to the outside of this obstacle. We prefer to go to\n                // the nearest edge in the chosen direction.\n                envelopingObstacle =\n                    findObstacleFromPoint(chartObstacles, fromPoint);\n                if (envelopingObstacle > -1) {\n                    envelopingObstacle = chartObstacles[envelopingObstacle];\n                    waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX, bounds);\n                    // Cut obstacle to hard bounds to make sure we stay within\n                    limitObstacleToBounds(envelopingObstacle, options.hardBounds);\n                    envelopWaypoint = dirIsX ? {\n                        y: fromPoint.y,\n                        x: envelopingObstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    } : {\n                        x: fromPoint.x,\n                        y: envelopingObstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    };\n                    // If we crashed into another obstacle doing this, we put the\n                    // waypoint between them instead\n                    secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);\n                    if (secondEnvelopingObstacle > -1) {\n                        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];\n                        // Cut obstacle to hard bounds\n                        limitObstacleToBounds(secondEnvelopingObstacle, options.hardBounds);\n                        // Modify waypoint to lay between obstacles\n                        envelopWaypoint[dir] = waypointUseMax ? max(envelopingObstacle[dir + 'Max'] - obstacleMargin + 1, (secondEnvelopingObstacle[dir + 'Min'] +\n                            envelopingObstacle[dir + 'Max']) / 2) :\n                            min((envelopingObstacle[dir + 'Min'] + obstacleMargin - 1), ((secondEnvelopingObstacle[dir + 'Max'] +\n                                envelopingObstacle[dir + 'Min']) / 2));\n                        // We are not going anywhere. If this happens for the first\n                        // time, do nothing. Otherwise, try to go to the extreme of\n                        // the obstacle pair in the current direction.\n                        if (fromPoint.x === envelopWaypoint.x &&\n                            fromPoint.y === envelopWaypoint.y) {\n                            if (forceObstacleBreak) {\n                                envelopWaypoint[dir] = waypointUseMax ?\n                                    max(envelopingObstacle[dir + 'Max'], secondEnvelopingObstacle[dir + 'Max']) + 1 :\n                                    min(envelopingObstacle[dir + 'Min'], secondEnvelopingObstacle[dir + 'Min']) - 1;\n                            }\n                            // Toggle on if off, and the opposite\n                            forceObstacleBreak = !forceObstacleBreak;\n                        }\n                        else {\n                            // This point is not identical to previous.\n                            // Clear break trigger.\n                            forceObstacleBreak = false;\n                        }\n                    }\n                    segments = [{\n                            start: fromPoint,\n                            end: envelopWaypoint\n                        }];\n                }\n                else { // If not enveloping, use standard pivot calculation\n                    pivot = pivotPoint(fromPoint, {\n                        x: dirIsX ? toPoint.x : fromPoint.x,\n                        y: dirIsX ? fromPoint.y : toPoint.y\n                    }, dirIsX);\n                    segments = [{\n                            start: fromPoint,\n                            end: {\n                                x: pivot.x,\n                                y: pivot.y\n                            }\n                        }];\n                    // Pivot before goal, use a waypoint to dodge obstacle\n                    if (pivot[dirIsX ? 'x' : 'y'] !== toPoint[dirIsX ? 'x' : 'y']) {\n                        // Find direction of waypoint\n                        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX, bounds);\n                        // Cut waypoint to hard bounds\n                        limitObstacleToBounds(pivot.obstacle, options.hardBounds);\n                        waypoint = {\n                            x: dirIsX ?\n                                pivot.x :\n                                pivot.obstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                                    (waypointUseMax ? 1 : -1),\n                            y: dirIsX ?\n                                pivot.obstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                                    (waypointUseMax ? 1 : -1) :\n                                pivot.y\n                        };\n                        // We're changing direction here, store that to make sure we\n                        // also change direction when adding the last segment array\n                        // after handling waypoint.\n                        dirIsX = !dirIsX;\n                        segments = segments.concat(clearPathTo({\n                            x: pivot.x,\n                            y: pivot.y\n                        }, waypoint, dirIsX));\n                    }\n                }\n                // Get segments for the other direction too\n                // Recursion is our friend\n                segments = segments.concat(clearPathTo(segments[segments.length - 1].end, toPoint, !dirIsX));\n                return segments;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Extract point to outside of obstacle in whichever direction is\n             * closest. Returns new point outside obstacle.\n             * @private\n             */\n            function extractFromObstacle(obstacle, point, goalPoint) {\n                const dirIsX = min(obstacle.xMax - point.x, point.x - obstacle.xMin) <\n                    min(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {\n                    soft: options.hardBounds,\n                    hard: options.hardBounds\n                }, useMax = getDodgeDirection(obstacle, point, goalPoint, dirIsX, bounds);\n                return dirIsX ? {\n                    y: point.y,\n                    x: obstacle[useMax ? 'xMax' : 'xMin'] + (useMax ? 1 : -1)\n                } : {\n                    x: point.x,\n                    y: obstacle[useMax ? 'yMax' : 'yMin'] + (useMax ? 1 : -1)\n                };\n            }\n            // Cut the obstacle array to soft bounds for optimization in large\n            // datasets.\n            chartObstacles =\n                chartObstacles.slice(startObstacleIx, endObstacleIx + 1);\n            // If an obstacle envelops the end point, move it out of there and add\n            // a little segment to where it was.\n            if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // If it's still inside one or more obstacles, get out of there by\n            // force-moving towards the start point.\n            while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                useMax = end[dir] - start[dir] < 0;\n                extractedEndPoint = {\n                    x: end.x,\n                    y: end.y\n                };\n                extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + 'Max' : dir + 'Min'] + (useMax ? 1 : -1);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // Find the path\n            segments = clearPathTo(start, end, dirIsX);\n            // Add the end-point segments\n            segments = segments.concat(endSegments.reverse());\n            return {\n                path: pathFromSegments(segments),\n                obstacles: segments\n            };\n        }\n        fastAvoid.requiresObstacles = true;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        // Define the available pathfinding algorithms.\n        // Algorithms take up to 3 arguments: starting point, ending point, and an\n        // options object.\n        const algorithms = {\n            fastAvoid,\n            straight,\n            simpleConnect\n        };\n\n        return algorithms;\n    });\n    _registerModule(_modules, 'Gantt/ConnectorsDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Defaults\n         *\n         * */\n        /*\n         @todo:\n             - Document how to write your own algorithms\n             - Consider adding a Point.pathTo method that wraps creating a connection\n               and rendering it\n        */\n        const connectorsDefaults = {\n            /**\n             * The Pathfinder module allows you to define connections between any two\n             * points, represented as lines - optionally with markers for the start\n             * and/or end points. Multiple algorithms are available for calculating how\n             * the connecting lines are drawn.\n             *\n             * Connector functionality requires Highcharts Gantt to be loaded. In Gantt\n             * charts, the connectors are used to draw dependencies between tasks.\n             *\n             * @see [dependency](series.gantt.data.dependency)\n             *\n             * @sample gantt/pathfinder/demo\n             *         Pathfinder connections\n             *\n             * @declare      Highcharts.ConnectorsOptions\n             * @product      gantt\n             * @optionparent connectors\n             */\n            connectors: {\n                /**\n                 * Enable connectors for this chart. Requires Highcharts Gantt.\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     6.2.0\n                 * @apioption connectors.enabled\n                 */\n                /**\n                 * Set the default dash style for this chart's connecting lines.\n                 *\n                 * @type      {string}\n                 * @default   solid\n                 * @since     6.2.0\n                 * @apioption connectors.dashStyle\n                 */\n                /**\n                 * Set the default color for this chart's Pathfinder connecting lines.\n                 * Defaults to the color of the point being connected.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @since     6.2.0\n                 * @apioption connectors.lineColor\n                 */\n                /**\n                 * Set the default pathfinder margin to use, in pixels. Some Pathfinder\n                 * algorithms attempt to avoid obstacles, such as other points in the\n                 * chart. These algorithms use this margin to determine how close lines\n                 * can be to an obstacle. The default is to compute this automatically\n                 * from the size of the obstacles in the chart.\n                 *\n                 * To draw connecting lines close to existing points, set this to a low\n                 * number. For more space around existing points, set this number\n                 * higher.\n                 *\n                 * @sample gantt/pathfinder/algorithm-margin\n                 *         Small algorithmMargin\n                 *\n                 * @type      {number}\n                 * @since     6.2.0\n                 * @apioption connectors.algorithmMargin\n                 */\n                /**\n                 * Set the default pathfinder algorithm to use for this chart. It is\n                 * possible to define your own algorithms by adding them to the\n                 * Highcharts.Pathfinder.prototype.algorithms object before the chart\n                 * has been created.\n                 *\n                 * The default algorithms are as follows:\n                 *\n                 * `straight`:      Draws a straight line between the connecting\n                 *                  points. Does not avoid other points when drawing.\n                 *\n                 * `simpleConnect`: Finds a path between the points using right angles\n                 *                  only. Takes only starting/ending points into\n                 *                  account, and will not avoid other points.\n                 *\n                 * `fastAvoid`:     Finds a path between the points using right angles\n                 *                  only. Will attempt to avoid other points, but its\n                 *                  focus is performance over accuracy. Works well with\n                 *                  less dense datasets.\n                 *\n                 * Default value: `straight` is used as default for most series types,\n                 * while `simpleConnect` is used as default for Gantt series, to show\n                 * dependencies between points.\n                 *\n                 * @sample gantt/pathfinder/demo\n                 *         Different types used\n                 *\n                 * @type    {Highcharts.PathfinderTypeValue}\n                 * @default undefined\n                 * @since   6.2.0\n                 */\n                type: 'straight',\n                /**\n                 * The corner radius for the connector line.\n                 *\n                 * @since 11.2.0\n                 */\n                radius: 0,\n                /**\n                 * Set the default pixel width for this chart's Pathfinder connecting\n                 * lines.\n                 *\n                 * @since 6.2.0\n                 */\n                lineWidth: 1,\n                /**\n                 * Marker options for this chart's Pathfinder connectors. Note that\n                 * this option is overridden by the `startMarker` and `endMarker`\n                 * options.\n                 *\n                 * @declare Highcharts.ConnectorsMarkerOptions\n                 * @since   6.2.0\n                 */\n                marker: {\n                    /**\n                     * Set the radius of the connector markers. The default is\n                     * automatically computed based on the algorithmMargin setting.\n                     *\n                     * Setting marker.width and marker.height will override this\n                     * setting.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.radius\n                     */\n                    /**\n                     * Set the width of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.width\n                     */\n                    /**\n                     * Set the height of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.height\n                     */\n                    /**\n                     * Set the color of the connector markers. By default this is the\n                     * same as the connector color.\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.color\n                     */\n                    /**\n                     * Set the line/border color of the connector markers. By default\n                     * this is the same as the marker color.\n                     *\n                     * @type      {Highcharts.ColorString}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.lineColor\n                     */\n                    /**\n                     * Enable markers for the connectors.\n                     */\n                    enabled: false,\n                    /**\n                     * Horizontal alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'center',\n                    /**\n                     * Vertical alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.VerticalAlignValue}\n                     */\n                    verticalAlign: 'middle',\n                    /**\n                     * Whether or not to draw the markers inside the points.\n                     */\n                    inside: false,\n                    /**\n                     * Set the line/border width of the pathfinder markers.\n                     */\n                    lineWidth: 1\n                },\n                /**\n                 * Marker options specific to the start markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsStartMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                startMarker: {\n                    /**\n                     * Set the symbol of the connector start markers.\n                     */\n                    symbol: 'diamond'\n                },\n                /**\n                 * Marker options specific to the end markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsEndMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                endMarker: {\n                    /**\n                     * Set the symbol of the connector end markers.\n                     */\n                    symbol: 'arrow-filled'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Override Pathfinder connector options for a series. Requires Highcharts Gantt\n         * to be loaded.\n         *\n         * @declare   Highcharts.SeriesConnectorsOptionsObject\n         * @extends   connectors\n         * @since     6.2.0\n         * @excluding enabled, algorithmMargin\n         * @product   gantt\n         * @apioption plotOptions.series.connectors\n         */\n        /**\n         * Connect to a point. This option can be either a string, referring to the ID\n         * of another point, or an object, or an array of either. If the option is an\n         * array, each element defines a connection.\n         *\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @declare   Highcharts.XrangePointConnectorsOptionsObject\n         * @type      {string|Array<string|*>|*}\n         * @extends   plotOptions.series.connectors\n         * @since     6.2.0\n         * @excluding enabled\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.xrange.data.connect\n         */\n        /**\n         * The ID of the point to connect to.\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.xrange.data.connect.to\n         */\n        ''; // Keeps doclets above in JS file\n\n        return connectorsDefaults;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderComposition.js', [_modules['Gantt/ConnectorsDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (ConnectorsDefaults, D, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { setOptions } = D;\n        const { defined, error, merge, pushUnique } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Warn if using legacy options. Copy the options over. Note that this will\n         * still break if using the legacy options in chart.update, addSeries etc.\n         * @private\n         */\n        function warnLegacy(chart) {\n            if (chart.options.pathfinder ||\n                chart.series.reduce(function (acc, series) {\n                    if (series.options) {\n                        merge(true, (series.options.connectors = series.options.connectors ||\n                            {}), series.options.pathfinder);\n                    }\n                    return acc || series.options && series.options.pathfinder;\n                }, false)) {\n                merge(true, (chart.options.connectors = chart.options.connectors || {}), chart.options.pathfinder);\n                error('WARNING: Pathfinder options have been renamed. ' +\n                    'Use \"chart.connectors\" or \"series.connectors\" instead.');\n            }\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ConnectionComposition;\n        (function (ConnectionComposition) {\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(ChartClass, PathfinderClass, PointClass) {\n                if (pushUnique(composedMembers, ChartClass)) {\n                    // Initialize Pathfinder for charts\n                    ChartClass.prototype.callbacks.push(function (chart) {\n                        const options = chart.options;\n                        if (options.connectors.enabled !== false) {\n                            warnLegacy(chart);\n                            this.pathfinder = new PathfinderClass(this);\n                            this.pathfinder.update(true); // First draw, defer render\n                        }\n                    });\n                }\n                if (pushUnique(composedMembers, PointClass)) {\n                    const pointProto = PointClass.prototype;\n                    pointProto.getMarkerVector = pointGetMarkerVector;\n                    pointProto.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;\n                    pointProto.getRadiansToVector = pointGetRadiansToVector;\n                }\n                if (pushUnique(composedMembers, setOptions)) {\n                    // Set default Pathfinder options\n                    setOptions(ConnectorsDefaults);\n                }\n            }\n            ConnectionComposition.compose = compose;\n            /**\n             * Get coordinates of anchor point for pathfinder connection.\n             *\n             * @private\n             * @function Highcharts.Point#getPathfinderAnchorPoint\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Connection options for position on point.\n             *\n             * @return {Highcharts.PositionObject}\n             *         An object with x/y properties for the position. Coordinates are\n             *         in plot values, not relative to point.\n             */\n            function pointGetPathfinderAnchorPoint(markerOptions) {\n                const bb = getPointBB(this);\n                let x, y;\n                switch (markerOptions.align) { // eslint-disable-line default-case\n                    case 'right':\n                        x = 'xMax';\n                        break;\n                    case 'left':\n                        x = 'xMin';\n                }\n                switch (markerOptions.verticalAlign) { // eslint-disable-line default-case\n                    case 'top':\n                        y = 'yMin';\n                        break;\n                    case 'bottom':\n                        y = 'yMax';\n                }\n                return {\n                    x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,\n                    y: y ? bb[y] : (bb.yMin + bb.yMax) / 2\n                };\n            }\n            /**\n             * Utility to get the angle from one point to another.\n             *\n             * @private\n             * @function Highcharts.Point#getRadiansToVector\n             *\n             * @param {Highcharts.PositionObject} v1\n             *        The first vector, as an object with x/y properties.\n             *\n             * @param {Highcharts.PositionObject} v2\n             *        The second vector, as an object with x/y properties.\n             *\n             * @return {number}\n             *         The angle in degrees\n             */\n            function pointGetRadiansToVector(v1, v2) {\n                let box;\n                if (!defined(v2)) {\n                    box = getPointBB(this);\n                    if (box) {\n                        v2 = {\n                            x: (box.xMin + box.xMax) / 2,\n                            y: (box.yMin + box.yMax) / 2\n                        };\n                    }\n                }\n                return Math.atan2(v2.y - v1.y, v1.x - v2.x);\n            }\n            /**\n             * Utility to get the position of the marker, based on the path angle and\n             * the marker's radius.\n             *\n             * @private\n             * @function Highcharts.Point#getMarkerVector\n             *\n             * @param {number} radians\n             *        The angle in radians from the point center to another vector.\n             *\n             * @param {number} markerRadius\n             *        The radius of the marker, to calculate the additional distance to\n             *        the center of the marker.\n             *\n             * @param {Object} anchor\n             *        The anchor point of the path and marker as an object with x/y\n             *        properties.\n             *\n             * @return {Object}\n             *         The marker vector as an object with x/y properties.\n             */\n            function pointGetMarkerVector(radians, markerRadius, anchor) {\n                const twoPI = Math.PI * 2.0, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2.0, rectHalfHeight = rectHeight / 2.0, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {\n                    x: rectHorizontalCenter,\n                    y: rectVerticalCenter\n                };\n                let theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;\n                while (theta < -Math.PI) {\n                    theta += twoPI;\n                }\n                while (theta > Math.PI) {\n                    theta -= twoPI;\n                }\n                tanTheta = Math.tan(theta);\n                if ((theta > -rAtan) && (theta <= rAtan)) {\n                    // Right side\n                    yFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else if (theta > rAtan && theta <= (Math.PI - rAtan)) {\n                    // Top side\n                    yFactor = -1;\n                }\n                else if (theta > (Math.PI - rAtan) || theta <= -(Math.PI - rAtan)) {\n                    // Left side\n                    xFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else {\n                    // Bottom side\n                    xFactor = -1;\n                }\n                // Correct the edgePoint according to the placement of the marker\n                if (leftOrRightRegion) {\n                    edgePoint.x += xFactor * (rectHalfWidth);\n                    edgePoint.y += yFactor * (rectHalfWidth) * tanTheta;\n                }\n                else {\n                    edgePoint.x += xFactor * (rectHeight / (2.0 * tanTheta));\n                    edgePoint.y += yFactor * (rectHalfHeight);\n                }\n                if (anchor.x !== rectHorizontalCenter) {\n                    edgePoint.x = anchor.x;\n                }\n                if (anchor.y !== rectVerticalCenter) {\n                    edgePoint.y = anchor.y;\n                }\n                return {\n                    x: edgePoint.x + (markerRadius * Math.cos(theta)),\n                    y: edgePoint.y - (markerRadius * Math.sin(theta))\n                };\n            }\n        })(ConnectionComposition || (ConnectionComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ConnectionComposition;\n    });\n    _registerModule(_modules, 'Gantt/Pathfinder.js', [_modules['Gantt/Connection.js'], _modules['Gantt/PathfinderAlgorithms.js'], _modules['Gantt/PathfinderComposition.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (Connection, PathfinderAlgorithms, PathfinderComposition, Point, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, defined, pick, splat } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            const shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            const bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Compute smallest distance between two rectangles.\n         * @private\n         */\n        function calculateObstacleDistance(a, b, bbMargin) {\n            // Count the distance even if we are slightly off\n            const margin = pick(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin &&\n                a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin &&\n                a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? (a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax) : Infinity, yDistance = xOverlap ? (a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax) : Infinity;\n            // If the rectangles collide, try recomputing with smaller margin.\n            // If they collide anyway, discard the obstacle.\n            if (xOverlap && yOverlap) {\n                return (margin ?\n                    calculateObstacleDistance(a, b, Math.floor(margin / 2)) :\n                    Infinity);\n            }\n            return min(xDistance, yDistance);\n        }\n        /**\n         * Calculate margin to place around obstacles for the pathfinder in pixels.\n         * Returns a minimum of 1 pixel margin.\n         *\n         * @private\n         * @function\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to calculate margin from.\n         *\n         * @return {number}\n         *         The calculated margin in pixels. At least 1.\n         */\n        function calculateObstacleMargin(obstacles) {\n            const len = obstacles.length, distances = [];\n            let onstacleDistance;\n            // Go over all obstacles and compare them to the others.\n            for (let i = 0; i < len; ++i) {\n                // Compare to all obstacles ahead. We will already have compared this\n                // obstacle to the ones before.\n                for (let j = i + 1; j < len; ++j) {\n                    onstacleDistance =\n                        calculateObstacleDistance(obstacles[i], obstacles[j]);\n                    // TODO: Magic number 80\n                    if (onstacleDistance < 80) { // Ignore large distances\n                        distances.push(onstacleDistance);\n                    }\n                }\n            }\n            // Ensure we always have at least one value, even in very spaceous charts\n            distances.push(80);\n            return max(Math.floor(distances.sort(function (a, b) {\n                return (a - b);\n            })[\n            // Discard first 10% of the relevant distances, and then grab\n            // the smallest one.\n            Math.floor(distances.length / 10)] / 2 - 1 // Divide the distance by 2 and subtract 1.\n            ), 1 // 1 is the minimum margin\n            );\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Pathfinder class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pathfinder\n         *\n         * @param {Highcharts.Chart} chart\n         *        The chart to operate on.\n         */\n        class Pathfinder {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(ChartClass, PointClass) {\n                PathfinderComposition.compose(ChartClass, Pathfinder, PointClass);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(chart) {\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.chartObstacles = void 0;\n                this.chartObstacleMetrics = void 0;\n                this.connections = void 0;\n                this.group = void 0;\n                this.lineObstacles = void 0;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Pathfinder object.\n             *\n             * @function Highcharts.Pathfinder#init\n             *\n             * @param {Highcharts.Chart} chart\n             *        The chart context.\n             */\n            init(chart) {\n                // Initialize pathfinder with chart context\n                this.chart = chart;\n                // Init connection reference list\n                this.connections = [];\n                // Recalculate paths/obstacles on chart redraw\n                addEvent(chart, 'redraw', function () {\n                    this.pathfinder.update();\n                });\n            }\n            /**\n             * Update Pathfinder connections from scratch.\n             *\n             * @function Highcharts.Pathfinder#update\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer rendering of connections until\n             *        series.afterAnimate event has fired. Used on first render.\n             */\n            update(deferRender) {\n                const chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;\n                // Rebuild pathfinder connections from options\n                pathfinder.connections = [];\n                chart.series.forEach(function (series) {\n                    if (series.visible && !series.options.isInternal) {\n                        series.points.forEach(function (point) {\n                            const ganttPointOptions = point.options;\n                            // For Gantt series the connect could be\n                            // defined as a dependency\n                            if (ganttPointOptions && ganttPointOptions.dependency) {\n                                ganttPointOptions.connect = ganttPointOptions\n                                    .dependency;\n                            }\n                            const connects = (point.options?.connect &&\n                                splat(point.options.connect));\n                            let to;\n                            if (point.visible && point.isInside !== false && connects) {\n                                connects.forEach(function (connect) {\n                                    to = chart.get(typeof connect === 'string' ?\n                                        connect : connect.to);\n                                    if (to instanceof Point &&\n                                        to.series.visible &&\n                                        to.visible &&\n                                        to.isInside !== false) {\n                                        // Add new connection\n                                        pathfinder.connections.push(new Connection(point, // From\n                                        to, typeof connect === 'string' ?\n                                            {} :\n                                            connect));\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n                // Clear connections that should not be updated, and move old info over\n                // to new connections.\n                for (let j = 0, k, found, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {\n                    found = false;\n                    const oldCon = oldConnections[j];\n                    for (k = 0; k < lenNew; ++k) {\n                        const newCon = pathfinder.connections[k];\n                        if ((oldCon.options && oldCon.options.type) ===\n                            (newCon.options && newCon.options.type) &&\n                            oldCon.fromPoint === newCon.fromPoint &&\n                            oldCon.toPoint === newCon.toPoint) {\n                            newCon.graphics = oldCon.graphics;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        oldCon.destroy();\n                    }\n                }\n                // Clear obstacles to force recalculation. This must be done on every\n                // redraw in case positions have changed. Recalculation is handled in\n                // Connection.getPath on demand.\n                delete this.chartObstacles;\n                delete this.lineObstacles;\n                // Draw the pending connections\n                pathfinder.renderConnections(deferRender);\n            }\n            /**\n             * Draw the chart's connecting paths.\n             *\n             * @function Highcharts.Pathfinder#renderConnections\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer render until series animation is finished.\n             *        Used on first render.\n             */\n            renderConnections(deferRender) {\n                if (deferRender) {\n                    // Render after series are done animating\n                    this.chart.series.forEach(function (series) {\n                        const render = function () {\n                            // Find pathfinder connections belonging to this series\n                            // that haven't rendered, and render them now.\n                            const pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];\n                            conns.forEach(function (connection) {\n                                if (connection.fromPoint &&\n                                    connection.fromPoint.series === series) {\n                                    connection.render();\n                                }\n                            });\n                            if (series.pathfinderRemoveRenderEvent) {\n                                series.pathfinderRemoveRenderEvent();\n                                delete series.pathfinderRemoveRenderEvent;\n                            }\n                        };\n                        if (series.options.animation === false) {\n                            render();\n                        }\n                        else {\n                            series.pathfinderRemoveRenderEvent = addEvent(series, 'afterAnimate', render);\n                        }\n                    });\n                }\n                else {\n                    // Go through connections and render them\n                    this.connections.forEach(function (connection) {\n                        connection.render();\n                    });\n                }\n            }\n            /**\n             * Get obstacles for the points in the chart. Does not include connecting\n             * lines from Pathfinder. Applies algorithmMargin to the obstacles.\n             *\n             * @function Highcharts.Pathfinder#getChartObstacles\n             *\n             * @param {Object} options\n             *        Options for the calculation. Currenlty only\n             *        options.algorithmMargin.\n             *\n             * @return {Array<object>}\n             *         An array of calculated obstacles. Each obstacle is defined as an\n             *         object with xMin, xMax, yMin and yMax properties.\n             */\n            getChartObstacles(options) {\n                const series = this.chart.series, margin = pick(options.algorithmMargin, 0);\n                let obstacles = [], calculatedMargin;\n                for (let i = 0, sLen = series.length; i < sLen; ++i) {\n                    if (series[i].visible && !series[i].options.isInternal) {\n                        for (let j = 0, pLen = series[i].points.length, bb, point; j < pLen; ++j) {\n                            point = series[i].points[j];\n                            if (point.visible) {\n                                bb = getPointBB(point);\n                                if (bb) {\n                                    obstacles.push({\n                                        xMin: bb.xMin - margin,\n                                        xMax: bb.xMax + margin,\n                                        yMin: bb.yMin - margin,\n                                        yMax: bb.yMax + margin\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Sort obstacles by xMin for optimization\n                obstacles = obstacles.sort(function (a, b) {\n                    return a.xMin - b.xMin;\n                });\n                // Add auto-calculated margin if the option is not defined\n                if (!defined(options.algorithmMargin)) {\n                    calculatedMargin =\n                        options.algorithmMargin =\n                            calculateObstacleMargin(obstacles);\n                    obstacles.forEach(function (obstacle) {\n                        obstacle.xMin -= calculatedMargin;\n                        obstacle.xMax += calculatedMargin;\n                        obstacle.yMin -= calculatedMargin;\n                        obstacle.yMax += calculatedMargin;\n                    });\n                }\n                return obstacles;\n            }\n            /**\n             * Utility function to get metrics for obstacles:\n             * - Widest obstacle width\n             * - Tallest obstacle height\n             *\n             * @function Highcharts.Pathfinder#getObstacleMetrics\n             *\n             * @param {Array<object>} obstacles\n             *        An array of obstacles to inspect.\n             *\n             * @return {Object}\n             *         The calculated metrics, as an object with maxHeight and maxWidth\n             *         properties.\n             */\n            getObstacleMetrics(obstacles) {\n                let maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;\n                while (i--) {\n                    width = obstacles[i].xMax - obstacles[i].xMin;\n                    height = obstacles[i].yMax - obstacles[i].yMin;\n                    if (maxWidth < width) {\n                        maxWidth = width;\n                    }\n                    if (maxHeight < height) {\n                        maxHeight = height;\n                    }\n                }\n                return {\n                    maxHeight: maxHeight,\n                    maxWidth: maxWidth\n                };\n            }\n            /**\n             * Utility to get which direction to start the pathfinding algorithm\n             * (X vs Y), calculated from a set of marker options.\n             *\n             * @function Highcharts.Pathfinder#getAlgorithmStartDirection\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Marker options to calculate from.\n             *\n             * @return {boolean}\n             *         Returns true for X, false for Y, and undefined for autocalculate.\n             */\n            getAlgorithmStartDirection(markerOptions) {\n                const xCenter = markerOptions.align !== 'left' &&\n                    markerOptions.align !== 'right', yCenter = markerOptions.verticalAlign !== 'top' &&\n                    markerOptions.verticalAlign !== 'bottom';\n                return xCenter ?\n                    (yCenter ? void 0 : false) : // When x is centered\n                    (yCenter ? true : void 0); // When x is off-center\n            }\n        }\n        /**\n         * @name Highcharts.Pathfinder#algorithms\n         * @type {Highcharts.Dictionary<Function>}\n         */\n        Pathfinder.prototype.algorithms = PathfinderAlgorithms;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Pathfinder;\n    });\n    _registerModule(_modules, 'Extensions/ArrowSymbols.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2017 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an arrow symbol. Like a triangle, except not filled.\n         * ```\n         *                   o\n         *             o\n         *       o\n         * o\n         *       o\n         *             o\n         *                   o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrow(x, y, w, h) {\n            return [\n                ['M', x, y + h / 2],\n                ['L', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h]\n            ];\n        }\n        /**\n         * Creates a half-width arrow symbol. Like a triangle, except not filled.\n         * ```\n         *       o\n         *    o\n         * o\n         *    o\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrowHalf(x, y, w, h) {\n            return arrow(x, y, w / 2, h);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            if (U.pushUnique(composedMembers, SVGRendererClass)) {\n                const symbols = SVGRendererClass.prototype.symbols;\n                symbols.arrow = arrow;\n                symbols['arrow-filled'] = triangleLeft;\n                symbols['arrow-filled-half'] = triangleLeftHalf;\n                symbols['arrow-half'] = arrowHalf;\n                symbols['triangle-left'] = triangleLeft;\n                symbols['triangle-left-half'] = triangleLeftHalf;\n            }\n        }\n        /**\n         * Creates a left-oriented triangle.\n         * ```\n         *             o\n         *       ooooooo\n         * ooooooooooooo\n         *       ooooooo\n         *             o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeft(x, y, w, h) {\n            return [\n                ['M', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h],\n                ['Z']\n            ];\n        }\n        /**\n         * Creates a half-width, left-oriented triangle.\n         * ```\n         *       o\n         *    oooo\n         * ooooooo\n         *    oooo\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeftHalf(x, y, w, h) {\n            return triangleLeft(x, y, w / 2, h);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const ArrowSymbols = {\n            compose\n        };\n\n        return ArrowSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/pathfinder.src.js', [_modules['Core/Globals.js'], _modules['Gantt/Pathfinder.js'], _modules['Extensions/ArrowSymbols.js']], function (Highcharts, Pathfinder, ArrowSymbols) {\n\n        const G = Highcharts;\n        G.Pathfinder = Pathfinder;\n        ArrowSymbols.compose(G.SVGRenderer);\n        Pathfinder.compose(G.Chart, G.Point);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","H","U","defined","error","merge","objectEach","deg2rad","max","Math","min","constructor","from","to","options","chart","fromPoint","graphics","pathfinder","toPoint","init","series","renderPath","attribs","animation","styledMode","animate","forExport","anim","pathGraphic","connection","group","renderer","g","addClass","attr","zIndex","add","seriesGroup","translate","plotLeft","plotTop","opacity","d","addMarker","type","markerVector","radians","rotation","box","width","height","pathVector","segment","point","anchor","getPathfinderAnchorPoint","enabled","length","x","y","getRadiansToVector","getMarkerVector","radius","rotationOriginX","rotationOriginY","symbol","colorIndex","fill","color","stroke","lineColor","lineWidth","getPath","algorithm","algorithms","chartObstacles","obstacles","requiresObstacles","getChartObstacles","connectors","algorithmMargin","chartObstacleMetrics","getObstacleMetrics","startMarker","endMarker","lineObstacles","obstacleMetrics","hardBounds","xMin","xMax","plotWidth","yMin","yMax","plotHeight","obstacleOptions","margin","startDirectionX","getAlgorithmStartDirection","render","dashStyle","dashstyle","marker","ceil","pathResult","concat","destroy","val","applyRadius","r","i","push","prevSeg","nextSeg","x1","y1","x2","y2","directionX","directionY","abs","getLinkPath","pathParams","inverted","parentVisible","straight","curved","offset","PathUtilities","pick","findLastObstacleBefore","startIx","left","right","cursor","cmp","findObstacleFromPoint","obstacle","pathFromSegments","segments","start","end","limitObstacleToBounds","bounds","simpleConnect","startObstacleIx","endObstacleIx","endSegment","dir","startObstacle","waypoint","useMax","endPoint","copyFromPoint","fromKey","toKey","getMeOut","direction","prevWaypoint","waypoint2","fastAvoid","dirIsX","endSegments","metrics","softMinX","maxWidth","softMaxX","softMinY","maxHeight","softMaxY","extractedEndPoint","forceObstacleBreak","pivotPoint","directionIsX","firstPoint","lastPoint","highestPoint","lowestPoint","searchDirection","getDodgeDirection","softBounds","soft","hard","toPointMax","toPointMin","maxOutOfSoftBounds","minOutOfSoftBounds","maxOutOfHardBounds","minOutOfHardBounds","minDistance","maxDistance","minPivot","maxPivot","slice","extractFromObstacle","goalPoint","clearPathTo","pivot","waypointUseMax","envelopingObstacle","secondEnvelopingObstacle","envelopWaypoint","obstacleMargin","reverse","align","verticalAlign","inside","ConnectorsDefaults","D","ConnectionComposition","setOptions","pushUnique","getPointBB","shapeArgs","bb","graphic","getBBox","plotX","plotY","composedMembers","pointGetPathfinderAnchorPoint","markerOptions","pointGetRadiansToVector","v1","v2","atan2","pointGetMarkerVector","markerRadius","twoPI","PI","rectWidth","rectHeight","rAtan","rectHalfWidth","rectHalfHeight","rectHorizontalCenter","rectVerticalCenter","edgePoint","theta","tanTheta","leftOrRightRegion","xFactor","yFactor","tan","cos","sin","compose","ChartClass","PathfinderClass","PointClass","prototype","callbacks","reduce","acc","update","pointProto","Connection","PathfinderAlgorithms","PathfinderComposition","Point","addEvent","splat","Pathfinder","connections","deferRender","oldConnections","forEach","visible","isInternal","points","ganttPointOptions","dependency","connect","connects","isInside","get","j","k","found","lenOld","lenNew","oldCon","newCon","renderConnections","conns","pathfinderRemoveRenderEvent","calculatedMargin","sLen","pLen","sort","a","b","calculateObstacleMargin","onstacleDistance","len","distances","calculateObstacleDistance","bbMargin","yOverlap","xOverlap","xDistance","Infinity","yDistance","floor","xCenter","yCenter","arrow","w","h","arrowHalf","triangleLeft","triangleLeftHalf","SVGRendererClass","symbols","ArrowSymbols","G","SVGRenderer","Chart"],"mappings":"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"}