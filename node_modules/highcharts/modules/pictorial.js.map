{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Pictorial graph series type for Highcharts\n *\n * (c) 2010-2022 Torstein Honsi, Magdalena Gut\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pictorial', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/PatternFill.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Globals.js'], _modules['Core/Defaults.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/Series.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Utilities.js']], function (A, Chart, H, D, Point, Series, SVGRenderer, U) {\n        /* *\n         *\n         *  Module for using patterns or images as point fills.\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *  Author: Torstein Hønsi, Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { getOptions } = D;\n        const { addEvent, defined, erase, merge, pick, removeEvent, wrap } = U;\n        // Add the predefined patterns\n        const patterns = H.patterns = (() => {\n            const patterns = [], colors = getOptions().colors;\n            // Start with subtle patterns\n            [\n                'M 0 0 L 5 5 M 4.5 -0.5 L 5.5 0.5 M -0.5 4.5 L 0.5 5.5',\n                'M 0 5 L 5 0 M -0.5 0.5 L 0.5 -0.5 M 4.5 5.5 L 5.5 4.5',\n                'M 2 0 L 2 5 M 4 0 L 4 5',\n                'M 0 2 L 5 2 M 0 4 L 5 4',\n                'M 0 1.5 L 2.5 1.5 L 2.5 0 M 2.5 5 L 2.5 3.5 L 5 3.5'\n            ].forEach((pattern, i) => {\n                patterns.push({\n                    path: pattern,\n                    color: colors[i],\n                    width: 5,\n                    height: 5,\n                    patternTransform: 'scale(1.4 1.4)'\n                });\n            });\n            // Then add the more drastic ones\n            [\n                'M 0 0 L 5 10 L 10 0',\n                'M 3 3 L 8 3 L 8 8 L 3 8 Z',\n                'M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0',\n                'M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11',\n                'M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9'\n            ].forEach((pattern, i) => {\n                patterns.push({\n                    path: pattern,\n                    color: colors[i + 5],\n                    width: 10,\n                    height: 10\n                });\n            });\n            return patterns;\n        })();\n        /**\n         * Utility function to compute a hash value from an object. Modified Java\n         * String.hashCode implementation in JS. Use the preSeed parameter to add an\n         * additional seeding step.\n         *\n         * @private\n         * @function hashFromObject\n         *\n         * @param {Object} obj\n         *        The javascript object to compute the hash from.\n         *\n         * @param {boolean} [preSeed=false]\n         *        Add an optional preSeed stage.\n         *\n         * @return {string}\n         *         The computed hash.\n         */\n        function hashFromObject(obj, preSeed) {\n            const str = JSON.stringify(obj), strLen = str.length || 0;\n            let hash = 0, i = 0, char, seedStep;\n            if (preSeed) {\n                seedStep = Math.max(Math.floor(strLen / 500), 1);\n                for (let a = 0; a < strLen; a += seedStep) {\n                    hash += str.charCodeAt(a);\n                }\n                hash = hash & hash;\n            }\n            for (; i < strLen; ++i) {\n                char = str.charCodeAt(i);\n                hash = ((hash << 5) - hash) + char;\n                hash = hash & hash;\n            }\n            return hash.toString(16).replace('-', '1');\n        }\n        /**\n         * Set dimensions on pattern from point. This function will set internal\n         * pattern._width/_height properties if width and height are not both already\n         * set. We only do this on image patterns. The _width/_height properties are set\n         * to the size of the bounding box of the point, optionally taking aspect ratio\n         * into account. If only one of width or height are supplied as options, the\n         * undefined option is calculated as above.\n         *\n         * @private\n         * @function Highcharts.Point#calculatePatternDimensions\n         *\n         * @param {Highcharts.PatternOptionsObject} pattern\n         *        The pattern to set dimensions on.\n         *\n         * @return {void}\n         *\n         * @requires modules/pattern-fill\n         */\n        Point.prototype.calculatePatternDimensions = function (pattern) {\n            if (pattern.width && pattern.height) {\n                return;\n            }\n            const bBox = this.graphic && (this.graphic.getBBox &&\n                this.graphic.getBBox(true) ||\n                this.graphic.element &&\n                    this.graphic.element.getBBox()) || {}, shapeArgs = this.shapeArgs;\n            // Prefer using shapeArgs, as it is animation agnostic\n            if (shapeArgs) {\n                bBox.width = shapeArgs.width || bBox.width;\n                bBox.height = shapeArgs.height || bBox.height;\n                bBox.x = shapeArgs.x || bBox.x;\n                bBox.y = shapeArgs.y || bBox.y;\n            }\n            // For images we stretch to bounding box\n            if (pattern.image) {\n                // If we do not have a bounding box at this point, simply add a defer\n                // key and pick this up in the fillSetter handler, where the bounding\n                // box should exist.\n                if (!bBox.width || !bBox.height) {\n                    pattern._width = 'defer';\n                    pattern._height = 'defer';\n                    // Mark the pattern to be flipped later if upside down (#16810)\n                    const scaleY = this.series.chart.mapView &&\n                        this.series.chart.mapView.getSVGTransform().scaleY;\n                    if (defined(scaleY) && scaleY < 0) {\n                        pattern._inverted = true;\n                    }\n                    return;\n                }\n                // Handle aspect ratio filling\n                if (pattern.aspectRatio) {\n                    bBox.aspectRatio = bBox.width / bBox.height;\n                    if (pattern.aspectRatio > bBox.aspectRatio) {\n                        // Height of bBox will determine width\n                        bBox.aspectWidth = bBox.height * pattern.aspectRatio;\n                    }\n                    else {\n                        // Width of bBox will determine height\n                        bBox.aspectHeight = bBox.width / pattern.aspectRatio;\n                    }\n                }\n                // We set the width/height on internal properties to differentiate\n                // between the options set by a user and by this function.\n                pattern._width = pattern.width ||\n                    Math.ceil(bBox.aspectWidth || bBox.width);\n                pattern._height = pattern.height ||\n                    Math.ceil(bBox.aspectHeight || bBox.height);\n            }\n            // Set x/y accordingly, centering if using aspect ratio, otherwise adjusting\n            // so bounding box corner is 0,0 of pattern.\n            if (!pattern.width) {\n                pattern._x = pattern.x || 0;\n                pattern._x += bBox.x - Math.round(bBox.aspectWidth ?\n                    Math.abs(bBox.aspectWidth - bBox.width) / 2 :\n                    0);\n            }\n            if (!pattern.height) {\n                pattern._y = pattern.y || 0;\n                pattern._y += bBox.y - Math.round(bBox.aspectHeight ?\n                    Math.abs(bBox.aspectHeight - bBox.height) / 2 :\n                    0);\n            }\n        };\n        /* eslint-disable no-invalid-this */\n        /**\n         * Add a pattern to the renderer.\n         *\n         * @private\n         * @function Highcharts.SVGRenderer#addPattern\n         *\n         * @param {Highcharts.PatternObject} options\n         * The pattern options.\n         *\n         * @param {boolean|Partial<Highcharts.AnimationOptionsObject>} [animation]\n         * The animation options.\n         *\n         * @return {Highcharts.SVGElement|undefined}\n         * The added pattern. Undefined if the pattern already exists.\n         *\n         * @requires modules/pattern-fill\n         */\n        SVGRenderer.prototype.addPattern = function (options, animation) {\n            let pattern, animate = pick(animation, true), animationOptions = animObject(animate), path, defaultSize = 32, width = options.width || options._width || defaultSize, height = (options.height || options._height || defaultSize), color = options.color || '#343434', id = options.id, ren = this, rect = function (fill) {\n                ren.rect(0, 0, width, height)\n                    .attr({ fill })\n                    .add(pattern);\n            }, attribs;\n            if (!id) {\n                this.idCounter = this.idCounter || 0;\n                id = ('highcharts-pattern-' +\n                    this.idCounter +\n                    '-' +\n                    (this.chartIndex || 0));\n                ++this.idCounter;\n            }\n            if (this.forExport) {\n                id += '-export';\n            }\n            // Do nothing if ID already exists\n            this.defIds = this.defIds || [];\n            if (this.defIds.indexOf(id) > -1) {\n                return;\n            }\n            // Store ID in list to avoid duplicates\n            this.defIds.push(id);\n            // Calculate pattern element attributes\n            const attrs = {\n                id: id,\n                patternUnits: 'userSpaceOnUse',\n                patternContentUnits: options.patternContentUnits || 'userSpaceOnUse',\n                width: width,\n                height: height,\n                x: options._x || options.x || 0,\n                y: options._y || options.y || 0\n            };\n            if (options._inverted) {\n                attrs.patternTransform = 'scale(1, -1)'; // (#16810)\n                if (options.patternTransform) {\n                    options.patternTransform += ' scale(1, -1)';\n                }\n            }\n            if (options.patternTransform) {\n                attrs.patternTransform = options.patternTransform;\n            }\n            pattern = this.createElement('pattern').attr(attrs).add(this.defs);\n            // Set id on the SVGRenderer object\n            pattern.id = id;\n            // Use an SVG path for the pattern\n            if (options.path) {\n                path = U.isObject(options.path) ?\n                    options.path :\n                    { d: options.path };\n                // The background\n                if (options.backgroundColor) {\n                    rect(options.backgroundColor);\n                }\n                // The pattern\n                attribs = {\n                    'd': path.d\n                };\n                if (!this.styledMode) {\n                    attribs.stroke = path.stroke || color;\n                    attribs['stroke-width'] = pick(path.strokeWidth, 2);\n                    attribs.fill = path.fill || 'none';\n                }\n                if (path.transform) {\n                    attribs.transform = path.transform;\n                }\n                this.createElement('path').attr(attribs).add(pattern);\n                pattern.color = color;\n                // Image pattern\n            }\n            else if (options.image) {\n                if (animate) {\n                    this.image(options.image, 0, 0, width, height, function () {\n                        // Onload\n                        this.animate({\n                            opacity: pick(options.opacity, 1)\n                        }, animationOptions);\n                        removeEvent(this.element, 'load');\n                    }).attr({ opacity: 0 }).add(pattern);\n                }\n                else {\n                    this.image(options.image, 0, 0, width, height).add(pattern);\n                }\n            }\n            // For non-animated patterns, set opacity now\n            if (!(options.image && animate) && typeof options.opacity !== 'undefined') {\n                [].forEach.call(pattern.element.childNodes, function (child) {\n                    child.setAttribute('opacity', options.opacity);\n                });\n            }\n            // Store for future reference\n            this.patternElements = this.patternElements || {};\n            this.patternElements[id] = pattern;\n            return pattern;\n        };\n        // Make sure we have a series color\n        wrap(Series.prototype, 'getColor', function (proceed) {\n            const oldColor = this.options.color;\n            // Temporarely remove color options to get defaults\n            if (oldColor &&\n                oldColor.pattern &&\n                !oldColor.pattern.color) {\n                delete this.options.color;\n                // Get default\n                proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n                // Replace with old, but add default color\n                oldColor.pattern.color =\n                    this.color;\n                this.color = this.options.color = oldColor;\n            }\n            else {\n                // We have a color, no need to do anything special\n                proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n            }\n        });\n        // Calculate pattern dimensions on points that have their own pattern.\n        addEvent(Series, 'render', function () {\n            const isResizing = this.chart.isResizing;\n            if (this.isDirtyData || isResizing || !this.chart.hasRendered) {\n                (this.points || []).forEach(function (point) {\n                    const colorOptions = point.options && point.options.color;\n                    if (colorOptions &&\n                        colorOptions.pattern) {\n                        // For most points we want to recalculate the dimensions on\n                        // render, where we have the shape args and bbox. But if we\n                        // are resizing and don't have the shape args, defer it, since\n                        // the bounding box is still not resized.\n                        if (isResizing &&\n                            !(point.shapeArgs &&\n                                point.shapeArgs.width &&\n                                point.shapeArgs.height)) {\n                            colorOptions\n                                .pattern._width = 'defer';\n                            colorOptions\n                                .pattern._height = 'defer';\n                        }\n                        else {\n                            point.calculatePatternDimensions(colorOptions.pattern);\n                        }\n                    }\n                });\n            }\n        });\n        // Merge series color options to points\n        addEvent(Point, 'afterInit', function () {\n            const point = this, colorOptions = point.options.color;\n            // Only do this if we have defined a specific color on this point. Otherwise\n            // we will end up trying to re-add the series color for each point.\n            if (colorOptions && colorOptions.pattern) {\n                // Move path definition to object, allows for merge with series path\n                // definition\n                if (typeof colorOptions.pattern.path === 'string') {\n                    colorOptions.pattern.path = {\n                        d: colorOptions.pattern.path\n                    };\n                }\n                // Merge with series options\n                point.color = point.options.color = merge(point.series.options.color, colorOptions);\n            }\n        });\n        // Add functionality to SVG renderer to handle patterns as complex colors\n        addEvent(SVGRenderer, 'complexColor', function (args) {\n            const color = args.args[0], prop = args.args[1], element = args.args[2], chartIndex = (this.chartIndex || 0);\n            let pattern = color.pattern, value = '#343434';\n            // Handle patternIndex\n            if (typeof color.patternIndex !== 'undefined' && patterns) {\n                pattern = patterns[color.patternIndex];\n            }\n            // Skip and call default if there is no pattern\n            if (!pattern) {\n                return true;\n            }\n            // We have a pattern.\n            if (pattern.image ||\n                typeof pattern.path === 'string' ||\n                pattern.path && pattern.path.d) {\n                // Real pattern. Add it and set the color value to be a reference.\n                // Force Hash-based IDs for legend items, as they are drawn before\n                // point render, meaning they are drawn before autocalculated image\n                // width/heights. We don't want them to highjack the width/height for\n                // this ID if it is defined by users.\n                let forceHashId = element.parentNode &&\n                    element.parentNode.getAttribute('class');\n                forceHashId = forceHashId &&\n                    forceHashId.indexOf('highcharts-legend') > -1;\n                // If we don't have a width/height yet, handle it. Try faking a point\n                // and running the algorithm again.\n                if (pattern._width === 'defer' || pattern._height === 'defer') {\n                    Point.prototype.calculatePatternDimensions.call({ graphic: { element: element } }, pattern);\n                }\n                // If we don't have an explicit ID, compute a hash from the\n                // definition and use that as the ID. This ensures that points with\n                // the same pattern definition reuse existing pattern elements by\n                // default. We combine two hashes, the second with an additional\n                // preSeed algorithm, to minimize collision probability.\n                if (forceHashId || !pattern.id) {\n                    // Make a copy so we don't accidentally edit options when setting ID\n                    pattern = merge({}, pattern);\n                    pattern.id = 'highcharts-pattern-' + chartIndex + '-' +\n                        hashFromObject(pattern) + hashFromObject(pattern, true);\n                }\n                // Add it. This function does nothing if an element with this ID\n                // already exists.\n                this.addPattern(pattern, !this.forExport && pick(pattern.animation, this.globalAnimation, { duration: 100 }));\n                value = `url(${this.url}#${pattern.id + (this.forExport ? '-export' : '')})`;\n            }\n            else {\n                // Not a full pattern definition, just add color\n                value = pattern.color || value;\n            }\n            // Set the fill/stroke prop on the element\n            element.setAttribute(prop, value);\n            // Allow the color to be concatenated into tooltips formatters etc.\n            color.toString = function () {\n                return value;\n            };\n            // Skip default handler\n            return false;\n        });\n        // When animation is used, we have to recalculate pattern dimensions after\n        // resize, as the bounding boxes are not available until then.\n        addEvent(Chart, 'endResize', function () {\n            if ((this.renderer && this.renderer.defIds || []).filter(function (id) {\n                return (id &&\n                    id.indexOf &&\n                    id.indexOf('highcharts-pattern-') === 0);\n            }).length) {\n                // We have non-default patterns to fix. Find them by looping through\n                // all points.\n                this.series.forEach(function (series) {\n                    if (series.visible) {\n                        series.points.forEach(function (point) {\n                            const colorOptions = point.options && point.options.color;\n                            if (colorOptions &&\n                                colorOptions.pattern) {\n                                colorOptions.pattern\n                                    ._width = 'defer';\n                                colorOptions.pattern\n                                    ._height = 'defer';\n                            }\n                        });\n                    }\n                });\n                // Redraw without animation\n                this.redraw(false);\n            }\n        });\n        // Add a garbage collector to delete old patterns with autogenerated hashes that\n        // are no longer being referenced.\n        addEvent(Chart, 'redraw', function () {\n            const usedIds = {}, renderer = this.renderer, \n            // Get the autocomputed patterns - these are the ones we might delete\n            patterns = (renderer.defIds || []).filter(function (pattern) {\n                return (pattern.indexOf &&\n                    pattern.indexOf('highcharts-pattern-') === 0);\n            });\n            if (patterns.length) {\n                // Look through the DOM for usage of the patterns. This can be points,\n                // series, tooltips etc.\n                [].forEach.call(this.renderTo.querySelectorAll('[color^=\"url(\"], [fill^=\"url(\"], [stroke^=\"url(\"]'), function (node) {\n                    const id = node.getAttribute('fill') ||\n                        node.getAttribute('color') ||\n                        node.getAttribute('stroke');\n                    if (id) {\n                        const sanitizedId = id\n                            .replace(renderer.url, '')\n                            .replace('url(#', '')\n                            .replace(')', '');\n                        usedIds[sanitizedId] = true;\n                    }\n                });\n                // Loop through the patterns that exist and see if they are used\n                patterns.forEach(function (id) {\n                    if (!usedIds[id]) {\n                        // Remove id from used id list\n                        erase(renderer.defIds, id);\n                        // Remove pattern element\n                        if (renderer.patternElements[id]) {\n                            renderer.patternElements[id].destroy();\n                            delete renderer.patternElements[id];\n                        }\n                    }\n                });\n            }\n        });\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Pattern options\n         *\n         * @interface Highcharts.PatternOptionsObject\n         */ /**\n        * Background color for the pattern if a `path` is set (not images).\n        * @name Highcharts.PatternOptionsObject#backgroundColor\n        * @type {Highcharts.ColorString|undefined}\n        */ /**\n        * URL to an image to use as the pattern.\n        * @name Highcharts.PatternOptionsObject#image\n        * @type {string|undefined}\n        */ /**\n        * Width of the pattern. For images this is automatically set to the width of\n        * the element bounding box if not supplied. For non-image patterns the default\n        * is 32px. Note that automatic resizing of image patterns to fill a bounding\n        * box dynamically is only supported for patterns with an automatically\n        * calculated ID.\n        * @name Highcharts.PatternOptionsObject#width\n        * @type {number|undefined}\n        */ /**\n        * Analogous to pattern.width.\n        * @name Highcharts.PatternOptionsObject#height\n        * @type {number|undefined}\n        */ /**\n        * For automatically calculated width and height on images, it is possible to\n        * set an aspect ratio. The image will be zoomed to fill the bounding box,\n        * maintaining the aspect ratio defined.\n        * @name Highcharts.PatternOptionsObject#aspectRatio\n        * @type {number|undefined}\n        */ /**\n        * Horizontal offset of the pattern. Defaults to 0.\n        * @name Highcharts.PatternOptionsObject#x\n        * @type {number|undefined}\n        */ /**\n        * Vertical offset of the pattern. Defaults to 0.\n        * @name Highcharts.PatternOptionsObject#y\n        * @type {number|undefined}\n        */ /**\n        * Either an SVG path as string, or an object. As an object, supply the path\n        * string in the `path.d` property. Other supported properties are standard SVG\n        * attributes like `path.stroke` and `path.fill`. If a path is supplied for the\n        * pattern, the `image` property is ignored.\n        * @name Highcharts.PatternOptionsObject#path\n        * @type {string|Highcharts.SVGAttributes|undefined}\n        */ /**\n        * SVG `patternTransform` to apply to the entire pattern.\n        * @name Highcharts.PatternOptionsObject#patternTransform\n        * @type {string|undefined}\n        * @see [patternTransform demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/series/pattern-fill-transform)\n        */ /**\n        * Pattern color, used as default path stroke.\n        * @name Highcharts.PatternOptionsObject#color\n        * @type {Highcharts.ColorString|undefined}\n        */ /**\n        * Opacity of the pattern as a float value from 0 to 1.\n        * @name Highcharts.PatternOptionsObject#opacity\n        * @type {number|undefined}\n        */ /**\n        * ID to assign to the pattern. This is automatically computed if not added, and\n        * identical patterns are reused. To refer to an existing pattern for a\n        * Highcharts color, use `color: \"url(#pattern-id)\"`.\n        * @name Highcharts.PatternOptionsObject#id\n        * @type {string|undefined}\n        */\n        /**\n         * Holds a pattern definition.\n         *\n         * @sample highcharts/series/pattern-fill-area/\n         *         Define a custom path pattern\n         * @sample highcharts/series/pattern-fill-pie/\n         *         Default patterns and a custom image pattern\n         * @sample maps/demo/pattern-fill-map/\n         *         Custom images on map\n         *\n         * @example\n         * // Pattern used as a color option\n         * color: {\n         *     pattern: {\n         *            path: {\n         *                 d: 'M 3 3 L 8 3 L 8 8 Z',\n         *                fill: '#102045'\n         *            },\n         *            width: 12,\n         *            height: 12,\n         *            color: '#907000',\n         *            opacity: 0.5\n         *     }\n         * }\n         *\n         * @interface Highcharts.PatternObject\n         */ /**\n        * Pattern options\n        * @name Highcharts.PatternObject#pattern\n        * @type {Highcharts.PatternOptionsObject}\n        */ /**\n        * Animation options for the image pattern loading.\n        * @name Highcharts.PatternObject#animation\n        * @type {boolean|Partial<Highcharts.AnimationOptionsObject>|undefined}\n        */ /**\n        * Optionally an index referencing which pattern to use. Highcharts adds\n        * 10 default patterns to the `Highcharts.patterns` array. Additional\n        * pattern definitions can be pushed to this array if desired. This option\n        * is an index into this array.\n        * @name Highcharts.PatternObject#patternIndex\n        * @type {number|undefined}\n        */\n        ''; // keeps doclets above in transpiled file\n\n    });\n    _registerModule(_modules, 'Series/Pictorial/PictorialUtilities.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2010-2022 Torstein Honsi, Magdalena Gut\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { defined } = U;\n        function rescalePatternFill(element, stackHeight, width, height, borderWidth = 1) {\n            const fill = element && element.attr('fill'), match = fill && fill.match(/url\\(([^)]+)\\)/);\n            if (match) {\n                const patternPath = document.querySelector(`${match[1]} path`);\n                if (patternPath) {\n                    let bBox = patternPath.getBBox();\n                    // Firefox (v108/Mac) is unable to detect the bounding box within\n                    // defs. Without this block, the pictorial is not rendered.\n                    if (bBox.width === 0) {\n                        const parent = patternPath.parentElement;\n                        // Temporarily append it to the root\n                        element.renderer.box.appendChild(patternPath);\n                        bBox = patternPath.getBBox();\n                        parent.appendChild(patternPath);\n                    }\n                    let scaleX = 1 / (bBox.width + borderWidth);\n                    const scaleY = stackHeight / height / bBox.height, aspectRatio = bBox.width / bBox.height, pointAspectRatio = width / stackHeight, x = -bBox.width / 2;\n                    if (aspectRatio < pointAspectRatio) {\n                        scaleX = scaleX * aspectRatio / pointAspectRatio;\n                    }\n                    patternPath.setAttribute('stroke-width', borderWidth / (width * scaleX));\n                    patternPath.setAttribute('transform', 'translate(0.5, 0)' +\n                        `scale(${scaleX} ${scaleY}) ` +\n                        `translate(${x + borderWidth * scaleX / 2}, ${-bBox.y})`);\n                }\n            }\n        }\n        function getStackMetrics(yAxis, shape) {\n            let height = yAxis.len, y = 0;\n            if (shape && defined(shape.max)) {\n                y = yAxis.toPixels(shape.max, true);\n                height = yAxis.len - y;\n            }\n            return {\n                height,\n                y\n            };\n        }\n        function invertShadowGroup(shadowGroup, yAxis) {\n            let inverted = yAxis.chart.inverted;\n            if (inverted) {\n                shadowGroup.attr({\n                    rotation: inverted ? 90 : 0,\n                    scaleX: inverted ? -1 : 1\n                });\n            }\n        }\n\n        return { rescalePatternFill, invertShadowGroup, getStackMetrics };\n    });\n    _registerModule(_modules, 'Series/Pictorial/PictorialPoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Series/Pictorial/PictorialUtilities.js']], function (SeriesRegistry, PictorialUtilities) {\n        /* *\n         *\n         *  (c) 2010-2022 Torstein Honsi, Magdalena Gut\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const ColumnPoint = SeriesRegistry.seriesTypes.column.prototype.pointClass;\n        const { rescalePatternFill, getStackMetrics } = PictorialUtilities;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class PictorialPoint extends ColumnPoint {\n            constructor() {\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                super(...arguments);\n                this.options = void 0;\n                this.series = void 0;\n                this.pathDef = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            setState() {\n                const point = this;\n                super.setState.apply(point, arguments);\n                const series = point.series, paths = series.options.paths;\n                if (point.graphic && point.shapeArgs && paths) {\n                    const shape = paths[point.index %\n                        paths.length];\n                    rescalePatternFill(point.graphic, getStackMetrics(series.yAxis, shape).height, point.shapeArgs.width || 0, point.shapeArgs.height || Infinity, point.series.options.borderWidth || 0);\n                }\n            }\n        }\n        /* *\n         *\n         *  Export Default\n         *\n         * */\n\n        return PictorialPoint;\n    });\n    _registerModule(_modules, 'Series/Pictorial/PictorialSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Chart/Chart.js'], _modules['Series/Pictorial/PictorialPoint.js'], _modules['Series/Pictorial/PictorialUtilities.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (A, Chart, PictorialPoint, PictorialUtilities, SeriesRegistry, StackItem, U) {\n        /* *\n         *\n         *  (c) 2010-2022 Torstein Honsi, Magdalena Gut\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        const ColumnSeries = SeriesRegistry.seriesTypes.column;\n        const { animObject } = A;\n        const { getStackMetrics, invertShadowGroup, rescalePatternFill } = PictorialUtilities;\n        const { addEvent, defined, merge, objectEach, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The pictorial series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.pictorial\n         *\n         * @augments Highcharts.Series\n         */\n        class PictorialSeries extends ColumnSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.paths = void 0;\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Animate in the series. Called internally twice. First with the `init`\n             * parameter set to true, which sets up the initial state of the\n             * animation. Then when ready, it is called with the `init` parameter\n             * undefined, in order to perform the actual animation.\n             *\n             * @function Highcharts.Series#animate\n             *\n             * @param {boolean} [init]\n             * Initialize the animation.\n             */\n            animate(init) {\n                const { chart, group } = this, animation = animObject(this.options.animation), \n                // The key for temporary animation clips\n                animationClipKey = [\n                    this.getSharedClipKey(),\n                    animation.duration,\n                    animation.easing,\n                    animation.defer\n                ].join(',');\n                let animationClipRect = chart.sharedClips[animationClipKey];\n                // Initialize the animation. Set up the clipping rectangle.\n                if (init && group) {\n                    const clipBox = this.getClipBox();\n                    // Create temporary animation clips\n                    if (!animationClipRect) {\n                        clipBox.y = clipBox.height;\n                        clipBox.height = 0;\n                        animationClipRect = chart.renderer.clipRect(clipBox);\n                        chart.sharedClips[animationClipKey] = animationClipRect;\n                    }\n                    group.clip(animationClipRect);\n                    // Run the animation\n                }\n                else if (animationClipRect &&\n                    // Only first series in this pane\n                    !animationClipRect.hasClass('highcharts-animating')) {\n                    const finalBox = this.getClipBox();\n                    animationClipRect\n                        .addClass('highcharts-animating')\n                        .animate(finalBox, animation);\n                }\n            }\n            animateDrilldown() { }\n            animateDrillupFrom() { }\n            pointAttribs(point) {\n                const pointAttribs = super.pointAttribs.apply(this, arguments), seriesOptions = this.options, series = this, paths = seriesOptions.paths;\n                if (point && point.shapeArgs && paths) {\n                    const shape = paths[point.index % paths.length], { y, height } = getStackMetrics(series.yAxis, shape), pathDef = shape.definition;\n                    // New pattern, replace\n                    if (pathDef !== point.pathDef) {\n                        point.pathDef = pathDef;\n                        pointAttribs.fill = {\n                            pattern: {\n                                path: {\n                                    d: pathDef,\n                                    fill: pointAttribs.fill,\n                                    strokeWidth: pointAttribs['stroke-width'],\n                                    stroke: pointAttribs.stroke\n                                },\n                                x: point.shapeArgs.x,\n                                y: y,\n                                width: point.shapeArgs.width || 0,\n                                height: height,\n                                patternContentUnits: 'objectBoundingBox',\n                                backgroundColor: 'none',\n                                color: '#ff0000'\n                            }\n                        };\n                    }\n                    else if (point.pathDef && point.graphic) {\n                        delete pointAttribs.fill;\n                    }\n                }\n                delete pointAttribs.stroke;\n                delete pointAttribs.strokeWidth;\n                return pointAttribs;\n            }\n            /**\n             * Make sure that path.max is also considered when calculating dataMax.\n             */\n            getExtremes() {\n                const extremes = super.getExtremes.apply(this, arguments), series = this, paths = series.options.paths;\n                if (paths) {\n                    paths.forEach(function (path) {\n                        if (defined(path.max) &&\n                            defined(extremes.dataMax) &&\n                            path.max > extremes.dataMax) {\n                            extremes.dataMax = path.max;\n                        }\n                    });\n                }\n                return extremes;\n            }\n        }\n        /**\n         * A pictorial chart uses vector images to represents the data.\n         * The shape of the data point is taken from the path parameter.\n         *\n         * @sample       {highcharts} highcharts/demo/pictorial/\n         *               Pictorial chart\n         *\n         * @extends      plotOptions.column\n         * @since 11.0.0\n         * @product      highcharts\n         * @excluding    allAreas, borderRadius,\n         *               centerInCategory, colorAxis, colorKey, connectEnds,\n         *               connectNulls, crisp, compare, compareBase, dataSorting,\n         *               dashStyle, dataAsColumns, linecap, lineWidth, shadow,\n         *               onPoint\n         * @requires     modules/pictorial\n         * @optionparent plotOptions.pictorial\n         */\n        PictorialSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n            borderWidth: 0\n        });\n        /* *\n         *\n         *  Events\n         *\n         * */\n        addEvent(PictorialSeries, 'afterRender', function () {\n            const series = this, paths = series.options.paths, fillUrlMatcher = /url\\(([^)]+)\\)/;\n            series.points.forEach(function (point) {\n                if (point.graphic && point.shapeArgs && paths) {\n                    const shape = paths[point.index % paths.length], fill = point.graphic.attr('fill'), match = fill && fill.match(fillUrlMatcher), { y, height } = getStackMetrics(series.yAxis, shape);\n                    if (match && series.chart.renderer.patternElements) {\n                        const currentPattern = series.chart.renderer.patternElements[match[1].slice(1)];\n                        if (currentPattern) {\n                            currentPattern.animate({\n                                x: point.shapeArgs.x,\n                                y: y,\n                                width: point.shapeArgs.width || 0,\n                                height: height\n                            });\n                        }\n                    }\n                    rescalePatternFill(point.graphic, getStackMetrics(series.yAxis, shape).height, point.shapeArgs.width || 0, point.shapeArgs.height || Infinity, series.options.borderWidth || 0);\n                }\n            });\n        });\n        function renderStackShadow(stack) {\n            // Get first pictorial series\n            const stackKeys = Object\n                .keys(stack.points)\n                .filter((p) => p.split(',').length > 1), allSeries = stack.axis.chart.series, seriesIndexes = stackKeys.map((key) => parseFloat(key.split(',')[0]));\n            let seriesIndex = -1;\n            seriesIndexes.forEach((index) => {\n                if (allSeries[index] && allSeries[index].visible) {\n                    seriesIndex = index;\n                }\n            });\n            const series = stack.axis.chart.series[seriesIndex];\n            if (series &&\n                series.is('pictorial') &&\n                stack.axis.hasData() &&\n                series.xAxis.hasData()) {\n                const xAxis = series.xAxis, options = stack.axis.options, chart = stack.axis.chart, stackShadow = stack.shadow, xCenter = xAxis.toPixels(stack.x, true), x = chart.inverted ? xAxis.len - xCenter : xCenter, paths = series.options.paths || [], index = stack.x % paths.length, shape = paths[index], width = series.getColumnMetrics &&\n                    series.getColumnMetrics().width, { height, y } = getStackMetrics(series.yAxis, shape), shadowOptions = options.stackShadow, strokeWidth = pick(shadowOptions && shadowOptions.borderWidth, series.options.borderWidth, 1);\n                if (!stackShadow &&\n                    shadowOptions &&\n                    shadowOptions.enabled &&\n                    shape) {\n                    if (!stack.shadowGroup) {\n                        stack.shadowGroup = chart.renderer.g('shadow-group')\n                            .add();\n                    }\n                    stack.shadowGroup.attr({\n                        translateX: chart.inverted ?\n                            stack.axis.pos : xAxis.pos,\n                        translateY: chart.inverted ?\n                            xAxis.pos : stack.axis.pos\n                    });\n                    stack.shadow = chart.renderer.rect(x, y, width, height)\n                        .attr({\n                        fill: {\n                            pattern: {\n                                path: {\n                                    d: shape.definition,\n                                    fill: shadowOptions.color ||\n                                        '#dedede',\n                                    strokeWidth: strokeWidth,\n                                    stroke: shadowOptions.borderColor ||\n                                        'transparent'\n                                },\n                                x: x,\n                                y: y,\n                                width: width,\n                                height: height,\n                                patternContentUnits: 'objectBoundingBox',\n                                backgroundColor: 'none',\n                                color: '#dedede'\n                            }\n                        }\n                    })\n                        .add(stack.shadowGroup);\n                    invertShadowGroup(stack.shadowGroup, stack.axis);\n                    rescalePatternFill(stack.shadow, height, width, height, strokeWidth);\n                    stack.setOffset(series.pointXOffset || 0, series.barW || 0);\n                }\n                else if (stackShadow && stack.shadowGroup) {\n                    stackShadow.animate({\n                        x,\n                        y,\n                        width,\n                        height\n                    });\n                    const fillUrlMatcher = /url\\(([^)]+)\\)/, fill = stackShadow.attr('fill'), match = fill && fill.match(fillUrlMatcher);\n                    if (match && chart.renderer.patternElements) {\n                        chart.renderer.patternElements[match[1].slice(1)]\n                            .animate({\n                            x,\n                            y,\n                            width,\n                            height\n                        });\n                    }\n                    stack.shadowGroup.animate({\n                        translateX: chart.inverted ?\n                            stack.axis.pos : xAxis.pos,\n                        translateY: chart.inverted ?\n                            xAxis.pos : stack.axis.pos\n                    });\n                    invertShadowGroup(stack.shadowGroup, stack.axis);\n                    rescalePatternFill(stackShadow, height, width, height, strokeWidth);\n                    stack.setOffset(series.pointXOffset || 0, series.barW || 0);\n                }\n            }\n            else if (stack.shadow && stack.shadowGroup) {\n                stack.shadow.destroy();\n                stack.shadow = void 0;\n                stack.shadowGroup.destroy();\n                stack.shadowGroup = void 0;\n            }\n        }\n        function forEachStack(chart, callback) {\n            if (chart.axes) {\n                chart.axes.forEach(function (axis) {\n                    if (!axis.stacking) {\n                        return;\n                    }\n                    const stacks = axis.stacking.stacks;\n                    // Render each stack total\n                    objectEach(stacks, function (type) {\n                        objectEach(type, function (stack) {\n                            callback(stack);\n                        });\n                    });\n                });\n            }\n        }\n        addEvent(Chart, 'render', function () {\n            forEachStack(this, renderStackShadow);\n        });\n        addEvent(StackItem, 'afterSetOffset', function (e) {\n            if (this.shadow) {\n                const { chart, len } = this.axis, { xOffset, width } = e, translateX = chart.inverted ? xOffset - chart.xAxis[0].len : xOffset, translateY = chart.inverted ? -len : 0;\n                this.shadow.attr({\n                    translateX,\n                    translateY\n                });\n                this.shadow.animate({ width });\n            }\n        });\n        function destroyAllStackShadows(chart) {\n            forEachStack(chart, function (stack) {\n                if (stack.shadow && stack.shadowGroup) {\n                    stack.shadow.destroy();\n                    stack.shadowGroup.destroy();\n                    delete stack.shadow;\n                    delete stack.shadowGroup;\n                }\n            });\n        }\n        // This is a workaround due to no implementation of the animation drilldown.\n        addEvent(Chart, 'afterDrilldown', function (e) {\n            destroyAllStackShadows(this);\n        });\n        addEvent(Chart, 'afterDrillUp', function (e) {\n            destroyAllStackShadows(this);\n        });\n        PictorialSeries.prototype.pointClass = PictorialPoint;\n        SeriesRegistry.registerSeriesType('pictorial', PictorialSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `pictorial` series. If the [type](#series.pictorial.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.pictorial\n         * @since 11.0.0\n         * @product   highcharts\n         * @excluding dataParser, borderRadius, boostBlending, boostThreshold,\n         *            borderColor, borderWidth, centerInCategory, connectEnds,\n         *            connectNulls, crisp, colorKey, dataURL, dataAsColumns, depth,\n         *            dragDrop, edgeColor, edgeWidth, linecap, lineWidth,  marker,\n         *            dataSorting, dashStyle, onPoint, relativeXValue, shadow, zoneAxis,\n         *            zones\n         * @requires  modules/pictorial\n         * @apioption series.pictorial\n         */\n        /**\n         * An array of data points for the series. For the `pictorial` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the values correspond\n         *    to `x,y`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 40],\n         *        [1, 50],\n         *        [2, 60]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.pictorial.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 0,\n         *        y: 40,\n         *        name: \"Point1\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 60,\n         *        name: \"Point2\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.column.data\n         *\n         * @sample {highcharts} highcharts/demo/pictorial/\n         *         Pictorial chart\n         * @sample {highcharts} highcharts/demo/pictorial-stackshadow/\n         *         Pictorial stackShadow option\n         * @sample {highcharts} highcharts/series-pictorial/paths-max/\n         *         Pictorial max option\n         *\n         * @excluding borderColor, borderWidth, dashStyle, dragDrop\n         * @since 11.0.0\n         * @product   highcharts\n         * @apioption series.pictorial.data\n         */\n        /**\n         * The paths include options describing the point image.\n         *\n         * @declare   Highcharts.SeriesPictorialPathsOptionsObject\n         * @type      {Array<*>}\n         *\n         * @sample    {highcharts} highcharts/demo/pictorial/\n         *            Pictorial chart\n         *\n         * @since 11.0.0\n         * @product   highcharts\n         * @apioption series.pictorial.paths\n         */\n        /**\n         * The definition defines a path to be drawn. It corresponds `d` SVG attribute.\n         *\n         * @type      {string}\n         *\n         * @sample    {highcharts} highcharts/demo/pictorial/\n         *            Pictorial chart\n         *\n         * @product   highcharts\n         * @apioption series.pictorial.paths.definition\n         */\n        /**\n         * The max option determines height of the image. It is the ratio of\n         * `yAxis.max` to the `paths.max`.\n         *\n         * @sample {highcharts} highcharts/series-pictorial/paths-max\n         *         Pictorial max option\n         *\n         * @type      {number}\n         * @default   yAxis.max\n         * @product   highcharts\n         * @apioption series.pictorial.paths.max\n         */\n        /**\n         * Relevant only for pictorial series. The `stackShadow` forms the background of\n         * stacked points. Requires `series.stacking` to be defined.\n         *\n         * @sample {highcharts} highcharts/demo/pictorial-stackshadow/ Pictorial\n         *         stackShadow option\n         *\n         * @declare   Highcharts.YAxisOptions\n         * @type      {*}\n         * @since 11.0.0\n         * @product   highcharts\n         * @requires  modules/pictorial\n         * @apioption yAxis.stackShadow\n         */\n        /**\n         * The color of the `stackShadow` border.\n         *\n         * @declare   Highcharts.YAxisOptions\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   transparent\n         * @product   highcharts\n         * @requires  modules/pictorial\n         * @apioption yAxis.stackShadow.borderColor\n         */\n        /**\n         * The width of the `stackShadow` border.\n         *\n         * @declare   Highcharts.YAxisOptions\n         * @type      {number}\n         * @default   0\n         * @product   highcharts\n         * @requires  modules/pictorial\n         * @apioption yAxis.stackShadow.borderWidth\n         */\n        /**\n         * The color of the `stackShadow`.\n         *\n         * @declare   Highcharts.YAxisOptions\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   #dedede\n         * @product   highcharts\n         * @requires  modules/pictorial\n         * @apioption yAxis.stackShadow.color\n         */\n        /**\n         * Enable or disable `stackShadow`.\n         *\n         * @declare   Highcharts.YAxisOptions\n         * @type      {boolean}\n         * @default   undefined\n         * @product   highcharts\n         * @requires  modules/pictorial\n         * @apioption yAxis.stackShadow.enabled\n         */\n        ''; // adds doclets above to transpiled file\n\n        return PictorialSeries;\n    });\n    _registerModule(_modules, 'masters/modules/pictorial.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","A","Chart","H","D","Point","Series","SVGRenderer","U","animObject","getOptions","addEvent","defined","erase","merge","pick","removeEvent","wrap","patterns","colors","forEach","pattern","i","push","color","width","height","patternTransform","hashFromObject","preSeed","str","JSON","stringify","strLen","length","hash","seedStep","Math","max","floor","a","charCodeAt","toString","replace","prototype","calculatePatternDimensions","bBox","graphic","getBBox","element","shapeArgs","x","y","image","_width","_height","scaleY","series","chart","mapView","getSVGTransform","_inverted","aspectRatio","aspectWidth","aspectHeight","ceil","_x","round","abs","_y","addPattern","options","animation","animate","animationOptions","id","ren","attribs","idCounter","chartIndex","forExport","defIds","indexOf","attrs","patternUnits","patternContentUnits","createElement","attr","add","defs","isObject","d","backgroundColor","rect","fill","styledMode","stroke","strokeWidth","transform","opacity","call","childNodes","child","setAttribute","patternElements","proceed","oldColor","Array","slice","arguments","isResizing","isDirtyData","hasRendered","points","point","colorOptions","prop","value","patternIndex","forceHashId","parentNode","getAttribute","globalAnimation","duration","url","renderer","filter","visible","redraw","usedIds","renderTo","querySelectorAll","node","sanitizedId","destroy","rescalePatternFill","stackHeight","borderWidth","match","patternPath","document","querySelector","parent","parentElement","box","appendChild","scaleX","pointAspectRatio","invertShadowGroup","shadowGroup","yAxis","inverted","rotation","getStackMetrics","shape","len","toPixels","SeriesRegistry","PictorialUtilities","ColumnPoint","seriesTypes","column","pointClass","constructor","pathDef","setState","paths","index","Infinity","PictorialPoint","StackItem","ColumnSeries","objectEach","PictorialSeries","data","init","group","animationClipKey","getSharedClipKey","easing","defer","join","animationClipRect","sharedClips","clipBox","getClipBox","clipRect","clip","hasClass","finalBox","addClass","animateDrilldown","animateDrillupFrom","pointAttribs","seriesOptions","definition","getExtremes","extremes","dataMax","renderStackShadow","stack","stackKeys","Object","keys","p","split","allSeries","axis","seriesIndexes","map","key","parseFloat","seriesIndex","is","hasData","xAxis","stackShadow","shadow","xCenter","getColumnMetrics","shadowOptions","enabled","g","translateX","pos","translateY","borderColor","setOffset","pointXOffset","barW","forEachStack","callback","axes","stacking","stacks","type","destroyAllStackShadows","defaultOptions","fillUrlMatcher","currentPattern","e","xOffset","registerSeriesType"],"mappings":"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"}