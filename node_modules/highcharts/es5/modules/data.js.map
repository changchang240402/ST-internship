{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Data module\n *\n * (c) 2012-2021 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/data', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/HttpUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (G, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Christer Vasseng, Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var doc = G.doc;\n        var createElement = U.createElement, discardElement = U.discardElement, merge = U.merge, objectEach = U.objectEach;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Perform an Ajax call.\n         *\n         * @function Highcharts.ajax\n         *\n         * @param {Highcharts.AjaxSettingsObject} settings\n         *        The Ajax settings to use.\n         *\n         * @return {false|undefined}\n         *         Returns false, if error occured.\n         */\n        function ajax(settings) {\n            var headers = {\n                json: 'application/json',\n                xml: 'application/xml',\n                text: 'text/plain',\n                octet: 'application/octet-stream'\n            }, r = new XMLHttpRequest();\n            /**\n             * Private error handler.\n             * @private\n             * @param {XMLHttpRequest} xhr\n             * Internal request object.\n             * @param {string|Error} err\n             * Occured error.\n             */\n            function handleError(xhr, err) {\n                if (settings.error) {\n                    settings.error(xhr, err);\n                }\n                else {\n                    // @todo Maybe emit a highcharts error event here\n                }\n            }\n            if (!settings.url) {\n                return false;\n            }\n            r.open((settings.type || 'get').toUpperCase(), settings.url, true);\n            if (!settings.headers || !settings.headers['Content-Type']) {\n                r.setRequestHeader('Content-Type', headers[settings.dataType || 'json'] || headers.text);\n            }\n            objectEach(settings.headers, function (val, key) {\n                r.setRequestHeader(key, val);\n            });\n            if (settings.responseType) {\n                r.responseType = settings.responseType;\n            }\n            // @todo lacking timeout handling\n            r.onreadystatechange = function () {\n                var res;\n                if (r.readyState === 4) {\n                    if (r.status === 200) {\n                        if (settings.responseType !== 'blob') {\n                            res = r.responseText;\n                            if (settings.dataType === 'json') {\n                                try {\n                                    res = JSON.parse(res);\n                                }\n                                catch (e) {\n                                    if (e instanceof Error) {\n                                        return handleError(r, e);\n                                    }\n                                }\n                            }\n                        }\n                        return settings.success && settings.success(res, r);\n                    }\n                    handleError(r, r.responseText);\n                }\n            };\n            if (settings.data && typeof settings.data !== 'string') {\n                settings.data = JSON.stringify(settings.data);\n            }\n            r.send(settings.data);\n        }\n        /**\n         * Get a JSON resource over XHR, also supporting CORS without preflight.\n         *\n         * @function Highcharts.getJSON\n         * @param {string} url\n         *        The URL to load.\n         * @param {Function} success\n         *        The success callback. For error handling, use the `Highcharts.ajax`\n         *        function instead.\n         */\n        function getJSON(url, success) {\n            HttpUtilities.ajax({\n                url: url,\n                success: success,\n                dataType: 'json',\n                headers: {\n                    // Override the Content-Type to avoid preflight problems with CORS\n                    // in the Highcharts demos\n                    'Content-Type': 'text/plain'\n                }\n            });\n        }\n        /**\n         * The post utility\n         *\n         * @private\n         * @function Highcharts.post\n         *\n         * @param {string} url\n         * Post URL\n         *\n         * @param {Object} data\n         * Post data\n         *\n         * @param {Highcharts.Dictionary<string>} [formAttributes]\n         * Additional attributes for the post request\n         */\n        function post(url, data, formAttributes) {\n            // create the form\n            var form = createElement('form', merge({\n                method: 'post',\n                action: url,\n                enctype: 'multipart/form-data'\n            }, formAttributes), {\n                display: 'none'\n            }, doc.body);\n            // add the data\n            objectEach(data, function (val, name) {\n                createElement('input', {\n                    type: 'hidden',\n                    name: name,\n                    value: val\n                }, void 0, form);\n            });\n            // submit\n            form.submit();\n            // clean up\n            discardElement(form);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var HttpUtilities = {\n            ajax: ajax,\n            getJSON: getJSON,\n            post: post\n        };\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @interface Highcharts.AjaxSettingsObject\n         */ /**\n        * The payload to send.\n        *\n        * @name Highcharts.AjaxSettingsObject#data\n        * @type {string|Highcharts.Dictionary<any>|undefined}\n        */ /**\n        * The data type expected.\n        * @name Highcharts.AjaxSettingsObject#dataType\n        * @type {\"json\"|\"xml\"|\"text\"|\"octet\"|undefined}\n        */ /**\n        * Function to call on error.\n        * @name Highcharts.AjaxSettingsObject#error\n        * @type {Function|undefined}\n        */ /**\n        * The headers; keyed on header name.\n        * @name Highcharts.AjaxSettingsObject#headers\n        * @type {Highcharts.Dictionary<string>|undefined}\n        */ /**\n        * Function to call on success.\n        * @name Highcharts.AjaxSettingsObject#success\n        * @type {Function|undefined}\n        */ /**\n        * The HTTP method to use. For example GET or POST.\n        * @name Highcharts.AjaxSettingsObject#type\n        * @type {string|undefined}\n        */ /**\n        * The URL to call.\n        * @name Highcharts.AjaxSettingsObject#url\n        * @type {string}\n        */\n        (''); // keeps doclets above in JS file\n\n        return HttpUtilities;\n    });\n    _registerModule(_modules, 'Extensions/Data.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Chart, D, G, HU, Point, SeriesRegistry, U) {\n        /* *\n         *\n         *  Data module\n         *\n         *  (c) 2012-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var getOptions = D.getOptions;\n        var doc = G.doc;\n        var ajax = HU.ajax;\n        var seriesTypes = SeriesRegistry.seriesTypes;\n        var addEvent = U.addEvent, defined = U.defined, extend = U.extend, fireEvent = U.fireEvent, isNumber = U.isNumber, merge = U.merge, objectEach = U.objectEach, pick = U.pick, splat = U.splat;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function getFreeIndexes(numberOfColumns, seriesBuilders) {\n            var freeIndexes = [], freeIndexValues = [];\n            var s, i, referencedIndexes;\n            // Add all columns as free\n            for (i = 0; i < numberOfColumns; i = i + 1) {\n                freeIndexes.push(true);\n            }\n            // Loop all defined builders and remove their referenced columns\n            for (s = 0; s < seriesBuilders.length; s = s + 1) {\n                referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();\n                for (i = 0; i < referencedIndexes.length; i = i + 1) {\n                    freeIndexes[referencedIndexes[i]] = false;\n                }\n            }\n            // Collect the values for the free indexes\n            for (i = 0; i < freeIndexes.length; i = i + 1) {\n                if (freeIndexes[i]) {\n                    freeIndexValues.push(i);\n                }\n            }\n            return freeIndexValues;\n        }\n        function hasURLOption(options) {\n            return Boolean(options &&\n                (options.rowsURL || options.csvURL || options.columnsURL));\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Data class\n         *\n         * @requires module:modules/data\n         *\n         * @class\n         * @name Highcharts.Data\n         *\n         * @param {Highcharts.DataOptions} dataOptions\n         *\n         * @param {Highcharts.Options} [chartOptions]\n         *\n         * @param {Highcharts.Chart} [chart]\n         */\n        var Data = /** @class */ (function () {\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            function Data(dataOptions, chartOptions, chart) {\n                if (chartOptions === void 0) { chartOptions = {}; }\n                this.rowsToColumns = Data.rowsToColumns; // backwards compatibility\n                /**\n                 * A collection of available date formats, extendable from the outside to\n                 * support custom date formats.\n                 *\n                 * @name Highcharts.Data#dateFormats\n                 * @type {Highcharts.Dictionary<Highcharts.DataDateFormatObject>}\n                 */\n                this.dateFormats = {\n                    'YYYY/mm/dd': {\n                        regex: /^([0-9]{4})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[1], match[2] - 1, +match[3]) :\n                                NaN);\n                        }\n                    },\n                    'dd/mm/YYYY': {\n                        regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{4})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[3], match[2] - 1, +match[1]) :\n                                NaN);\n                        },\n                        alternative: 'mm/dd/YYYY' // different format with the same regex\n                    },\n                    'mm/dd/YYYY': {\n                        regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{4})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[3], match[1] - 1, +match[2]) :\n                                NaN);\n                        }\n                    },\n                    'dd/mm/YY': {\n                        regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{2})$/,\n                        parser: function (match) {\n                            if (!match) {\n                                return NaN;\n                            }\n                            var d = new Date();\n                            var year = +match[3];\n                            if (year > (d.getFullYear() - 2000)) {\n                                year += 1900;\n                            }\n                            else {\n                                year += 2000;\n                            }\n                            return Date.UTC(year, match[2] - 1, +match[1]);\n                        },\n                        alternative: 'mm/dd/YY' // different format with the same regex\n                    },\n                    'mm/dd/YY': {\n                        regex: /^([0-9]{1,2})[\\-\\/\\.]([0-9]{1,2})[\\-\\/\\.]([0-9]{2})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[3] + 2000, match[1] - 1, +match[2]) :\n                                NaN);\n                        }\n                    }\n                };\n                this.chart = chart;\n                this.chartOptions = chartOptions;\n                this.options = dataOptions;\n                this.rawColumns = [];\n                this.init(dataOptions, chartOptions, chart);\n            }\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            /**\n             * Creates a data object to parse data for a chart.\n             *\n             * @function Highcharts.data\n             */\n            Data.data = function (dataOptions, chartOptions, chart) {\n                if (chartOptions === void 0) { chartOptions = {}; }\n                return new Data(dataOptions, chartOptions, chart);\n            };\n            /**\n             * Reorganize rows into columns.\n             *\n             * @function Highcharts.Data.rowsToColumns\n             */\n            Data.rowsToColumns = function (rows) {\n                var row, rowsLength, col, colsLength, columns;\n                if (rows) {\n                    columns = [];\n                    rowsLength = rows.length;\n                    for (row = 0; row < rowsLength; row++) {\n                        colsLength = rows[row].length;\n                        for (col = 0; col < colsLength; col++) {\n                            if (!columns[col]) {\n                                columns[col] = [];\n                            }\n                            columns[col][row] = rows[row][col];\n                        }\n                    }\n                }\n                return columns;\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Data object with the given options\n             *\n             * @private\n             * @function Highcharts.Data#init\n             */\n            Data.prototype.init = function (dataOptions, chartOptions, chart) {\n                var decimalPoint = dataOptions.decimalPoint, hasData;\n                if (chartOptions) {\n                    this.chartOptions = chartOptions;\n                }\n                if (chart) {\n                    this.chart = chart;\n                }\n                if (decimalPoint !== '.' && decimalPoint !== ',') {\n                    decimalPoint = void 0;\n                }\n                this.options = dataOptions;\n                this.columns = (dataOptions.columns ||\n                    this.rowsToColumns(dataOptions.rows) ||\n                    []);\n                this.firstRowAsNames = pick(dataOptions.firstRowAsNames, this.firstRowAsNames, true);\n                this.decimalRegex = (decimalPoint &&\n                    new RegExp('^(-?[0-9]+)' + decimalPoint + '([0-9]+)$'));\n                // Always stop old polling when we have new options\n                if (this.liveDataTimeout !== void 0) {\n                    clearTimeout(this.liveDataTimeout);\n                }\n                // This is a two-dimensional array holding the raw, trimmed string\n                // values with the same organisation as the columns array. It makes it\n                // possible for example to revert from interpreted timestamps to\n                // string-based categories.\n                this.rawColumns = [];\n                // No need to parse or interpret anything\n                if (this.columns.length) {\n                    this.dataFound();\n                    hasData = !hasURLOption(dataOptions);\n                }\n                if (!hasData) {\n                    // Fetch live data\n                    hasData = this.fetchLiveData();\n                }\n                if (!hasData) {\n                    // Parse a CSV string if options.csv is given. The parseCSV function\n                    // returns a columns array, if it has no length, we have no data\n                    hasData = Boolean(this.parseCSV().length);\n                }\n                if (!hasData) {\n                    // Parse a HTML table if options.table is given\n                    hasData = Boolean(this.parseTable().length);\n                }\n                if (!hasData) {\n                    // Parse a Google Spreadsheet\n                    hasData = this.parseGoogleSpreadsheet();\n                }\n                if (!hasData && dataOptions.afterComplete) {\n                    dataOptions.afterComplete();\n                }\n            };\n            /**\n             * Get the column distribution. For example, a line series takes a single\n             * column for Y values. A range series takes two columns for low and high\n             * values respectively, and an OHLC series takes four columns.\n             *\n             * @function Highcharts.Data#getColumnDistribution\n             */\n            Data.prototype.getColumnDistribution = function () {\n                var chartOptions = this.chartOptions, options = this.options, xColumns = [], getValueCount = function (type) {\n                    return (seriesTypes[type || 'line'].prototype.pointArrayMap || [0]).length;\n                }, getPointArrayMap = function (type) {\n                    return seriesTypes[type || 'line'].prototype.pointArrayMap;\n                }, globalType = (chartOptions &&\n                    chartOptions.chart &&\n                    chartOptions.chart.type), individualCounts = [], seriesBuilders = [], \n                // If no series mapping is defined, check if the series array is\n                // defined with types.\n                seriesMapping = ((options && options.seriesMapping) ||\n                    (chartOptions &&\n                        chartOptions.series &&\n                        chartOptions.series.map(function () {\n                            return { x: 0 };\n                        })) ||\n                    []);\n                var seriesIndex = 0, i;\n                ((chartOptions && chartOptions.series) || []).forEach(function (series) {\n                    individualCounts.push(getValueCount(series.type || globalType));\n                });\n                // Collect the x-column indexes from seriesMapping\n                seriesMapping.forEach(function (mapping) {\n                    xColumns.push(mapping.x || 0);\n                });\n                // If there are no defined series with x-columns, use the first column\n                // as x column\n                if (xColumns.length === 0) {\n                    xColumns.push(0);\n                }\n                // Loop all seriesMappings and constructs SeriesBuilders from\n                // the mapping options.\n                seriesMapping.forEach(function (mapping) {\n                    var builder = new SeriesBuilder(), numberOfValueColumnsNeeded = individualCounts[seriesIndex] ||\n                        getValueCount(globalType), seriesArr = (chartOptions && chartOptions.series) || [], series = seriesArr[seriesIndex] || {}, defaultPointArrayMap = getPointArrayMap(series.type || globalType), pointArrayMap = defaultPointArrayMap || ['y'];\n                    if (\n                    // User-defined x.mapping\n                    defined(mapping.x) ||\n                        // All non cartesian don't need 'x'\n                        series.isCartesian ||\n                        // Except pie series:\n                        !defaultPointArrayMap) {\n                        // Add an x reader from the x property or from an undefined\n                        // column if the property is not set. It will then be auto\n                        // populated later.\n                        builder.addColumnReader(mapping.x, 'x');\n                    }\n                    // Add all column mappings\n                    objectEach(mapping, function (val, name) {\n                        if (name !== 'x') {\n                            builder.addColumnReader(val, name);\n                        }\n                    });\n                    // Add missing columns\n                    for (i = 0; i < numberOfValueColumnsNeeded; i++) {\n                        if (!builder.hasReader(pointArrayMap[i])) {\n                            // Create and add a column reader for the next free column\n                            // index\n                            builder.addColumnReader(void 0, pointArrayMap[i]);\n                        }\n                    }\n                    seriesBuilders.push(builder);\n                    seriesIndex++;\n                });\n                var globalPointArrayMap = getPointArrayMap(globalType);\n                if (typeof globalPointArrayMap === 'undefined') {\n                    globalPointArrayMap = ['y'];\n                }\n                this.valueCount = {\n                    global: getValueCount(globalType),\n                    xColumns: xColumns,\n                    individual: individualCounts,\n                    seriesBuilders: seriesBuilders,\n                    globalPointArrayMap: globalPointArrayMap\n                };\n            };\n            /**\n             * When the data is parsed into columns, either by CSV, table, GS or direct\n             * input, continue with other operations.\n             *\n             * @private\n             * @function Highcharts.Data#dataFound\n             */\n            Data.prototype.dataFound = function () {\n                if (this.options.switchRowsAndColumns) {\n                    this.columns = this.rowsToColumns(this.columns);\n                }\n                // Interpret the info about series and columns\n                this.getColumnDistribution();\n                // Interpret the values into right types\n                this.parseTypes();\n                // Handle columns if a handleColumns callback is given\n                if (this.parsed() !== false) {\n                    // Complete if a complete callback is given\n                    this.complete();\n                }\n            };\n            /**\n             * Parse a CSV input string\n             *\n             * @function Highcharts.Data#parseCSV\n             */\n            Data.prototype.parseCSV = function (inOptions) {\n                var self = this, columns = this.columns = [], options = inOptions || this.options, startColumn = (typeof options.startColumn !== 'undefined' &&\n                    options.startColumn) ? options.startColumn : 0, endColumn = options.endColumn || Number.MAX_VALUE, dataTypes = [], \n                // We count potential delimiters in the prepass, and use the\n                // result as the basis of half-intelligent guesses.\n                potDelimiters = {\n                    ',': 0,\n                    ';': 0,\n                    '\\t': 0\n                };\n                var csv = options.csv, startRow = (typeof options.startRow !== 'undefined' && options.startRow ?\n                    options.startRow :\n                    0), endRow = options.endRow || Number.MAX_VALUE, itemDelimiter, lines, \n                // activeRowNo = 0,\n                rowIt = 0;\n                /*\n                    This implementation is quite verbose. It will be shortened once\n                    it's stable and passes all the test.\n\n                    It's also not written with speed in mind, instead everything is\n                    very seggregated, and there a several redundant loops.\n                    This is to make it easier to stabilize the code initially.\n\n                    We do a pre-pass on the first 4 rows to make some intelligent\n                    guesses on the set. Guessed delimiters are in this pass counted.\n\n                    Auto detecting delimiters\n                        - If we meet a quoted string, the next symbol afterwards\n                          (that's not \\s, \\t) is the delimiter\n                        - If we meet a date, the next symbol afterwards is the delimiter\n\n                    Date formats\n                        - If we meet a column with date formats, check all of them to\n                          see if one of the potential months crossing 12. If it does,\n                          we now know the format\n\n                    It would make things easier to guess the delimiter before\n                    doing the actual parsing.\n\n                    General rules:\n                        - Quoting is allowed, e.g: \"Col 1\",123,321\n                        - Quoting is optional, e.g.: Col1,123,321\n                        - Doubble quoting is escaping, e.g. \"Col \"\"Hello world\"\"\",123\n                        - Spaces are considered part of the data: Col1 ,123\n                        - New line is always the row delimiter\n                        - Potential column delimiters are , ; \\t\n                        - First row may optionally contain headers\n                        - The last row may or may not have a row delimiter\n                        - Comments are optionally supported, in which case the comment\n                          must start at the first column, and the rest of the line will\n                          be ignored\n                */\n                /**\n                 * Parse a single row.\n                 * @private\n                 */\n                function parseRow(columnStr, rowNumber, noAdd, callbacks) {\n                    var i = 0, c = '', cl = '', cn = '', token = '', actualColumn = 0, column = 0;\n                    /**\n                     * @private\n                     */\n                    function read(j) {\n                        c = columnStr[j];\n                        cl = columnStr[j - 1];\n                        cn = columnStr[j + 1];\n                    }\n                    /**\n                     * @private\n                     */\n                    function pushType(type) {\n                        if (dataTypes.length < column + 1) {\n                            dataTypes.push([type]);\n                        }\n                        if (dataTypes[column][dataTypes[column].length - 1] !== type) {\n                            dataTypes[column].push(type);\n                        }\n                    }\n                    /**\n                     * @private\n                     */\n                    function push() {\n                        if (startColumn > actualColumn || actualColumn > endColumn) {\n                            // Skip this column, but increment the column count (#7272)\n                            ++actualColumn;\n                            token = '';\n                            return;\n                        }\n                        if (!isNaN(parseFloat(token)) && isFinite(token)) {\n                            token = parseFloat(token);\n                            pushType('number');\n                        }\n                        else if (!isNaN(Date.parse(token))) {\n                            token = token.replace(/\\//g, '-');\n                            pushType('date');\n                        }\n                        else {\n                            pushType('string');\n                        }\n                        if (columns.length < column + 1) {\n                            columns.push([]);\n                        }\n                        if (!noAdd) {\n                            // Don't push - if there's a varrying amount of columns\n                            // for each row, pushing will skew everything down n slots\n                            columns[column][rowNumber] = token;\n                        }\n                        token = '';\n                        ++column;\n                        ++actualColumn;\n                    }\n                    if (!columnStr.trim().length) {\n                        return;\n                    }\n                    if (columnStr.trim()[0] === '#') {\n                        return;\n                    }\n                    for (; i < columnStr.length; i++) {\n                        read(i);\n                        if (c === '\"') {\n                            read(++i);\n                            while (i < columnStr.length) {\n                                if (c === '\"' && cl !== '\"' && cn !== '\"') {\n                                    break;\n                                }\n                                if (c !== '\"' || (c === '\"' && cl !== '\"')) {\n                                    token += c;\n                                }\n                                read(++i);\n                            }\n                            // Perform \"plugin\" handling\n                        }\n                        else if (callbacks && callbacks[c]) {\n                            if (callbacks[c](c, token)) {\n                                push();\n                            }\n                            // Delimiter - push current token\n                        }\n                        else if (c === itemDelimiter) {\n                            push();\n                            // Actual column data\n                        }\n                        else {\n                            token += c;\n                        }\n                    }\n                    push();\n                }\n                /**\n                 * Attempt to guess the delimiter. We do a separate parse pass here\n                 * because we need to count potential delimiters softly without making\n                 * any assumptions.\n                 * @private\n                 */\n                function guessDelimiter(lines) {\n                    var points = 0, commas = 0, guessed = false;\n                    lines.some(function (columnStr, i) {\n                        var inStr = false, c, cn, cl, token = '';\n                        // We should be able to detect dateformats within 13 rows\n                        if (i > 13) {\n                            return true;\n                        }\n                        for (var j = 0; j < columnStr.length; j++) {\n                            c = columnStr[j];\n                            cn = columnStr[j + 1];\n                            cl = columnStr[j - 1];\n                            if (c === '#') {\n                                // Skip the rest of the line - it's a comment\n                                return;\n                            }\n                            if (c === '\"') {\n                                if (inStr) {\n                                    if (cl !== '\"' && cn !== '\"') {\n                                        while (cn === ' ' && j < columnStr.length) {\n                                            cn = columnStr[++j];\n                                        }\n                                        // After parsing a string, the next non-blank\n                                        // should be a delimiter if the CSV is properly\n                                        // formed.\n                                        if (typeof potDelimiters[cn] !== 'undefined') {\n                                            potDelimiters[cn]++;\n                                        }\n                                        inStr = false;\n                                    }\n                                }\n                                else {\n                                    inStr = true;\n                                }\n                            }\n                            else if (typeof potDelimiters[c] !== 'undefined') {\n                                token = token.trim();\n                                if (!isNaN(Date.parse(token))) {\n                                    potDelimiters[c]++;\n                                }\n                                else if (isNaN(token) ||\n                                    !isFinite(token)) {\n                                    potDelimiters[c]++;\n                                }\n                                token = '';\n                            }\n                            else {\n                                token += c;\n                            }\n                            if (c === ',') {\n                                commas++;\n                            }\n                            if (c === '.') {\n                                points++;\n                            }\n                        }\n                    });\n                    // Count the potential delimiters.\n                    // This could be improved by checking if the number of delimiters\n                    // equals the number of columns - 1\n                    if (potDelimiters[';'] > potDelimiters[',']) {\n                        guessed = ';';\n                    }\n                    else if (potDelimiters[','] > potDelimiters[';']) {\n                        guessed = ',';\n                    }\n                    else {\n                        // No good guess could be made..\n                        guessed = ',';\n                    }\n                    // Try to deduce the decimal point if it's not explicitly set.\n                    // If both commas or points is > 0 there is likely an issue\n                    if (!options.decimalPoint) {\n                        if (points > commas) {\n                            options.decimalPoint = '.';\n                        }\n                        else {\n                            options.decimalPoint = ',';\n                        }\n                        // Apply a new decimal regex based on the presumed decimal sep.\n                        self.decimalRegex = new RegExp('^(-?[0-9]+)' +\n                            options.decimalPoint +\n                            '([0-9]+)$');\n                    }\n                    return guessed;\n                }\n                /**\n                 * Tries to guess the date format\n                 *  - Check if either month candidate exceeds 12\n                 *  - Check if year is missing (use current year)\n                 *  - Check if a shortened year format is used (e.g. 1/1/99)\n                 *  - If no guess can be made, the user must be prompted\n                 * data is the data to deduce a format based on\n                 * @private\n                 */\n                function deduceDateFormat(data, limit) {\n                    var format = 'YYYY/mm/dd', stable = [], max = [];\n                    var thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = false, \n                    // candidates = {},\n                    j;\n                    if (!limit || limit > data.length) {\n                        limit = data.length;\n                    }\n                    for (; i < limit; i++) {\n                        if (typeof data[i] !== 'undefined' &&\n                            data[i] && data[i].length) {\n                            thing = data[i]\n                                .trim()\n                                .replace(/\\//g, ' ')\n                                .replace(/\\-/g, ' ')\n                                .replace(/\\./g, ' ')\n                                .split(' ');\n                            guessedFormat = [\n                                '',\n                                '',\n                                ''\n                            ];\n                            for (j = 0; j < thing.length; j++) {\n                                if (j < guessedFormat.length) {\n                                    thing[j] = parseInt(thing[j], 10);\n                                    if (thing[j]) {\n                                        max[j] = (!max[j] || max[j] < thing[j]) ?\n                                            thing[j] :\n                                            max[j];\n                                        if (typeof stable[j] !== 'undefined') {\n                                            if (stable[j] !== thing[j]) {\n                                                stable[j] = false;\n                                            }\n                                        }\n                                        else {\n                                            stable[j] = thing[j];\n                                        }\n                                        if (thing[j] > 31) {\n                                            if (thing[j] < 100) {\n                                                guessedFormat[j] = 'YY';\n                                            }\n                                            else {\n                                                guessedFormat[j] = 'YYYY';\n                                            }\n                                            // madeDeduction = true;\n                                        }\n                                        else if (thing[j] > 12 &&\n                                            thing[j] <= 31) {\n                                            guessedFormat[j] = 'dd';\n                                            madeDeduction = true;\n                                        }\n                                        else if (!guessedFormat[j].length) {\n                                            guessedFormat[j] = 'mm';\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (madeDeduction) {\n                        // This handles a few edge cases with hard to guess dates\n                        for (j = 0; j < stable.length; j++) {\n                            if (stable[j] !== false) {\n                                if (max[j] > 12 &&\n                                    guessedFormat[j] !== 'YY' &&\n                                    guessedFormat[j] !== 'YYYY') {\n                                    guessedFormat[j] = 'YY';\n                                }\n                            }\n                            else if (max[j] > 12 && guessedFormat[j] === 'mm') {\n                                guessedFormat[j] = 'dd';\n                            }\n                        }\n                        // If the middle one is dd, and the last one is dd,\n                        // the last should likely be year.\n                        if (guessedFormat.length === 3 &&\n                            guessedFormat[1] === 'dd' &&\n                            guessedFormat[2] === 'dd') {\n                            guessedFormat[2] = 'YY';\n                        }\n                        calculatedFormat = guessedFormat.join('/');\n                        // If the caculated format is not valid, we need to present an\n                        // error.\n                        if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {\n                            // This should emit an event instead\n                            fireEvent('deduceDateFailed');\n                            return format;\n                        }\n                        return calculatedFormat;\n                    }\n                    return format;\n                }\n                /**\n                 * @todo\n                 * Figure out the best axis types for the data\n                 * - If the first column is a number, we're good\n                 * - If the first column is a date, set to date/time\n                 * - If the first column is a string, set to categories\n                 * @private\n                 */\n                function deduceAxisTypes() {\n                }\n                if (csv && options.beforeParse) {\n                    csv = options.beforeParse.call(this, csv);\n                }\n                if (csv) {\n                    lines = csv\n                        .replace(/\\r\\n/g, '\\n') // Unix\n                        .replace(/\\r/g, '\\n') // Mac\n                        .split(options.lineDelimiter || '\\n');\n                    if (!startRow || startRow < 0) {\n                        startRow = 0;\n                    }\n                    if (!endRow || endRow >= lines.length) {\n                        endRow = lines.length - 1;\n                    }\n                    if (options.itemDelimiter) {\n                        itemDelimiter = options.itemDelimiter;\n                    }\n                    else {\n                        itemDelimiter = null;\n                        itemDelimiter = guessDelimiter(lines);\n                    }\n                    var offset = 0;\n                    for (rowIt = startRow; rowIt <= endRow; rowIt++) {\n                        if (lines[rowIt][0] === '#') {\n                            offset++;\n                        }\n                        else {\n                            parseRow(lines[rowIt], rowIt - startRow - offset);\n                        }\n                    }\n                    // //Make sure that there's header columns for everything\n                    // columns.forEach(function (col) {\n                    // });\n                    deduceAxisTypes();\n                    if ((!options.columnTypes || options.columnTypes.length === 0) &&\n                        dataTypes.length &&\n                        dataTypes[0].length &&\n                        dataTypes[0][1] === 'date' &&\n                        !options.dateFormat) {\n                        options.dateFormat = deduceDateFormat(columns[0]);\n                    }\n                    // lines.forEach(function (line, rowNo) {\n                    //    let trimmed = self.trim(line),\n                    //        isComment = trimmed.indexOf('#') === 0,\n                    //        isBlank = trimmed === '',\n                    //        items;\n                    //    if (\n                    //        rowNo >= startRow &&\n                    //        rowNo <= endRow &&\n                    //        !isComment && !isBlank\n                    //    ) {\n                    //        items = line.split(itemDelimiter);\n                    //        items.forEach(function (item, colNo) {\n                    //            if (colNo >= startColumn && colNo <= endColumn) {\n                    //                if (!columns[colNo - startColumn]) {\n                    //                    columns[colNo - startColumn] = [];\n                    //                }\n                    //                columns[colNo - startColumn][activeRowNo] = item;\n                    //            }\n                    //        });\n                    //        activeRowNo += 1;\n                    //    }\n                    // });\n                    //\n                    this.dataFound();\n                }\n                return columns;\n            };\n            /**\n             * Parse a HTML table\n             *\n             * @function Highcharts.Data#parseTable\n             */\n            Data.prototype.parseTable = function () {\n                var options = this.options, columns = this.columns || [], startRow = options.startRow || 0, endRow = options.endRow || Number.MAX_VALUE, startColumn = options.startColumn || 0, endColumn = options.endColumn || Number.MAX_VALUE;\n                if (options.table) {\n                    var table = options.table;\n                    if (typeof table === 'string') {\n                        table = doc.getElementById(table);\n                    }\n                    [].forEach.call(table.getElementsByTagName('tr'), function (tr, rowNo) {\n                        if (rowNo >= startRow && rowNo <= endRow) {\n                            [].forEach.call(tr.children, function (item, colNo) {\n                                var row = columns[colNo - startColumn];\n                                var i = 1;\n                                if ((item.tagName === 'TD' ||\n                                    item.tagName === 'TH') &&\n                                    colNo >= startColumn &&\n                                    colNo <= endColumn) {\n                                    if (!columns[colNo - startColumn]) {\n                                        columns[colNo - startColumn] = [];\n                                    }\n                                    columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;\n                                    // Loop over all previous indices and make sure\n                                    // they are nulls, not undefined.\n                                    while (rowNo - startRow >= i &&\n                                        row[rowNo - startRow - i] === void 0) {\n                                        row[rowNo - startRow - i] = null;\n                                        i++;\n                                    }\n                                }\n                            });\n                        }\n                    });\n                    this.dataFound(); // continue\n                }\n                return columns;\n            };\n            /**\n             * Fetch or refetch live data\n             *\n             * @function Highcharts.Data#fetchLiveData\n             *\n             * @return {boolean}\n             *         The URLs that were tried can be found in the options\n             */\n            Data.prototype.fetchLiveData = function () {\n                var data = this, chart = this.chart, options = this.options, maxRetries = 3, pollingEnabled = options.enablePolling, originalOptions = merge(options);\n                var currentRetries = 0, updateIntervalMs = (options.dataRefreshRate || 2) * 1000;\n                if (!hasURLOption(options)) {\n                    return false;\n                }\n                // Do not allow polling more than once a second\n                if (updateIntervalMs < 1000) {\n                    updateIntervalMs = 1000;\n                }\n                delete options.csvURL;\n                delete options.rowsURL;\n                delete options.columnsURL;\n                /**\n                 * @private\n                 */\n                function performFetch(initialFetch) {\n                    /**\n                     * Helper function for doing the data fetch + polling.\n                     * @private\n                     */\n                    function request(url, done, tp) {\n                        if (!url ||\n                            !/^(http|\\/|\\.\\/|\\.\\.\\/)/.test(url)) {\n                            if (url && options.error) {\n                                options.error('Invalid URL');\n                            }\n                            return false;\n                        }\n                        if (initialFetch) {\n                            clearTimeout(data.liveDataTimeout);\n                            chart.liveDataURL = url;\n                        }\n                        /**\n                         * @private\n                         */\n                        function poll() {\n                            // Poll\n                            if (pollingEnabled && chart.liveDataURL === url) {\n                                // We need to stop doing this if the URL has changed\n                                data.liveDataTimeout =\n                                    setTimeout(performFetch, updateIntervalMs);\n                            }\n                        }\n                        ajax({\n                            url: url,\n                            dataType: tp || 'json',\n                            success: function (res) {\n                                if (chart && chart.series) {\n                                    done(res);\n                                }\n                                poll();\n                            },\n                            error: function (xhr, text) {\n                                if (++currentRetries < maxRetries) {\n                                    poll();\n                                }\n                                return options.error && options.error(text, xhr);\n                            }\n                        });\n                        return true;\n                    }\n                    if (!request(originalOptions.csvURL, function (res) {\n                        chart.update({\n                            data: {\n                                csv: res\n                            }\n                        });\n                    }, 'text')) {\n                        if (!request(originalOptions.rowsURL, function (res) {\n                            chart.update({\n                                data: {\n                                    rows: res\n                                }\n                            });\n                        })) {\n                            request(originalOptions.columnsURL, function (res) {\n                                chart.update({\n                                    data: {\n                                        columns: res\n                                    }\n                                });\n                            });\n                        }\n                    }\n                }\n                performFetch(true);\n                return hasURLOption(options);\n            };\n            /**\n             * Parse a Google spreadsheet.\n             *\n             * @function Highcharts.Data#parseGoogleSpreadsheet\n             *\n             * @return {boolean}\n             *         Always returns false, because it is an intermediate fetch.\n             */\n            Data.prototype.parseGoogleSpreadsheet = function () {\n                var data = this, options = this.options, googleSpreadsheetKey = options.googleSpreadsheetKey, chart = this.chart, refreshRate = Math.max((options.dataRefreshRate || 2) * 1000, 4000);\n                /**\n                 * Form the `values` field after range settings, unless the\n                 * googleSpreadsheetRange option is set.\n                 */\n                var getRange = function () {\n                    if (options.googleSpreadsheetRange) {\n                        return options.googleSpreadsheetRange;\n                    }\n                    var alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n                    var start = (alphabet.charAt(options.startColumn || 0) || 'A') +\n                        ((options.startRow || 0) + 1);\n                    var end = alphabet.charAt(pick(options.endColumn, -1)) || 'ZZ';\n                    if (defined(options.endRow)) {\n                        end += options.endRow + 1;\n                    }\n                    return \"\".concat(start, \":\").concat(end);\n                };\n                /**\n                 * Fetch the actual spreadsheet using XMLHttpRequest.\n                 * @private\n                 */\n                function fetchSheet(fn) {\n                    var url = [\n                        'https://sheets.googleapis.com/v4/spreadsheets',\n                        googleSpreadsheetKey,\n                        'values',\n                        getRange(),\n                        '?alt=json&' +\n                            'majorDimension=COLUMNS&' +\n                            'valueRenderOption=UNFORMATTED_VALUE&' +\n                            'dateTimeRenderOption=FORMATTED_STRING&' +\n                            'key=' + options.googleAPIKey\n                    ].join('/');\n                    ajax({\n                        url: url,\n                        dataType: 'json',\n                        success: function (json) {\n                            fn(json);\n                            if (options.enablePolling) {\n                                data.liveDataTimeout = setTimeout(function () {\n                                    fetchSheet(fn);\n                                }, refreshRate);\n                            }\n                        },\n                        error: function (xhr, text) {\n                            return options.error && options.error(text, xhr);\n                        }\n                    });\n                }\n                if (googleSpreadsheetKey) {\n                    delete options.googleSpreadsheetKey;\n                    fetchSheet(function (json) {\n                        // Prepare the data from the spreadsheat\n                        var columns = json.values;\n                        if (!columns || columns.length === 0) {\n                            return false;\n                        }\n                        // Find the maximum row count in order to extend shorter columns\n                        var rowCount = columns.reduce(function (rowCount, column) { return Math.max(rowCount, column.length); }, 0);\n                        // Insert null for empty spreadsheet cells (#5298)\n                        columns.forEach(function (column) {\n                            for (var i = 0; i < rowCount; i++) {\n                                if (typeof column[i] === 'undefined') {\n                                    column[i] = null;\n                                }\n                            }\n                        });\n                        if (chart && chart.series) {\n                            chart.update({\n                                data: {\n                                    columns: columns\n                                }\n                            });\n                        }\n                        else { // #8245\n                            data.columns = columns;\n                            data.dataFound();\n                        }\n                    });\n                }\n                // This is an intermediate fetch, so always return false.\n                return false;\n            };\n            /**\n             * Trim a string from whitespaces.\n             *\n             * @function Highcharts.Data#trim\n             *\n             * @param {string} str\n             *        String to trim\n             *\n             * @param {boolean} [inside=false]\n             *        Remove all spaces between numbers.\n             *\n             * @return {string}\n             *         Trimed string\n             */\n            Data.prototype.trim = function (str, inside) {\n                if (typeof str === 'string') {\n                    str = str.replace(/^\\s+|\\s+$/g, '');\n                    // Clear white space insdie the string, like thousands separators\n                    if (inside && /^-?[0-9\\s]+$/.test(str)) {\n                        str = str.replace(/\\s/g, '');\n                    }\n                    if (this.decimalRegex) {\n                        str = str.replace(this.decimalRegex, '$1.$2');\n                    }\n                }\n                return str;\n            };\n            /**\n             * Parse numeric cells in to number types and date types in to true dates.\n             *\n             * @function Highcharts.Data#parseTypes\n             */\n            Data.prototype.parseTypes = function () {\n                var columns = this.columns || [];\n                var col = columns.length;\n                while (col--) {\n                    this.parseColumn(columns[col], col);\n                }\n            };\n            /**\n             * Parse a single column. Set properties like .isDatetime and .isNumeric.\n             *\n             * @function Highcharts.Data#parseColumn\n             *\n             * @param {Array<Highcharts.DataValueType>} column\n             *        Column to parse\n             *\n             * @param {number} col\n             *        Column index\n             */\n            Data.prototype.parseColumn = function (column, col) {\n                var rawColumns = this.rawColumns, columns = this.columns, firstRowAsNames = this.firstRowAsNames, isXColumn = this.valueCount.xColumns.indexOf(col) !== -1, backup = [], chartOptions = this.chartOptions, columnTypes = this.options.columnTypes || [], columnType = columnTypes[col], forceCategory = isXColumn && ((chartOptions &&\n                    chartOptions.xAxis &&\n                    splat(chartOptions.xAxis)[0].type === 'category') || columnType === 'string'), columnHasName = defined(column.name);\n                var row = column.length, val, floatVal, trimVal, trimInsideVal, dateVal, diff, descending;\n                if (!rawColumns[col]) {\n                    rawColumns[col] = [];\n                }\n                while (row--) {\n                    val = backup[row] || column[row];\n                    trimVal = this.trim(val);\n                    trimInsideVal = this.trim(val, true);\n                    floatVal = parseFloat(trimInsideVal);\n                    // Set it the first time\n                    if (typeof rawColumns[col][row] === 'undefined') {\n                        rawColumns[col][row] = trimVal;\n                    }\n                    // Disable number or date parsing by setting the X axis type to\n                    // category\n                    if (forceCategory ||\n                        (row === 0 && firstRowAsNames && !columnHasName)) {\n                        column[row] = '' + trimVal;\n                    }\n                    else if (+trimInsideVal === floatVal) { // is numeric\n                        column[row] = floatVal;\n                        // If the number is greater than milliseconds in a year, assume\n                        // datetime\n                        if (floatVal > 365 * 24 * 3600 * 1000 &&\n                            columnType !== 'float') {\n                            column.isDatetime = true;\n                        }\n                        else {\n                            column.isNumeric = true;\n                        }\n                        if (typeof column[row + 1] !== 'undefined') {\n                            descending = floatVal > column[row + 1];\n                        }\n                        // String, continue to determine if it is a date string or really a\n                        // string\n                    }\n                    else {\n                        if (trimVal && trimVal.length) {\n                            dateVal = this.parseDate(val);\n                        }\n                        // Only allow parsing of dates if this column is an x-column\n                        if (isXColumn && isNumber(dateVal) && columnType !== 'float') {\n                            backup[row] = val;\n                            column[row] = dateVal;\n                            column.isDatetime = true;\n                            // Check if the dates are uniformly descending or ascending.\n                            // If they are not, chances are that they are a different\n                            // time format, so check for alternative.\n                            if (typeof column[row + 1] !== 'undefined') {\n                                diff = dateVal > column[row + 1];\n                                if (diff !== descending &&\n                                    typeof descending !== 'undefined') {\n                                    if (this.alternativeFormat) {\n                                        this.dateFormat = this.alternativeFormat;\n                                        row = column.length;\n                                        this.alternativeFormat =\n                                            this.dateFormats[this.dateFormat]\n                                                .alternative;\n                                    }\n                                    else {\n                                        column.unsorted = true;\n                                    }\n                                }\n                                descending = diff;\n                            }\n                        }\n                        else { // string\n                            column[row] = trimVal === '' ? null : trimVal;\n                            if (row !== 0 &&\n                                (column.isDatetime ||\n                                    column.isNumeric)) {\n                                column.mixed = true;\n                            }\n                        }\n                    }\n                }\n                // If strings are intermixed with numbers or dates in a parsed column,\n                // it is an indication that parsing went wrong or the data was not\n                // intended to display as numbers or dates and parsing is too\n                // aggressive. Fall back to categories. Demonstrated in the\n                // highcharts/demo/column-drilldown sample.\n                if (isXColumn && column.mixed) {\n                    columns[col] = rawColumns[col];\n                }\n                // If the 0 column is date or number and descending, reverse all\n                // columns.\n                if (isXColumn && descending && this.options.sort) {\n                    for (col = 0; col < columns.length; col++) {\n                        columns[col].reverse();\n                        if (firstRowAsNames) {\n                            columns[col].unshift(columns[col].pop());\n                        }\n                    }\n                }\n            };\n            /**\n             * Parse a date and return it as a number. Overridable through\n             * `options.parseDate`.\n             *\n             * @function Highcharts.Data#parseDate\n             */\n            Data.prototype.parseDate = function (val) {\n                var parseDate = this.options.parseDate;\n                var ret, key, format, dateFormat = this.options.dateFormat || this.dateFormat, match;\n                if (parseDate) {\n                    ret = parseDate(val);\n                }\n                else if (typeof val === 'string') {\n                    // Auto-detect the date format the first time\n                    if (!dateFormat) {\n                        for (key in this.dateFormats) { // eslint-disable-line guard-for-in\n                            format = this.dateFormats[key];\n                            match = val.match(format.regex);\n                            if (match) {\n                                this.dateFormat = dateFormat = key;\n                                this.alternativeFormat = format.alternative;\n                                ret = format.parser(match);\n                                break;\n                            }\n                        }\n                        // Next time, use the one previously found\n                    }\n                    else {\n                        format = this.dateFormats[dateFormat];\n                        if (!format) {\n                            // The selected format is invalid\n                            format = this.dateFormats['YYYY/mm/dd'];\n                        }\n                        match = val.match(format.regex);\n                        if (match) {\n                            ret = format.parser(match);\n                        }\n                    }\n                    // Fall back to Date.parse\n                    if (!match) {\n                        if (val.match(/:.+(GMT|UTC|[Z+-])/)) {\n                            val = val\n                                .replace(/\\s*(?:GMT|UTC)?([+-])(\\d\\d)(\\d\\d)$/, '$1$2:$3')\n                                .replace(/(?:\\s+|GMT|UTC)([+-])/, '$1')\n                                .replace(/(\\d)\\s*(?:GMT|UTC|Z)$/, '$1+00:00');\n                        }\n                        match = Date.parse(val);\n                        // External tools like Date.js and MooTools extend Date object\n                        // and return a date.\n                        if (typeof match === 'object' &&\n                            match !== null &&\n                            match.getTime) {\n                            ret = (match.getTime() -\n                                match.getTimezoneOffset() *\n                                    60000);\n                            // Timestamp\n                        }\n                        else if (isNumber(match)) {\n                            ret = match - (new Date(match)).getTimezoneOffset() * 60000;\n                        }\n                    }\n                }\n                return ret;\n            };\n            /**\n             * Get the parsed data in a form that we can apply directly to the\n             * `series.data` config. Array positions can be mapped using the\n             * `series.keys` option.\n             *\n             * @example\n             * const data = Highcharts.data({\n             *   csv: document.getElementById('data').innerHTML\n             * }).getData();\n             *\n             * @function Highcharts.Data#getData\n             *\n             * @return {Array<Array<(number|string)>>|undefined} Data rows\n             */\n            Data.prototype.getData = function () {\n                if (this.columns) {\n                    return this.rowsToColumns(this.columns).slice(1);\n                }\n            };\n            /**\n             * A hook for working directly on the parsed columns\n             *\n             * @function Highcharts.Data#parsed\n             */\n            Data.prototype.parsed = function () {\n                if (this.options.parsed) {\n                    return this.options.parsed.call(this, this.columns);\n                }\n            };\n            /**\n             * If a complete callback function is provided in the options, interpret the\n             * columns into a Highcharts options object.\n             *\n             * @function Highcharts.Data#complete\n             */\n            Data.prototype.complete = function () {\n                var columns = this.columns, xColumns = [], options = this.options, allSeriesBuilders = [];\n                var type, series, data, i, j, r, seriesIndex, chartOptions, builder, freeIndexes, typeCol, index;\n                xColumns.length = columns.length;\n                if (options.complete || options.afterComplete) {\n                    // Get the names and shift the top row\n                    if (this.firstRowAsNames) {\n                        for (i = 0; i < columns.length; i++) {\n                            var curCol = columns[i];\n                            if (!defined(curCol.name)) {\n                                curCol.name = pick(curCol.shift(), '').toString();\n                            }\n                        }\n                    }\n                    // Use the next columns for series\n                    series = [];\n                    freeIndexes = getFreeIndexes(columns.length, this.valueCount.seriesBuilders);\n                    // Populate defined series\n                    for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {\n                        builder = this.valueCount.seriesBuilders[seriesIndex];\n                        // If the builder can be populated with remaining columns, then\n                        // add it to allBuilders\n                        if (builder.populateColumns(freeIndexes)) {\n                            allSeriesBuilders.push(builder);\n                        }\n                    }\n                    // Populate dynamic series\n                    while (freeIndexes.length > 0) {\n                        builder = new SeriesBuilder();\n                        builder.addColumnReader(0, 'x');\n                        // Mark index as used (not free)\n                        index = freeIndexes.indexOf(0);\n                        if (index !== -1) {\n                            freeIndexes.splice(index, 1);\n                        }\n                        for (i = 0; i < this.valueCount.global; i++) {\n                            // Create and add a column reader for the next free column\n                            // index\n                            builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i]);\n                        }\n                        // If the builder can be populated with remaining columns, then\n                        // add it to allBuilders\n                        if (builder.populateColumns(freeIndexes)) {\n                            allSeriesBuilders.push(builder);\n                        }\n                    }\n                    // Get the data-type from the first series x column\n                    if (allSeriesBuilders.length > 0 &&\n                        allSeriesBuilders[0].readers.length > 0) {\n                        typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];\n                        if (typeof typeCol !== 'undefined') {\n                            if (typeCol.isDatetime) {\n                                type = 'datetime';\n                            }\n                            else if (!typeCol.isNumeric) {\n                                type = 'category';\n                            }\n                        }\n                    }\n                    // Axis type is category, then the \"x\" column should be called\n                    // \"name\"\n                    if (type === 'category') {\n                        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {\n                            builder = allSeriesBuilders[seriesIndex];\n                            for (r = 0; r < builder.readers.length; r++) {\n                                if (builder.readers[r].configName === 'x') {\n                                    builder.readers[r].configName = 'name';\n                                }\n                            }\n                        }\n                    }\n                    // Read data for all builders\n                    for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {\n                        builder = allSeriesBuilders[seriesIndex];\n                        // Iterate down the cells of each column and add data to the\n                        // series\n                        data = [];\n                        for (j = 0; j < columns[0].length; j++) {\n                            data[j] = builder.read(columns, j);\n                        }\n                        // Add the series\n                        series[seriesIndex] = {\n                            data: data\n                        };\n                        if (builder.name) {\n                            series[seriesIndex].name = builder.name;\n                        }\n                        if (type === 'category') {\n                            series[seriesIndex].turboThreshold = 0;\n                        }\n                    }\n                    // Do the callback\n                    chartOptions = {\n                        series: series\n                    };\n                    if (type) {\n                        chartOptions.xAxis = {\n                            type: type\n                        };\n                        if (type === 'category') {\n                            chartOptions.xAxis.uniqueNames = false;\n                        }\n                    }\n                    if (options.complete) {\n                        options.complete(chartOptions);\n                    }\n                    // The afterComplete hook is used internally to avoid conflict with\n                    // the externally available complete option.\n                    if (options.afterComplete) {\n                        options.afterComplete(chartOptions);\n                    }\n                }\n            };\n            /**\n             * Updates the chart with new data options.\n             *\n             * @function Highcharts.Data#update\n             *\n             * @param {Highcharts.DataOptions} options\n             *\n             * @param {boolean} [redraw=true]\n             */\n            Data.prototype.update = function (options, redraw) {\n                var chart = this.chart, chartOptions = chart.options;\n                if (options) {\n                    // Set the complete handler\n                    options.afterComplete = function (dataOptions) {\n                        // Avoid setting axis options unless the type changes. Running\n                        // Axis.update will cause the whole structure to be destroyed\n                        // and rebuilt, and animation is lost.\n                        if (dataOptions) {\n                            if (dataOptions.xAxis &&\n                                chart.xAxis[0] &&\n                                dataOptions.xAxis.type ===\n                                    chart.xAxis[0].options.type) {\n                                delete dataOptions.xAxis;\n                            }\n                            // @todo looks not right:\n                            chart.update(dataOptions, redraw, true);\n                        }\n                    };\n                    // Apply it\n                    merge(true, chartOptions.data, options);\n                    // Reset columns if fetching spreadsheet, to force a re-fetch\n                    if (chartOptions.data && chartOptions.data.googleSpreadsheetKey &&\n                        !options.columns) {\n                        delete chartOptions.data.columns;\n                    }\n                    this.init(chartOptions.data);\n                }\n            };\n            return Data;\n        }());\n        // Extend Chart.init so that the Chart constructor accepts a new configuration\n        // option group, data.\n        addEvent(Chart, 'init', function (e) {\n            var chart = this, callback = e.args[1], defaultDataOptions = getOptions().data;\n            var userOptions = (e.args[0] || {});\n            if ((defaultDataOptions || userOptions && userOptions.data) &&\n                !chart.hasDataDef) {\n                chart.hasDataDef = true;\n                /**\n                 * The data parser for this chart.\n                 *\n                 * @name Highcharts.Chart#data\n                 * @type {Highcharts.Data|undefined}\n                 */\n                var dataOptions = merge(defaultDataOptions, userOptions.data);\n                chart.data = new Data(extend(dataOptions, {\n                    afterComplete: function (dataOptions) {\n                        var i, series;\n                        // Merge series configs\n                        if (Object.hasOwnProperty.call(userOptions, 'series')) {\n                            if (typeof userOptions.series === 'object') {\n                                i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ?\n                                    dataOptions.series.length :\n                                    0);\n                                while (i--) {\n                                    series = userOptions.series[i] || {};\n                                    userOptions.series[i] = merge(series, dataOptions && dataOptions.series ?\n                                        dataOptions.series[i] :\n                                        {});\n                                }\n                            }\n                            else { // Allow merging in dataOptions.series (#2856)\n                                delete userOptions.series;\n                            }\n                        }\n                        // Do the merge\n                        userOptions = merge(dataOptions, userOptions);\n                        // Run chart.init again\n                        chart.init(userOptions, callback);\n                    }\n                }), userOptions, chart);\n                e.preventDefault();\n            }\n        });\n        /**\n         * Creates a new SeriesBuilder. A SeriesBuilder consists of a number\n         * of ColumnReaders that reads columns and give them a name.\n         * Ex: A series builder can be constructed to read column 3 as 'x' and\n         * column 7 and 8 as 'y1' and 'y2'.\n         * The output would then be points/rows of the form {x: 11, y1: 22, y2: 33}\n         *\n         * The name of the builder is taken from the second column. In the above\n         * example it would be the column with index 7.\n         *\n         * @private\n         * @class\n         * @name SeriesBuilder\n         */\n        var SeriesBuilder = /** @class */ (function () {\n            function SeriesBuilder() {\n                /* eslint-disable no-invalid-this */\n                this.readers = [];\n                this.pointIsArray = true;\n            }\n            /**\n             * Populates readers with column indexes. A reader can be added without\n             * a specific index and for those readers the index is taken sequentially\n             * from the free columns (this is handled by the ColumnCursor instance).\n             *\n             * @function SeriesBuilder#populateColumns\n             */\n            SeriesBuilder.prototype.populateColumns = function (freeIndexes) {\n                var builder = this;\n                var enoughColumns = true;\n                // Loop each reader and give it an index if its missing.\n                // The freeIndexes.shift() will return undefined if there\n                // are no more columns.\n                builder.readers.forEach(function (reader) {\n                    if (typeof reader.columnIndex === 'undefined') {\n                        reader.columnIndex = freeIndexes.shift();\n                    }\n                });\n                // Now, all readers should have columns mapped. If not\n                // then return false to signal that this series should\n                // not be added.\n                builder.readers.forEach(function (reader) {\n                    if (typeof reader.columnIndex === 'undefined') {\n                        enoughColumns = false;\n                    }\n                });\n                return enoughColumns;\n            };\n            /**\n             * Reads a row from the dataset and returns a point or array depending\n             * on the names of the readers.\n             *\n             * @function SeriesBuilder#read<T>\n             */\n            SeriesBuilder.prototype.read = function (columns, rowIndex) {\n                var builder = this, pointIsArray = builder.pointIsArray, point = pointIsArray ? [] : {};\n                // Loop each reader and ask it to read its value.\n                // Then, build an array or point based on the readers names.\n                builder.readers.forEach(function (reader) {\n                    var value = columns[reader.columnIndex][rowIndex];\n                    if (pointIsArray) {\n                        point.push(value);\n                    }\n                    else {\n                        if (reader.configName.indexOf('.') > 0) {\n                            // Handle nested property names\n                            Point.prototype.setNestedProperty(point, value, reader.configName);\n                        }\n                        else {\n                            point[reader.configName] = value;\n                        }\n                    }\n                });\n                // The name comes from the first column (excluding the x column)\n                if (typeof this.name === 'undefined' && builder.readers.length >= 2) {\n                    var columnIndexes_1 = [];\n                    builder.readers.forEach(function (reader) {\n                        if (reader.configName === 'x' ||\n                            reader.configName === 'name' ||\n                            reader.configName === 'y') {\n                            if (typeof reader.columnIndex !== 'undefined') {\n                                columnIndexes_1.push(reader.columnIndex);\n                            }\n                        }\n                    });\n                    if (columnIndexes_1.length >= 2) {\n                        // Remove the first one (x col)\n                        columnIndexes_1.shift();\n                        // Sort the remaining\n                        columnIndexes_1.sort(function (a, b) {\n                            return a - b;\n                        });\n                    }\n                    // Now use the lowest index as name column\n                    this.name = columns[pick(columnIndexes_1.shift(), 0)].name;\n                }\n                return point;\n            };\n            /**\n             * Creates and adds ColumnReader from the given columnIndex and configName.\n             * ColumnIndex can be undefined and in that case the reader will be given\n             * an index when columns are populated.\n             *\n             * @function SeriesBuilder#addColumnReader\n             */\n            SeriesBuilder.prototype.addColumnReader = function (columnIndex, configName) {\n                this.readers.push({\n                    columnIndex: columnIndex,\n                    configName: configName\n                });\n                if (!(configName === 'x' ||\n                    configName === 'y' ||\n                    typeof configName === 'undefined')) {\n                    this.pointIsArray = false;\n                }\n            };\n            /**\n             * Returns an array of column indexes that the builder will use when\n             * reading data.\n             *\n             * @function SeriesBuilder#getReferencedColumnIndexes\n             */\n            SeriesBuilder.prototype.getReferencedColumnIndexes = function () {\n                var referencedColumnIndexes = [];\n                var i, columnReader;\n                for (i = 0; i < this.readers.length; i = i + 1) {\n                    columnReader = this.readers[i];\n                    if (typeof columnReader.columnIndex !== 'undefined') {\n                        referencedColumnIndexes.push(columnReader.columnIndex);\n                    }\n                }\n                return referencedColumnIndexes;\n            };\n            /**\n             * Returns true if the builder has a reader for the given configName.\n             *\n             * @function SeriesBuider#hasReader\n             */\n            SeriesBuilder.prototype.hasReader = function (configName) {\n                var i, columnReader;\n                for (i = 0; i < this.readers.length; i = i + 1) {\n                    columnReader = this.readers[i];\n                    if (columnReader.configName === configName) {\n                        return true;\n                    }\n                }\n                // Else return undefined\n            };\n            return SeriesBuilder;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Callback function to modify the CSV before parsing it by the data module.\n         *\n         * @callback Highcharts.DataBeforeParseCallbackFunction\n         *\n         * @param {string} csv\n         *        The CSV to modify.\n         *\n         * @return {string}\n         *         The CSV to parse.\n         */\n        /**\n         * Callback function that gets called after parsing data.\n         *\n         * @callback Highcharts.DataCompleteCallbackFunction\n         *\n         * @param {Highcharts.Options} chartOptions\n         *        The chart options that were used.\n         */\n        /**\n         * Callback function that returns the correspondig Date object to a match.\n         *\n         * @callback Highcharts.DataDateFormatCallbackFunction\n         *\n         * @param {Array<number>} match\n         *\n         * @return {number}\n         */\n        /**\n         * Structure for alternative date formats to parse.\n         *\n         * @interface Highcharts.DataDateFormatObject\n         */ /**\n        * @name Highcharts.DataDateFormatObject#alternative\n        * @type {string|undefined}\n        */ /**\n        * @name Highcharts.DataDateFormatObject#parser\n        * @type {Highcharts.DataDateFormatCallbackFunction}\n        */ /**\n        * @name Highcharts.DataDateFormatObject#regex\n        * @type {global.RegExp}\n        */\n        /**\n         * Possible types for a data item in a column or row.\n         *\n         * @typedef {number|string|null} Highcharts.DataValueType\n         */\n        /**\n         * Callback function to parse string representations of dates into\n         * JavaScript timestamps (milliseconds since 1.1.1970).\n         *\n         * @callback Highcharts.DataParseDateCallbackFunction\n         *\n         * @param {string} dateValue\n         *\n         * @return {number}\n         *         Timestamp (milliseconds since 1.1.1970) as integer for Date class.\n         */\n        /**\n         * Callback function to access the parsed columns, the two-dimentional\n         * input data array directly, before they are interpreted into series\n         * data and categories.\n         *\n         * @callback Highcharts.DataParsedCallbackFunction\n         *\n         * @param {Array<Array<*>>} columns\n         *        The parsed columns by the data module.\n         *\n         * @return {boolean|undefined}\n         *         Return `false` to stop completion, or call `this.complete()` to\n         *         continue async.\n         */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The Data module provides a simplified interface for adding data to\n         * a chart from sources like CVS, HTML tables or grid views. See also\n         * the [tutorial article on the Data module](\n         * https://www.highcharts.com/docs/working-with-data/data-module).\n         *\n         * It requires the `modules/data.js` file to be loaded.\n         *\n         * Please note that the default way of adding data in Highcharts, without\n         * the need of a module, is through the [series._type_.data](#series.line.data)\n         * option.\n         *\n         * @sample {highcharts} highcharts/demo/column-parsed/\n         *         HTML table\n         * @sample {highcharts} highcharts/data/csv/\n         *         CSV\n         *\n         * @since     4.0\n         * @requires  modules/data\n         * @apioption data\n         */\n        /**\n         * A callback function to modify the CSV before parsing it. Return the modified\n         * string.\n         *\n         * @sample {highcharts} highcharts/demo/line-ajax/\n         *         Modify CSV before parse\n         *\n         * @type      {Highcharts.DataBeforeParseCallbackFunction}\n         * @since     6.1\n         * @apioption data.beforeParse\n         */\n        /**\n         * A two-dimensional array representing the input data on tabular form.\n         * This input can be used when the data is already parsed, for example\n         * from a grid view component. Each cell can be a string or number.\n         * If not switchRowsAndColumns is set, the columns are interpreted as\n         * series.\n         *\n         * @see [data.rows](#data.rows)\n         *\n         * @sample {highcharts} highcharts/data/columns/\n         *         Columns\n         *\n         * @type      {Array<Array<Highcharts.DataValueType>>}\n         * @since     4.0\n         * @apioption data.columns\n         */\n        /**\n         * The callback that is evaluated when the data is finished loading,\n         * optionally from an external source, and parsed. The first argument\n         * passed is a finished chart options object, containing the series.\n         * These options can be extended with additional options and passed\n         * directly to the chart constructor.\n         *\n         * @see [data.parsed](#data.parsed)\n         *\n         * @sample {highcharts} highcharts/data/complete/\n         *         Modify data on complete\n         *\n         * @type      {Highcharts.DataCompleteCallbackFunction}\n         * @since     4.0\n         * @apioption data.complete\n         */\n        /**\n         * A comma delimited string to be parsed. Related options are [startRow](\n         * #data.startRow), [endRow](#data.endRow), [startColumn](#data.startColumn)\n         * and [endColumn](#data.endColumn) to delimit what part of the table\n         * is used. The [lineDelimiter](#data.lineDelimiter) and [itemDelimiter](\n         * #data.itemDelimiter) options define the CSV delimiter formats.\n         *\n         * The built-in CSV parser doesn't support all flavours of CSV, so in\n         * some cases it may be necessary to use an external CSV parser. See\n         * [this example](https://jsfiddle.net/highcharts/u59176h4/) of parsing\n         * CSV through the MIT licensed [Papa Parse](http://papaparse.com/)\n         * library.\n         *\n         * @sample {highcharts} highcharts/data/csv/\n         *         Data from CSV\n         *\n         * @type      {string}\n         * @since     4.0\n         * @apioption data.csv\n         */\n        /**\n         * Which of the predefined date formats in Date.prototype.dateFormats\n         * to use to parse date values. Defaults to a best guess based on what\n         * format gives valid and ordered dates. Valid options include: `YYYY/mm/dd`,\n         * `dd/mm/YYYY`, `mm/dd/YYYY`, `dd/mm/YY`, `mm/dd/YY`.\n         *\n         * @see [data.parseDate](#data.parseDate)\n         *\n         * @sample {highcharts} highcharts/data/dateformat-auto/\n         *         Best guess date format\n         *\n         * @type       {string}\n         * @since      4.0\n         * @validvalue [\"YYYY/mm/dd\", \"dd/mm/YYYY\", \"mm/dd/YYYY\", \"dd/mm/YYYY\",\n         *             \"dd/mm/YY\", \"mm/dd/YY\"]\n         * @apioption  data.dateFormat\n         */\n        /**\n         * The decimal point used for parsing numbers in the CSV.\n         *\n         * If both this and data.delimiter is set to `undefined`, the parser will\n         * attempt to deduce the decimal point automatically.\n         *\n         * @sample {highcharts} highcharts/data/delimiters/\n         *         Comma as decimal point\n         *\n         * @type      {string}\n         * @default   .\n         * @since     4.1.0\n         * @apioption data.decimalPoint\n         */\n        /**\n         * In tabular input data, the last column (indexed by 0) to use. Defaults\n         * to the last column containing data.\n         *\n         * @sample {highcharts} highcharts/data/start-end/\n         *         Limited data\n         *\n         * @type      {number}\n         * @since     4.0\n         * @apioption data.endColumn\n         */\n        /**\n         * In tabular input data, the last row (indexed by 0) to use. Defaults\n         * to the last row containing data.\n         *\n         * @sample {highcharts} highcharts/data/start-end/\n         *         Limited data\n         *\n         * @type      {number}\n         * @since     4.0.4\n         * @apioption data.endRow\n         */\n        /**\n         * Whether to use the first row in the data set as series names.\n         *\n         * @sample {highcharts} highcharts/data/start-end/\n         *         Don't get series names from the CSV\n         * @sample {highstock} highcharts/data/start-end/\n         *         Don't get series names from the CSV\n         *\n         * @type      {boolean}\n         * @default   true\n         * @since     4.1.0\n         * @product   highcharts highstock gantt\n         * @apioption data.firstRowAsNames\n         */\n        /**\n         * The Google Spreadsheet API key required for access generated at [API Services\n         * / Credentials](https://console.cloud.google.com/apis/credentials). See a\n         * comprehensive tutorial for setting up the key at the\n         * [Hands-On Data Visualization](https://handsondataviz.org/google-sheets-api-key.html)\n         * book website.\n         *\n         * @sample {highcharts} highcharts/data/google-spreadsheet/\n         *         Load a Google Spreadsheet\n         *\n         * @type      {string}\n         * @since     9.2.2\n         * @apioption data.googleAPIKey\n         */\n        /**\n         * The key or `spreadsheetId` value for a Google Spreadsheet to load. See\n         * [developers.google.com](https://developers.google.com/sheets/api/guides/concepts)\n         * for how to find the `spreadsheetId`.\n         *\n         * In order for Google Sheets to load, a valid [googleAPIKey](#data.googleAPIKey)\n         * must also be given.\n         *\n         * @sample {highcharts} highcharts/data/google-spreadsheet/\n         *         Load a Google Spreadsheet\n         *\n         * @type      {string}\n         * @since     4.0\n         * @apioption data.googleSpreadsheetKey\n         */\n        /**\n         * The Google Spreadsheet `range` to use in combination with\n         * [googleSpreadsheetKey](#data.googleSpreadsheetKey). See\n         * [developers.google.com](https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/get)\n         * for details.\n         *\n         * If given, it takes precedence over `startColumn`, `endColumn`, `startRow` and\n         * `endRow`.\n         *\n         * @example\n         * googleSpreadsheetRange: 'Fruit Consumption' // Load a named worksheet\n         * googleSpreadsheetRange: 'A:Z' // Load columns A to Z\n         *\n         * @sample {highcharts} highcharts/data/google-spreadsheet/\n         *         Load a Google Spreadsheet\n         *\n         * @type      {string|undefined}\n         * @since     9.2.2\n         * @apioption data.googleSpreadsheetRange\n         */\n        /**\n         * No longer works since v9.2.2, that uses Google Sheets API v4. Instead, use\n         * the [googleSpreadsheetRange](#data.googleSpreadsheetRange) option to load a\n         * specific sheet.\n         *\n         * @deprecated\n         * @type      {string}\n         * @since     4.0\n         * @apioption data.googleSpreadsheetWorksheet\n         */\n        /**\n         * Item or cell delimiter for parsing CSV. Defaults to the tab character\n         * `\\t` if a tab character is found in the CSV string, if not it defaults\n         * to `,`.\n         *\n         * If this is set to false or undefined, the parser will attempt to deduce\n         * the delimiter automatically.\n         *\n         * @sample {highcharts} highcharts/data/delimiters/\n         *         Delimiters\n         *\n         * @type      {string}\n         * @since     4.0\n         * @apioption data.itemDelimiter\n         */\n        /**\n         * Line delimiter for parsing CSV.\n         *\n         * @sample {highcharts} highcharts/data/delimiters/\n         *         Delimiters\n         *\n         * @type      {string}\n         * @default   \\n\n         * @since     4.0\n         * @apioption data.lineDelimiter\n         */\n        /**\n         * A callback function to access the parsed columns, the two-dimentional\n         * input data array directly, before they are interpreted into series\n         * data and categories. Return `false` to stop completion, or call\n         * `this.complete()` to continue async.\n         *\n         * @see [data.complete](#data.complete)\n         *\n         * @sample {highcharts} highcharts/data/parsed/\n         *         Modify data after parse\n         *\n         * @type      {Highcharts.DataParsedCallbackFunction}\n         * @since     4.0\n         * @apioption data.parsed\n         */\n        /**\n         * A callback function to parse string representations of dates into\n         * JavaScript timestamps. Should return an integer timestamp on success.\n         *\n         * @see [dateFormat](#data.dateFormat)\n         *\n         * @type      {Highcharts.DataParseDateCallbackFunction}\n         * @since     4.0\n         * @apioption data.parseDate\n         */\n        /**\n         * The same as the columns input option, but defining rows intead of\n         * columns.\n         *\n         * @see [data.columns](#data.columns)\n         *\n         * @sample {highcharts} highcharts/data/rows/\n         *         Data in rows\n         *\n         * @type      {Array<Array<Highcharts.DataValueType>>}\n         * @since     4.0\n         * @apioption data.rows\n         */\n        /**\n         * An array containing dictionaries for each series. A dictionary exists of\n         * Point property names as the key and the CSV column index as the value.\n         *\n         * @sample {highcharts} highcharts/data/seriesmapping-label/\n         *         Label from data set\n         *\n         * @type      {Array<Highcharts.Dictionary<number>>}\n         * @since     4.0.4\n         * @apioption data.seriesMapping\n         */\n        /**\n         * In tabular input data, the first column (indexed by 0) to use.\n         *\n         * @sample {highcharts} highcharts/data/start-end/\n         *         Limited data\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.0\n         * @apioption data.startColumn\n         */\n        /**\n         * In tabular input data, the first row (indexed by 0) to use.\n         *\n         * @sample {highcharts} highcharts/data/start-end/\n         *         Limited data\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.0\n         * @apioption data.startRow\n         */\n        /**\n         * Switch rows and columns of the input data, so that `this.columns`\n         * effectively becomes the rows of the data set, and the rows are interpreted\n         * as series.\n         *\n         * @sample {highcharts} highcharts/data/switchrowsandcolumns/\n         *         Switch rows and columns\n         *\n         * @type      {boolean}\n         * @default   false\n         * @since     4.0\n         * @apioption data.switchRowsAndColumns\n         */\n        /**\n         * An HTML table or the id of such to be parsed as input data. Related\n         * options are `startRow`, `endRow`, `startColumn` and `endColumn` to\n         * delimit what part of the table is used.\n         *\n         * @sample {highcharts} highcharts/demo/column-parsed/\n         *         Parsed table\n         *\n         * @type      {string|global.HTMLElement}\n         * @since     4.0\n         * @apioption data.table\n         */\n        /**\n         * An URL to a remote CSV dataset. Will be fetched when the chart is created\n         * using Ajax.\n         *\n         * @sample highcharts/data/livedata-columns\n         *         Categorized bar chart with CSV and live polling\n         * @sample highcharts/data/livedata-csv\n         *         Time based line chart with CSV and live polling\n         *\n         * @type      {string}\n         * @apioption data.csvURL\n         */\n        /**\n         * A URL to a remote JSON dataset, structured as a row array.\n         * Will be fetched when the chart is created using Ajax.\n         *\n         * @sample highcharts/data/livedata-rows\n         *         Rows with live polling\n         *\n         * @type      {string}\n         * @apioption data.rowsURL\n         */\n        /**\n         * A URL to a remote JSON dataset, structured as a column array.\n         * Will be fetched when the chart is created using Ajax.\n         *\n         * @sample highcharts/data/livedata-columns\n         *         Columns with live polling\n         *\n         * @type      {string}\n         * @apioption data.columnsURL\n         */\n        /**\n         * Sets the refresh rate for data polling when importing remote dataset by\n         * setting [data.csvURL](data.csvURL), [data.rowsURL](data.rowsURL),\n         * [data.columnsURL](data.columnsURL), or\n         * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).\n         *\n         * Note that polling must be enabled by setting\n         * [data.enablePolling](data.enablePolling) to true.\n         *\n         * The value is the number of seconds between pollings.\n         * It cannot be set to less than 1 second.\n         *\n         * @sample highcharts/demo/live-data\n         *         Live data with user set refresh rate\n         *\n         * @default   1\n         * @type      {number}\n         * @apioption data.dataRefreshRate\n         */\n        /**\n         * Enables automatic refetching of remote datasets every _n_ seconds (defined by\n         * setting [data.dataRefreshRate](data.dataRefreshRate)).\n         *\n         * Only works when either [data.csvURL](data.csvURL),\n         * [data.rowsURL](data.rowsURL), [data.columnsURL](data.columnsURL), or\n         * [data.googleSpreadsheetKey](data.googleSpreadsheetKey).\n         *\n         * @sample highcharts/demo/live-data\n         *         Live data\n         * @sample highcharts/data/livedata-columns\n         *         Categorized bar chart with CSV and live polling\n         *\n         * @type      {boolean}\n         * @default   false\n         * @apioption data.enablePolling\n         */\n        (''); // keeps doclets above in JS file\n\n        return Data;\n    });\n    _registerModule(_modules, 'masters/modules/data.src.js', [_modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Extensions/Data.js']], function (Highcharts, HttpUtilities, Data) {\n\n        var G = Highcharts;\n        // Functions\n        G.ajax = HttpUtilities.ajax;\n        G.data = Data.data;\n        G.getJSON = HttpUtilities.getJSON;\n        G.post = HttpUtilities.post;\n        // Classes\n        G.Data = Data;\n        G.HttpUtilities = HttpUtilities;\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","G","U","doc","createElement","discardElement","merge","objectEach","HttpUtilities","ajax","settings","headers","json","xml","text","octet","r","XMLHttpRequest","handleError","xhr","err","error","url","open","type","toUpperCase","setRequestHeader","dataType","val","key","responseType","onreadystatechange","res","readyState","status","responseText","JSON","parse","e","Error","success","data","stringify","send","getJSON","post","formAttributes","form","method","action","enctype","display","body","name","value","submit","Chart","D","HU","Point","SeriesRegistry","getOptions","seriesTypes","addEvent","defined","extend","fireEvent","isNumber","pick","splat","hasURLOption","options","Boolean","rowsURL","csvURL","columnsURL","Data","dataOptions","chartOptions","chart","rowsToColumns","dateFormats","regex","parser","match","Date","UTC","NaN","alternative","d","year","getFullYear","rawColumns","init","rows","row","rowsLength","col","colsLength","columns","length","prototype","hasData","decimalPoint","firstRowAsNames","decimalRegex","RegExp","liveDataTimeout","clearTimeout","dataFound","fetchLiveData","parseCSV","parseTable","parseGoogleSpreadsheet","afterComplete","getColumnDistribution","i","xColumns","getValueCount","pointArrayMap","getPointArrayMap","globalType","individualCounts","seriesBuilders","seriesMapping","series","map","x","seriesIndex","forEach","push","mapping","builder","SeriesBuilder","numberOfValueColumnsNeeded","seriesArr","defaultPointArrayMap","isCartesian","addColumnReader","hasReader","globalPointArrayMap","valueCount","global","individual","switchRowsAndColumns","parseTypes","parsed","complete","inOptions","points","commas","guessed","itemDelimiter","lines","self","startColumn","endColumn","Number","MAX_VALUE","dataTypes","potDelimiters","csv","startRow","endRow","rowIt","beforeParse","call","replace","split","lineDelimiter","some","columnStr","c","cn","cl","inStr","token","j","isNaN","trim","isFinite","offset","parseRow","rowNumber","noAdd","callbacks","actualColumn","column","read","pushType","parseFloat","columnTypes","dateFormat","deduceDateFormat","limit","thing","calculatedFormat","format","stable","max","guessedFormat","madeDeduction","parseInt","join","table","getElementById","getElementsByTagName","tr","rowNo","children","item","colNo","tagName","innerHTML","pollingEnabled","enablePolling","originalOptions","currentRetries","updateIntervalMs","dataRefreshRate","performFetch","initialFetch","request","done","tp","test","poll","liveDataURL","setTimeout","update","googleSpreadsheetKey","refreshRate","Math","getRange","googleSpreadsheetRange","alphabet","start","charAt","end","concat","fetchSheet","googleAPIKey","values","rowCount","reduce","str","inside","parseColumn","floatVal","trimVal","trimInsideVal","dateVal","diff","descending","isXColumn","indexOf","backup","columnType","forceCategory","xAxis","columnHasName","isDatetime","isNumeric","parseDate","alternativeFormat","unsorted","mixed","sort","reverse","unshift","pop","ret","getTime","getTimezoneOffset","getData","slice","freeIndexes","typeCol","index","allSeriesBuilders","curCol","shift","toString","getFreeIndexes","numberOfColumns","s","referencedIndexes","freeIndexValues","getReferencedColumnIndexes","populateColumns","splice","readers","columnIndex","configName","turboThreshold","uniqueNames","redraw","callback","defaultDataOptions","userOptions","hasDataDef","Object","preventDefault","pointIsArray","enoughColumns","reader","rowIndex","point","setNestedProperty","columnIndexes_1","a","b","columnReader","referencedColumnIndexes"],"mappings":"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"}