{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2021 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/marker-clusters', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterDefaults.js', [], function () {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Options for marker clusters, the concept of sampling the data\n         * values into larger blocks in order to ease readability and\n         * increase performance of the JavaScript charts.\n         *\n         * Note: marker clusters module is not working with `boost`\n         * and `draggable-points` modules.\n         *\n         * The marker clusters feature requires the marker-clusters.js\n         * file to be loaded, found in the modules directory of the download\n         * package, or online at [code.highcharts.com/modules/marker-clusters.js\n         * ](code.highcharts.com/modules/marker-clusters.js).\n         *\n         * @sample maps/marker-clusters/europe\n         *         Maps marker clusters\n         * @sample highcharts/marker-clusters/basic\n         *         Scatter marker clusters\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Marker clusters with colorAxis\n         *\n         * @product      highcharts highmaps\n         * @since 8.0.0\n         * @optionparent plotOptions.scatter.cluster\n         *\n         * @private\n         */\n        var cluster = {\n            /**\n             * Whether to enable the marker-clusters module.\n             *\n             * @sample maps/marker-clusters/basic\n             *         Maps marker clusters\n             * @sample highcharts/marker-clusters/basic\n             *         Scatter marker clusters\n             */\n            enabled: false,\n            /**\n             * When set to `false` prevent cluster overlapping - this option\n             * works only when `layoutAlgorithm.type = \"grid\"`.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Prevent overlapping\n             */\n            allowOverlap: true,\n            /**\n             * Options for the cluster marker animation.\n             * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n             * @default { \"duration\": 500 }\n             */\n            animation: {\n                /** @ignore-option */\n                duration: 500\n            },\n            /**\n             * Zoom the plot area to the cluster points range when a cluster is clicked.\n             */\n            drillToCluster: true,\n            /**\n             * The minimum amount of points to be combined into a cluster.\n             * This value has to be greater or equal to 2.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         At least three points in the cluster\n             */\n            minimumClusterSize: 2,\n            /**\n             * Options for layout algorithm. Inside there\n             * are options to change the type of the algorithm, gridSize,\n             * distance or iterations.\n             */\n            layoutAlgorithm: {\n                /**\n                 * Type of the algorithm used to combine points into a cluster.\n                 * There are three available algorithms:\n                 *\n                 * 1) `grid` - grid-based clustering technique. Points are assigned\n                 * to squares of set size depending on their position on the plot\n                 * area. Points inside the grid square are combined into a cluster.\n                 * The grid size can be controlled by `gridSize` property\n                 * (grid size changes at certain zoom levels).\n                 *\n                 * 2) `kmeans` - based on K-Means clustering technique. In the\n                 * first step, points are divided using the grid method (distance\n                 * property is a grid size) to find the initial amount of clusters.\n                 * Next, each point is classified by computing the distance between\n                 * each cluster center and that point. When the closest cluster\n                 * distance is lower than distance property set by a user the point\n                 * is added to this cluster otherwise is classified as `noise`. The\n                 * algorithm is repeated until each cluster center not change its\n                 * previous position more than one pixel. This technique is more\n                 * accurate but also more time consuming than the `grid` algorithm,\n                 * especially for big datasets.\n                 *\n                 * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n                 * algorithm uses k-means algorithm only on the chart initialization\n                 * or when chart extremes have greater range than on initialization.\n                 * When a chart is redrawn the algorithm checks only clustered points\n                 * distance from the cluster center and rebuild it when the point is\n                 * spaced enough to be outside the cluster. It provides performance\n                 * improvement and more stable clusters position yet can be used rather\n                 * on small and sparse datasets.\n                 *\n                 * By default, the algorithm depends on visible quantity of points\n                 * and `kmeansThreshold`. When there are more visible points than the\n                 * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n                 *\n                 * The custom clustering algorithm can be added by assigning a callback\n                 * function as the type property. This function takes an array of\n                 * `processedXData`, `processedYData`, `processedXData` indexes and\n                 * `layoutAlgorithm` options as arguments and should return an object\n                 * with grouped data.\n                 *\n                 * The algorithm should return an object like that:\n                 * <pre>{\n                 *  clusterId1: [{\n                 *      x: 573,\n                 *      y: 285,\n                 *      index: 1 // point index in the data array\n                 *  }, {\n                 *      x: 521,\n                 *      y: 197,\n                 *      index: 2\n                 *  }],\n                 *  clusterId2: [{\n                 *      ...\n                 *  }]\n                 *  ...\n                 * }</pre>\n                 *\n                 * `clusterId` (example above - unique id of a cluster or noise)\n                 * is an array of points belonging to a cluster. If the\n                 * array has only one point or fewer points than set in\n                 * `cluster.minimumClusterSize` it won't be combined into a cluster.\n                 *\n                 * @sample maps/marker-clusters/optimized-kmeans\n                 *         Optimized K-Means algorithm\n                 * @sample highcharts/marker-clusters/kmeans\n                 *         K-Means algorithm\n                 * @sample highcharts/marker-clusters/grid\n                 *         Grid algorithm\n                 * @sample maps/marker-clusters/custom-alg\n                 *         Custom algorithm\n                 *\n                 * @type {string|Function}\n                 * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n                 */\n                /**\n                 * When `type` is set to the `grid`,\n                 * `gridSize` is a size of a grid square element either as a number\n                 * defining pixels, or a percentage defining a percentage\n                 * of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                gridSize: 50,\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `iterations` are the number of iterations that this algorithm will be\n                 * repeated to find clusters positions.\n                 *\n                 * @type    {number}\n                 * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n                 */\n                /**\n                 * When `type` is set to `kmeans`,\n                 * `distance` is a maximum distance between point and cluster center\n                 * so that this point will be inside the cluster. The distance\n                 * is either a number defining pixels or a percentage\n                 * defining a percentage of the plot area width.\n                 *\n                 * @type    {number|string}\n                 */\n                distance: 40,\n                /**\n                 * When `type` is set to `undefined` and there are more visible points\n                 * than the kmeansThreshold the `grid` algorithm is used to find\n                 * clusters, otherwise `kmeans`. It ensures good performance on\n                 * large datasets and better clusters arrangement after the zoom.\n                 */\n                kmeansThreshold: 100\n            },\n            /**\n             * Options for the cluster marker.\n             * @type      {Highcharts.PointMarkerOptionsObject}\n             * @extends   plotOptions.series.marker\n             * @excluding enabledThreshold, states\n             */\n            marker: {\n                /** @internal */\n                symbol: 'cluster',\n                /** @internal */\n                radius: 15,\n                /** @internal */\n                lineWidth: 0,\n                /** @internal */\n                lineColor: \"#ffffff\" /* Palette.backgroundColor */\n            },\n            /**\n             * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n             * One parameter, `event`, is passed to the function. The default action\n             * is to zoom to the cluster points range. This can be prevented\n             * by calling `event.preventDefault()`.\n             *\n             * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n             * @product   highcharts highmaps\n             * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n             * @apioption plotOptions.scatter.cluster.events.drillToCluster\n             */\n            /**\n             * An array defining zones within marker clusters.\n             *\n             * In styled mode, the color zones are styled with the\n             * `.highcharts-cluster-zone-{n}` class, or custom\n             * classed from the `className`\n             * option.\n             *\n             * @sample highcharts/marker-clusters/basic\n             *         Marker clusters zones\n             * @sample maps/marker-clusters/custom-alg\n             *         Zones on maps\n             *\n             * @type      {Array<*>}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones\n             */\n            /**\n             * Styled mode only. A custom class name for the zone.\n             *\n             * @sample highcharts/css/color-zones/\n             *         Zones styled by class name\n             *\n             * @type      {string}\n             * @apioption plotOptions.scatter.cluster.zones.className\n             */\n            /**\n             * Settings for the cluster marker belonging to the zone.\n             *\n             * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n             * @extends   plotOptions.scatter.cluster.marker\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.marker\n             */\n            /**\n             * The value where the zone starts.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.from\n             */\n            /**\n             * The value where the zone ends.\n             *\n             * @type      {number}\n             * @product   highcharts highmaps\n             * @apioption plotOptions.scatter.cluster.zones.to\n             */\n            /**\n             * The fill color of the cluster marker in hover state. When\n             * `undefined`, the series' or point's fillColor for normal\n             * state is used.\n             *\n             * @type      {Highcharts.ColorType}\n             * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n             */\n            /**\n             * Options for the cluster data labels.\n             * @type    {Highcharts.DataLabelsOptions}\n             */\n            dataLabels: {\n                /** @internal */\n                enabled: true,\n                /** @internal */\n                format: '{point.clusterPointsAmount}',\n                /** @internal */\n                verticalAlign: 'middle',\n                /** @internal */\n                align: 'center',\n                /** @internal */\n                style: {\n                    color: 'contrast'\n                },\n                /** @internal */\n                inside: true\n            }\n        };\n        var tooltip = {\n            /**\n             * The HTML of the cluster point's in the tooltip. Works only with\n             * marker-clusters module and analogously to\n             * [pointFormat](#tooltip.pointFormat).\n             *\n             * The cluster tooltip can be also formatted using\n             * `tooltip.formatter` callback function and `point.isCluster` flag.\n             *\n             * @sample highcharts/marker-clusters/grid\n             *         Format tooltip for cluster points.\n             *\n             * @sample maps/marker-clusters/europe/\n             *         Format tooltip for clusters using tooltip.formatter\n             *\n             * @type      {string}\n             * @default   Clustered points: {point.clusterPointsAmount}\n             * @apioption tooltip.clusterFormat\n             */\n            clusterFormat: '<span>Clustered points: ' +\n                '{point.clusterPointsAmount}</span><br/>'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterDefaults = {\n            cluster: cluster,\n            tooltip: tooltip\n        };\n\n        return MarkerClusterDefaults;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterScatter.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Core/Utilities.js']], function (A, MarkerClusterDefaults, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var animObject = A.animObject;\n        var clusterDefaults = MarkerClusterDefaults.cluster;\n        var addEvent = U.addEvent, defined = U.defined, error = U.error, isArray = U.isArray, isFunction = U.isFunction, isObject = U.isObject, isNumber = U.isNumber, merge = U.merge, objectEach = U.objectEach, pushUnique = U.pushUnique, relativeLength = U.relativeLength, syncTimeout = U.syncTimeout;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedMembers = [];\n        var markerClusterAlgorithms = {\n            grid: function (dataX, dataY, dataIndexes, options) {\n                var series = this, grid = {}, gridOffset = this.getGridOffset();\n                var x, y, gridX, gridY, key, i;\n                // drawGridLines(series, options);\n                var scaledGridSize = series.getScaledGridSize(options);\n                for (i = 0; i < dataX.length; i++) {\n                    var p = valuesToPixels(series, { x: dataX[i], y: dataY[i] });\n                    x = p.x - gridOffset.plotLeft;\n                    y = p.y - gridOffset.plotTop;\n                    gridX = Math.floor(x / scaledGridSize);\n                    gridY = Math.floor(y / scaledGridSize);\n                    key = gridY + '-' + gridX;\n                    if (!grid[key]) {\n                        grid[key] = [];\n                    }\n                    grid[key].push({\n                        dataIndex: dataIndexes[i],\n                        x: dataX[i],\n                        y: dataY[i]\n                    });\n                }\n                return grid;\n            },\n            kmeans: function (dataX, dataY, dataIndexes, options) {\n                var series = this, clusters = [], noise = [], group = {}, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.distance, iterations = options.iterations, \n                // Max pixel difference beetwen new and old cluster position.\n                maxClusterShift = 1;\n                var currentIteration = 0, repeat = true, pointX = 0, pointY = 0, tempPos, pointClusterDistance = [];\n                options.processedGridSize = options.processedDistance;\n                // Use grid method to get groupedData object.\n                var groupedData = series.markerClusterAlgorithms ?\n                    series.markerClusterAlgorithms.grid.call(series, dataX, dataY, dataIndexes, options) : {};\n                // Find clusters amount and its start positions\n                // based on grid grouped data.\n                for (var key in groupedData) {\n                    if (groupedData[key].length > 1) {\n                        tempPos = getClusterPosition(groupedData[key]);\n                        clusters.push({\n                            posX: tempPos.x,\n                            posY: tempPos.y,\n                            oldX: 0,\n                            oldY: 0,\n                            startPointsLen: groupedData[key].length,\n                            points: []\n                        });\n                    }\n                }\n                // Start kmeans iteration process.\n                while (repeat) {\n                    for (var _i = 0, clusters_1 = clusters; _i < clusters_1.length; _i++) {\n                        var c = clusters_1[_i];\n                        c.points.length = 0;\n                    }\n                    noise.length = 0;\n                    for (var i = 0; i < dataX.length; i++) {\n                        pointX = dataX[i];\n                        pointY = dataY[i];\n                        pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                        if (pointClusterDistance.length &&\n                            pointClusterDistance[0].distance < pointMaxDistance) {\n                            clusters[pointClusterDistance[0].clusterIndex].points.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                        else {\n                            noise.push({\n                                x: pointX,\n                                y: pointY,\n                                dataIndex: dataIndexes[i]\n                            });\n                        }\n                    }\n                    // When cluster points array has only one point the\n                    // point should be classified again.\n                    for (var i = 0; i < clusters.length; i++) {\n                        if (clusters[i].points.length === 1) {\n                            pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                            if (pointClusterDistance[1].distance < pointMaxDistance) {\n                                // Add point to the next closest cluster.\n                                clusters[pointClusterDistance[1].clusterIndex].points\n                                    .push(clusters[i].points[0]);\n                                // Clear points array.\n                                clusters[pointClusterDistance[0].clusterIndex]\n                                    .points.length = 0;\n                            }\n                        }\n                    }\n                    // Compute a new clusters position and check if it\n                    // is different than the old one.\n                    repeat = false;\n                    for (var i = 0; i < clusters.length; i++) {\n                        tempPos = getClusterPosition(clusters[i].points);\n                        clusters[i].oldX = clusters[i].posX;\n                        clusters[i].oldY = clusters[i].posY;\n                        clusters[i].posX = tempPos.x;\n                        clusters[i].posY = tempPos.y;\n                        // Repeat the algorithm if at least one cluster\n                        // is shifted more than maxClusterShift property.\n                        if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                            clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                            clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                            clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                            repeat = true;\n                        }\n                    }\n                    // If iterations property is set repeat the algorithm\n                    // specified amount of times.\n                    if (iterations) {\n                        repeat = currentIteration < iterations - 1;\n                    }\n                    currentIteration++;\n                }\n                for (var i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n                    group['cluster' + i] = clusters[i].points;\n                }\n                for (var i = 0, iEnd = noise.length; i < iEnd; ++i) {\n                    group['noise' + i] = [noise[i]];\n                }\n                return group;\n            },\n            optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n                var series = this, pointMaxDistance = options.processedDistance ||\n                    clusterDefaults.layoutAlgorithm.gridSize, extremes = series.getRealExtremes(), clusterMarkerOptions = (series.options.cluster || {}).marker;\n                var distance, group = {}, offset, radius;\n                if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n                    series.initMinX && series.initMinX > extremes.minX ||\n                    series.initMaxY && series.initMaxY < extremes.maxY ||\n                    series.initMinY && series.initMinY > extremes.minY)) {\n                    series.initMaxX = extremes.maxX;\n                    series.initMinX = extremes.minX;\n                    series.initMaxY = extremes.maxY;\n                    series.initMinY = extremes.minY;\n                    group = series.markerClusterAlgorithms ?\n                        series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n                    series.baseClusters = null;\n                }\n                else {\n                    if (!series.baseClusters) {\n                        series.baseClusters = {\n                            clusters: series.markerClusterInfo.clusters,\n                            noise: series.markerClusterInfo.noise\n                        };\n                    }\n                    for (var _i = 0, _a = series.baseClusters.clusters; _i < _a.length; _i++) {\n                        var cluster = _a[_i];\n                        cluster.pointsOutside = [];\n                        cluster.pointsInside = [];\n                        for (var _b = 0, _c = cluster.data; _b < _c.length; _b++) {\n                            var dataPoint = _c[_b];\n                            var dataPointPx = valuesToPixels(series, dataPoint), clusterPx = valuesToPixels(series, cluster);\n                            distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                                Math.pow(dataPointPx.y - clusterPx.y, 2));\n                            if (cluster.clusterZone &&\n                                cluster.clusterZone.marker &&\n                                cluster.clusterZone.marker.radius) {\n                                radius = cluster.clusterZone.marker.radius;\n                            }\n                            else if (clusterMarkerOptions &&\n                                clusterMarkerOptions.radius) {\n                                radius = clusterMarkerOptions.radius;\n                            }\n                            else {\n                                radius = clusterDefaults.marker.radius;\n                            }\n                            offset = pointMaxDistance - radius >= 0 ?\n                                pointMaxDistance - radius : radius;\n                            if (distance > radius + offset &&\n                                defined(cluster.pointsOutside)) {\n                                cluster.pointsOutside.push(dataPoint);\n                            }\n                            else if (defined(cluster.pointsInside)) {\n                                cluster.pointsInside.push(dataPoint);\n                            }\n                        }\n                        if (cluster.pointsInside.length) {\n                            group[cluster.id] = cluster.pointsInside;\n                        }\n                        var i = 0;\n                        for (var _d = 0, _e = cluster.pointsOutside; _d < _e.length; _d++) {\n                            var p = _e[_d];\n                            group[cluster.id + '_noise' + i++] = [p];\n                        }\n                    }\n                    for (var _f = 0, _g = series.baseClusters.noise; _f < _g.length; _f++) {\n                        var noise = _g[_f];\n                        group[noise.id] = noise.data;\n                    }\n                }\n                return group;\n            }\n        };\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        var baseGeneratePoints;\n        /**\n         * Points that ids are included in the oldPointsStateId array are hidden before\n         * animation. Other ones are destroyed.\n         * @private\n         */\n        var oldPointsStateId = [];\n        var stateIdCounter = 0;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(highchartsDefaultOptions, ScatterSeriesClass) {\n            if (pushUnique(composedMembers, ScatterSeriesClass)) {\n                var scatterProto = ScatterSeriesClass.prototype;\n                baseGeneratePoints = scatterProto.generatePoints;\n                scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n                scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n                scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n                scatterProto.generatePoints = seriesGeneratePoints;\n                scatterProto.getClusterDistancesFromPoint =\n                    seriesGetClusterDistancesFromPoint;\n                scatterProto.getClusteredData = seriesGetClusteredData;\n                scatterProto.getGridOffset = seriesGetGridOffset;\n                scatterProto.getPointsState = seriesGetPointsState;\n                scatterProto.getRealExtremes = seriesGetRealExtremes;\n                scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n                scatterProto.hideClusteredData = seriesHideClusteredData;\n                scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n                scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n                // Destroy grouped data on series destroy.\n                addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n            }\n            if (pushUnique(composedMembers, highchartsDefaultOptions)) {\n                (highchartsDefaultOptions.plotOptions || {}).series = merge((highchartsDefaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function destroyOldPoints(oldState) {\n            if (oldState) {\n                var state = void 0;\n                for (var _i = 0, _a = Object.keys(oldState); _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    state = oldState[key];\n                    if (state.point && state.point.destroy) {\n                        state.point.destroy();\n                    }\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInElement(elem, opacity, animation) {\n            elem\n                .attr({\n                opacity: opacity\n            })\n                .animate({\n                opacity: 1\n            }, animation);\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n            // Fade in new point.\n            fadeInStatePoint(newPointObj, opacity, animation, true, true);\n            // Destroy old animated points.\n            for (var _i = 0, oldPoints_1 = oldPoints; _i < oldPoints_1.length; _i++) {\n                var p = oldPoints_1[_i];\n                if (p.point && p.point.destroy) {\n                    p.point.destroy();\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n            if (stateObj.point) {\n                if (fadeinGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.show();\n                    fadeInElement(stateObj.point.graphic, opacity, animation);\n                }\n                if (fadeinDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.show();\n                    fadeInElement(stateObj.point.dataLabel, opacity, animation);\n                }\n            }\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function getClusterPosition(points) {\n            var pointsLen = points.length;\n            var sumX = 0, sumY = 0;\n            for (var i = 0; i < pointsLen; i++) {\n                sumX += points[i].x;\n                sumY += points[i].y;\n            }\n            return {\n                x: sumX / pointsLen,\n                y: sumY / pointsLen\n            };\n        }\n        /**\n         * Util function.Prepare array with sorted data objects to be compared in\n         * getPointsState method.\n         * @private\n         */\n        function getDataState(clusteredData, stateDataLen) {\n            var state = [];\n            state.length = stateDataLen;\n            clusteredData.clusters.forEach(function (cluster) {\n                cluster.data.forEach(function (elem) {\n                    state[elem.dataIndex] = elem;\n                });\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.data[0].dataIndex] = noise.data[0];\n            });\n            return state;\n        }\n        /**\n         * Util function. Generate unique stateId for a state element.\n         * @private\n         */\n        function getStateId() {\n            return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n            if (stateObj.point) {\n                if (hideGraphic && stateObj.point.graphic) {\n                    stateObj.point.graphic.hide();\n                }\n                if (hideDataLabel && stateObj.point.dataLabel) {\n                    stateObj.point.dataLabel.hide();\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            var point = event.point || event.target;\n            point.firePointEvent('drillToCluster', event, function (e) {\n                var point = e.point || e.target, series = point.series, xAxis = point.series.xAxis, yAxis = point.series.yAxis, chart = point.series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, drillToCluster = (clusterOptions || {}).drillToCluster;\n                if (drillToCluster && point.clusteredData) {\n                    var sortedDataX = point.clusteredData\n                        .map(function (data) { return data.x; })\n                        .sort(function (a, b) { return a - b; }), sortedDataY = point.clusteredData\n                        .map(function (data) { return data.y; })\n                        .sort(function (a, b) { return a - b; }), minX = sortedDataX[0], maxX = sortedDataX[sortedDataX.length - 1], minY = sortedDataY[0], maxY = sortedDataY[sortedDataY.length - 1], offsetX = Math.abs((maxX - minX) * 0.1), offsetY = Math.abs((maxY - minY) * 0.1), x1 = Math.min(minX, maxX) - offsetX, x2 = Math.max(minX, maxX) + offsetX, y1 = Math.min(minY, maxY) - offsetY, y2 = Math.max(minY, maxY) + offsetY;\n                    if (mapView) {\n                        mapView.fitToBounds({ x1: x1, x2: x2, y1: y1, y2: y2 });\n                    }\n                    else if (xAxis && yAxis) {\n                        chart.pointer.zoomX = true;\n                        chart.pointer.zoomY = true;\n                        chart.zoom({\n                            originalEvent: e,\n                            xAxis: [{\n                                    axis: xAxis,\n                                    min: x1,\n                                    max: x2\n                                }],\n                            yAxis: [{\n                                    axis: yAxis,\n                                    min: y1,\n                                    max: y2\n                                }]\n                        });\n                    }\n                }\n            });\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function pixelsToValues(series, pos) {\n            var chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            if (chart.mapView) {\n                return chart.mapView.pixelsToProjectedUnits(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toValue(pos.x) : 0,\n                y: yAxis ? yAxis.toValue(pos.y) : 0\n            };\n        }\n        /** @private */\n        function seriesAnimateClusterPoint(clusterObj) {\n            var series = this, chart = series.chart, mapView = chart.mapView, clusterOptions = series.options.cluster, animation = animObject((clusterOptions || {}).animation), animDuration = animation.duration || 500, pointsState = (series.markerClusterInfo || {}).pointsState, newState = (pointsState || {}).newState, oldState = (pointsState || {}).oldState, oldPoints = [];\n            var parentId, oldPointObj, newPointObj, newPointBBox, offset = 0, newX = 0, newY = 0, isOldPointGrahic = false, isCbHandled = false;\n            if (oldState && newState) {\n                newPointObj = newState[clusterObj.stateId];\n                var newPos = valuesToPixels(series, newPointObj);\n                newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n                newY = newPos.y - (mapView ? 0 : chart.plotTop);\n                // Point has one ancestor.\n                if (newPointObj.parentsId.length === 1) {\n                    parentId = (newState || {})[clusterObj.stateId].parentsId[0];\n                    oldPointObj = oldState[parentId];\n                    // If old and new poistions are the same do not animate.\n                    if (newPointObj.point &&\n                        newPointObj.point.graphic &&\n                        oldPointObj &&\n                        oldPointObj.point &&\n                        oldPointObj.point.plotX &&\n                        oldPointObj.point.plotY &&\n                        oldPointObj.point.plotX !== newPointObj.point.plotX &&\n                        oldPointObj.point.plotY !== newPointObj.point.plotY) {\n                        newPointBBox = newPointObj.point.graphic.getBBox();\n                        // Marker image does not have the offset (#14342).\n                        offset = (newPointObj.point.graphic &&\n                            newPointObj.point.graphic.isImg) ?\n                            0 : newPointBBox.width / 2;\n                        newPointObj.point.graphic.attr({\n                            x: oldPointObj.point.plotX - offset,\n                            y: oldPointObj.point.plotY - offset\n                        });\n                        newPointObj.point.graphic.animate({\n                            x: newX - (newPointObj.point.graphic.radius || 0),\n                            y: newY - (newPointObj.point.graphic.radius || 0)\n                        }, animation, function () {\n                            isCbHandled = true;\n                            // Destroy old point.\n                            if (oldPointObj.point && oldPointObj.point.destroy) {\n                                oldPointObj.point.destroy();\n                            }\n                        });\n                        // Data label animation.\n                        if (newPointObj.point.dataLabel &&\n                            newPointObj.point.dataLabel.alignAttr &&\n                            oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.alignAttr) {\n                            newPointObj.point.dataLabel.attr({\n                                x: oldPointObj.point.dataLabel.alignAttr.x,\n                                y: oldPointObj.point.dataLabel.alignAttr.y\n                            });\n                            newPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y\n                            }, animation);\n                        }\n                    }\n                }\n                else if (newPointObj.parentsId.length === 0) {\n                    // Point has no ancestors - new point.\n                    // Hide new point.\n                    hideStatePoint(newPointObj, true, true);\n                    syncTimeout(function () {\n                        // Fade in new point.\n                        fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n                    }, animDuration / 2);\n                }\n                else {\n                    // Point has many ancestors.\n                    // Hide new point before animation.\n                    hideStatePoint(newPointObj, true, true);\n                    newPointObj.parentsId.forEach(function (elem) {\n                        if (oldState && oldState[elem]) {\n                            oldPointObj = oldState[elem];\n                            oldPoints.push(oldPointObj);\n                            if (oldPointObj.point &&\n                                oldPointObj.point.graphic) {\n                                isOldPointGrahic = true;\n                                oldPointObj.point.graphic.show();\n                                oldPointObj.point.graphic.animate({\n                                    x: newX - (oldPointObj.point.graphic.radius || 0),\n                                    y: newY - (oldPointObj.point.graphic.radius || 0),\n                                    opacity: 0.4\n                                }, animation, function () {\n                                    isCbHandled = true;\n                                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                                });\n                                if (oldPointObj.point.dataLabel &&\n                                    oldPointObj.point.dataLabel.y !== -9999 &&\n                                    newPointObj.point &&\n                                    newPointObj.point.dataLabel &&\n                                    newPointObj.point.dataLabel.alignAttr) {\n                                    oldPointObj.point.dataLabel.show();\n                                    oldPointObj.point.dataLabel.animate({\n                                        x: newPointObj.point.dataLabel.alignAttr.x,\n                                        y: newPointObj.point.dataLabel.alignAttr.y,\n                                        opacity: 0.4\n                                    }, animation);\n                                }\n                            }\n                        }\n                    });\n                    // Make sure point is faded in.\n                    syncTimeout(function () {\n                        if (!isCbHandled) {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                        }\n                    }, animDuration);\n                    if (!isOldPointGrahic) {\n                        syncTimeout(function () {\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                        }, animDuration / 2);\n                    }\n                }\n            }\n        }\n        /**\n         * Destroy clustered data points.\n         * @private\n         */\n        function seriesDestroyClusteredData() {\n            var clusteredSeriesData = this.markerClusterSeriesData;\n            // Clear previous groups.\n            (clusteredSeriesData || []).forEach(function (point) {\n                if (point && point.destroy) {\n                    point.destroy();\n                }\n            });\n            this.markerClusterSeriesData = null;\n        }\n        /**\n         * Override the generatePoints method by adding a reference to grouped data.\n         * @private\n         */\n        function seriesGeneratePoints() {\n            var series = this, chart = series.chart, mapView = chart.mapView, xData = series.xData, yData = series.yData, clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n            var oldPointsState, oldDataLen, oldMarkerClusterInfo, kmeansThreshold, cropDataOffsetX, cropDataOffsetY, seriesMinX, seriesMaxX, seriesMinY, seriesMaxY, type, algorithm, clusteredData, groupedData, layoutAlgOptions, point, i;\n            // For map point series, we need to resolve lon, lat and geometry options\n            // and project them on the plane in order to get x and y. In the regular\n            // series flow, this is not done until the `translate` method because the\n            // resulting [x, y] position depends on inset positions in the MapView.\n            if (mapView && series.is('mappoint') && xData && yData) {\n                (series.options.data || []).forEach(function (p, i) {\n                    var xy = series.projectPoint(p);\n                    if (xy) {\n                        xData[i] = xy.x;\n                        yData[i] = xy.y;\n                    }\n                });\n            }\n            if (clusterOptions &&\n                clusterOptions.enabled &&\n                xData &&\n                xData.length &&\n                yData &&\n                yData.length &&\n                !chart.polar) {\n                type = clusterOptions.layoutAlgorithm.type;\n                layoutAlgOptions = clusterOptions.layoutAlgorithm;\n                // Get processed algorithm properties.\n                layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n                    clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n                layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n                    clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n                kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n                    clusterDefaults.layoutAlgorithm.kmeansThreshold;\n                // Offset to prevent cluster size changes.\n                var halfGrid = layoutAlgOptions.processedGridSize / 2, p1 = pixelsToValues(series, { x: 0, y: 0 }), p2 = pixelsToValues(series, { x: halfGrid, y: halfGrid });\n                cropDataOffsetX = Math.abs(p1.x - p2.x);\n                cropDataOffsetY = Math.abs(p1.y - p2.y);\n                // Get only visible data.\n                for (i = 0; i < xData.length; i++) {\n                    if (!series.dataMaxX) {\n                        if (!defined(seriesMaxX) ||\n                            !defined(seriesMinX) ||\n                            !defined(seriesMaxY) ||\n                            !defined(seriesMinY)) {\n                            seriesMaxX = seriesMinX = xData[i];\n                            seriesMaxY = seriesMinY = yData[i];\n                        }\n                        else if (isNumber(yData[i]) &&\n                            isNumber(seriesMaxY) &&\n                            isNumber(seriesMinY)) {\n                            seriesMaxX = Math.max(xData[i], seriesMaxX);\n                            seriesMinX = Math.min(xData[i], seriesMinX);\n                            seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                            seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                        }\n                    }\n                    // Crop data to visible ones with appropriate offset to prevent\n                    // cluster size changes on the edge of the plot area.\n                    if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                        xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                        (yData[i] || realExtremes.minY) >=\n                            (realExtremes.minY - cropDataOffsetY) &&\n                        (yData[i] || realExtremes.maxY) <=\n                            (realExtremes.maxY + cropDataOffsetY)) {\n                        visibleXData.push(xData[i]);\n                        visibleYData.push(yData[i]);\n                        visibleDataIndexes.push(i);\n                    }\n                }\n                // Save data max values.\n                if (defined(seriesMaxX) && defined(seriesMinX) &&\n                    isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n                    series.dataMaxX = seriesMaxX;\n                    series.dataMinX = seriesMinX;\n                    series.dataMaxY = seriesMaxY;\n                    series.dataMinY = seriesMinY;\n                }\n                if (isFunction(type)) {\n                    algorithm = type;\n                }\n                else if (series.markerClusterAlgorithms) {\n                    if (type && series.markerClusterAlgorithms[type]) {\n                        algorithm = series.markerClusterAlgorithms[type];\n                    }\n                    else {\n                        algorithm = visibleXData.length < kmeansThreshold ?\n                            series.markerClusterAlgorithms.kmeans :\n                            series.markerClusterAlgorithms.grid;\n                    }\n                }\n                else {\n                    algorithm = function () {\n                        return false;\n                    };\n                }\n                groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n                clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n                // When animation is enabled get old points state.\n                if (clusterOptions.animation &&\n                    series.markerClusterInfo &&\n                    series.markerClusterInfo.pointsState &&\n                    series.markerClusterInfo.pointsState.oldState) {\n                    // Destroy old points.\n                    destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n                    oldPointsState = series.markerClusterInfo.pointsState.newState;\n                }\n                else {\n                    oldPointsState = {};\n                }\n                // Save points old state info.\n                oldDataLen = xData.length;\n                oldMarkerClusterInfo = series.markerClusterInfo;\n                if (clusteredData) {\n                    series.processedXData = clusteredData.groupedXData;\n                    series.processedYData = clusteredData.groupedYData;\n                    series.hasGroupedData = true;\n                    series.markerClusterInfo = clusteredData;\n                    series.groupMap = clusteredData.groupMap;\n                }\n                baseGeneratePoints.apply(this);\n                if (clusteredData && series.markerClusterInfo) {\n                    // Mark cluster points. Safe point reference in the cluster object.\n                    (series.markerClusterInfo.clusters || []).forEach(function (cluster) {\n                        point = series.points[cluster.index];\n                        point.isCluster = true;\n                        point.clusteredData = cluster.data;\n                        point.clusterPointsAmount = cluster.data.length;\n                        cluster.point = point;\n                        // Add zoom to cluster range.\n                        addEvent(point, 'click', onPointDrillToCluster);\n                    });\n                    // Safe point reference in the noise object.\n                    (series.markerClusterInfo.noise || []).forEach(function (noise) {\n                        noise.point = series.points[noise.index];\n                    });\n                    // When animation is enabled save points state.\n                    if (clusterOptions.animation &&\n                        series.markerClusterInfo) {\n                        series.markerClusterInfo.pointsState = {\n                            oldState: oldPointsState,\n                            newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                        };\n                    }\n                    // Record grouped data in order to let it be destroyed the next time\n                    // processData runs.\n                    if (!clusterOptions.animation) {\n                        this.destroyClusteredData();\n                    }\n                    else {\n                        this.hideClusteredData();\n                    }\n                    this.markerClusterSeriesData =\n                        this.hasGroupedData ? this.points : null;\n                }\n            }\n            else {\n                baseGeneratePoints.apply(this);\n            }\n        }\n        /** @private */\n        function seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n            var pointClusterDistance = [];\n            for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n                var p1 = valuesToPixels(this, { x: pointX, y: pointY }), p2 = valuesToPixels(this, {\n                    x: clusters[clusterIndex].posX,\n                    y: clusters[clusterIndex].posY\n                }), distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n                    Math.pow(p1.y - p2.y, 2));\n                pointClusterDistance.push({ clusterIndex: clusterIndex, distance: distance });\n            }\n            return pointClusterDistance.sort(function (a, b) { return a.distance - b.distance; });\n        }\n        /** @private */\n        function seriesGetClusteredData(groupedData, options) {\n            var series = this, groupedXData = [], groupedYData = [], clusters = [], // Container for clusters.\n            noise = [], // Container for points not belonging to any cluster.\n            groupMap = [], \n            // Prevent minimumClusterSize lower than 2.\n            minimumClusterSize = Math.max(2, options.minimumClusterSize || 2);\n            var index = 0, stateId, point, points, pointUserOptions, pointsLen, marker, clusterPos, pointOptions, clusterTempPos, zoneOptions, clusterZone, clusterZoneClassName, i, k;\n            // Check if groupedData is valid when user uses a custom algorithm.\n            if (isFunction(options.layoutAlgorithm.type) &&\n                !series.isValidGroupedDataObject(groupedData)) {\n                error('Highcharts marker-clusters module: ' +\n                    'The custom algorithm result is not valid!', false, series.chart);\n                return false;\n            }\n            for (k in groupedData) {\n                if (groupedData[k].length >= minimumClusterSize) {\n                    points = groupedData[k];\n                    stateId = getStateId();\n                    pointsLen = points.length;\n                    // Get zone options for cluster.\n                    if (options.zones) {\n                        for (i = 0; i < options.zones.length; i++) {\n                            if (pointsLen >= options.zones[i].from &&\n                                pointsLen <= options.zones[i].to) {\n                                clusterZone = options.zones[i];\n                                clusterZone.zoneIndex = i;\n                                zoneOptions = options.zones[i].marker;\n                                clusterZoneClassName = options.zones[i].className;\n                            }\n                        }\n                    }\n                    clusterTempPos = getClusterPosition(points);\n                    if (options.layoutAlgorithm.type === 'grid' &&\n                        !options.allowOverlap) {\n                        marker = series.options.marker || {};\n                        clusterPos = series.preventClusterCollisions({\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y,\n                            key: k,\n                            groupedData: groupedData,\n                            gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                            defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                            clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                                zoneOptions.radius :\n                                (options.marker || {}).radius ||\n                                    clusterDefaults.marker.radius\n                        });\n                    }\n                    else {\n                        clusterPos = {\n                            x: clusterTempPos.x,\n                            y: clusterTempPos.y\n                        };\n                    }\n                    for (i = 0; i < pointsLen; i++) {\n                        points[i].parentStateId = stateId;\n                    }\n                    clusters.push({\n                        x: clusterPos.x,\n                        y: clusterPos.y,\n                        id: k,\n                        stateId: stateId,\n                        index: index,\n                        data: points,\n                        clusterZone: clusterZone,\n                        clusterZoneClassName: clusterZoneClassName\n                    });\n                    groupedXData.push(clusterPos.x);\n                    groupedYData.push(clusterPos.y);\n                    groupMap.push({\n                        options: {\n                            formatPrefix: 'cluster',\n                            dataLabels: options.dataLabels,\n                            marker: merge(options.marker, {\n                                states: options.states\n                            }, zoneOptions || {})\n                        }\n                    });\n                    // Save cluster data points options.\n                    if (series.options.data && series.options.data.length) {\n                        for (i = 0; i < pointsLen; i++) {\n                            if (isObject(series.options.data[points[i].dataIndex])) {\n                                points[i].options =\n                                    series.options.data[points[i].dataIndex];\n                            }\n                        }\n                    }\n                    index++;\n                    zoneOptions = null;\n                }\n                else {\n                    for (i = 0; i < groupedData[k].length; i++) {\n                        // Points not belonging to any cluster.\n                        point = groupedData[k][i];\n                        stateId = getStateId();\n                        pointOptions = null;\n                        pointUserOptions =\n                            ((series.options || {}).data || [])[point.dataIndex];\n                        groupedXData.push(point.x);\n                        groupedYData.push(point.y);\n                        point.parentStateId = stateId;\n                        noise.push({\n                            x: point.x,\n                            y: point.y,\n                            id: k,\n                            stateId: stateId,\n                            index: index,\n                            data: groupedData[k]\n                        });\n                        if (pointUserOptions &&\n                            typeof pointUserOptions === 'object' &&\n                            !isArray(pointUserOptions)) {\n                            pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                        }\n                        else {\n                            pointOptions = {\n                                userOptions: pointUserOptions,\n                                x: point.x,\n                                y: point.y\n                            };\n                        }\n                        groupMap.push({ options: pointOptions });\n                        index++;\n                    }\n                }\n            }\n            return {\n                clusters: clusters,\n                noise: noise,\n                groupedXData: groupedXData,\n                groupedYData: groupedYData,\n                groupMap: groupMap\n            };\n        }\n        /** @private */\n        function seriesGetGridOffset() {\n            var series = this, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            var plotLeft = 0, plotTop = 0;\n            if (xAxis && series.dataMinX && series.dataMaxX) {\n                plotLeft = xAxis.reversed ?\n                    xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n            }\n            else {\n                plotLeft = chart.plotLeft;\n            }\n            if (yAxis && series.dataMinY && series.dataMaxY) {\n                plotTop = yAxis.reversed ?\n                    yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n            }\n            else {\n                plotTop = chart.plotTop;\n            }\n            return { plotLeft: plotLeft, plotTop: plotTop };\n        }\n        /**\n         * Point state used when animation is enabled to compare and bind old points\n         * with new ones.\n         * @private\n         */\n        function seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n            var oldDataStateArr = oldMarkerClusterInfo ?\n                getDataState(oldMarkerClusterInfo, dataLength) : [], newDataStateArr = getDataState(clusteredData, dataLength), state = {};\n            // Clear global array before populate with new ids.\n            oldPointsStateId = [];\n            // Build points state structure.\n            clusteredData.clusters.forEach(function (cluster) {\n                state[cluster.stateId] = {\n                    x: cluster.x,\n                    y: cluster.y,\n                    id: cluster.stateId,\n                    point: cluster.point,\n                    parentsId: []\n                };\n            });\n            clusteredData.noise.forEach(function (noise) {\n                state[noise.stateId] = {\n                    x: noise.x,\n                    y: noise.y,\n                    id: noise.stateId,\n                    point: noise.point,\n                    parentsId: []\n                };\n            });\n            var newState, oldState;\n            // Bind new and old state.\n            for (var i = 0; i < newDataStateArr.length; i++) {\n                newState = newDataStateArr[i];\n                oldState = oldDataStateArr[i];\n                if (newState &&\n                    oldState &&\n                    newState.parentStateId &&\n                    oldState.parentStateId &&\n                    state[newState.parentStateId] &&\n                    state[newState.parentStateId].parentsId.indexOf(oldState.parentStateId) === -1) {\n                    state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n                    if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                        oldPointsStateId.push(oldState.parentStateId);\n                    }\n                }\n            }\n            return state;\n        }\n        /** @private */\n        function seriesGetRealExtremes() {\n            var chart = this.chart, x = chart.mapView ? 0 : chart.plotLeft, y = chart.mapView ? 0 : chart.plotTop, p1 = pixelsToValues(this, {\n                x: x,\n                y: y\n            }), p2 = pixelsToValues(this, {\n                x: x + chart.plotWidth,\n                y: x + chart.plotHeight\n            }), realMinX = p1.x, realMaxX = p2.x, realMinY = p1.y, realMaxY = p2.y;\n            return {\n                minX: Math.min(realMinX, realMaxX),\n                maxX: Math.max(realMinX, realMaxX),\n                minY: Math.min(realMinY, realMaxY),\n                maxY: Math.max(realMinY, realMaxY)\n            };\n        }\n        /** @private */\n        function seriesGetScaledGridSize(options) {\n            var series = this, xAxis = series.xAxis, mapView = this.chart.mapView, processedGridSize = options.processedGridSize ||\n                clusterDefaults.layoutAlgorithm.gridSize;\n            var search = true, k = 1, divider = 1;\n            if (!series.gridValueSize) {\n                if (mapView) {\n                    series.gridValueSize = processedGridSize / mapView.getScale();\n                }\n                else {\n                    series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n                }\n            }\n            var gridSize = mapView ?\n                series.gridValueSize * mapView.getScale() :\n                xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n            var scale = +(processedGridSize / gridSize).toFixed(14);\n            // Find the level and its divider.\n            while (search && scale !== 1) {\n                var level = Math.pow(2, k);\n                if (scale > 0.75 && scale < 1.25) {\n                    search = false;\n                }\n                else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n                    search = false;\n                    divider = level;\n                }\n                else if (scale <= level && scale > level / 2) {\n                    search = false;\n                    divider = 1 / level;\n                }\n                k++;\n            }\n            return (processedGridSize / divider) / scale;\n        }\n        /**\n         * Hide clustered data points.\n         * @private\n         */\n        function seriesHideClusteredData() {\n            var series = this, clusteredSeriesData = this.markerClusterSeriesData, oldState = ((series.markerClusterInfo || {}).pointsState || {}).oldState || {}, oldPointsId = oldPointsStateId.map(function (elem) {\n                return (oldState[elem].point || {}).id || '';\n            });\n            (clusteredSeriesData || []).forEach(function (point) {\n                // If an old point is used in animation hide it, otherwise destroy.\n                if (point &&\n                    oldPointsId.indexOf(point.id) !== -1) {\n                    if (point.graphic) {\n                        point.graphic.hide();\n                    }\n                    if (point.dataLabel) {\n                        point.dataLabel.hide();\n                    }\n                }\n                else {\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n            });\n        }\n        /**\n         * Check if user algorithm result is valid groupedDataObject.\n         * @private\n         */\n        function seriesIsValidGroupedDataObject(groupedData) {\n            var result = false, i;\n            if (!isObject(groupedData)) {\n                return false;\n            }\n            objectEach(groupedData, function (elem) {\n                result = true;\n                if (!isArray(elem) || !elem.length) {\n                    result = false;\n                    return;\n                }\n                for (i = 0; i < elem.length; i++) {\n                    if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                        result = false;\n                        return;\n                    }\n                }\n            });\n            return result;\n        }\n        /** @private */\n        function seriesPreventClusterCollisions(props) {\n            var _a;\n            var series = this, _b = props.key.split('-').map(parseFloat), gridY = _b[0], gridX = _b[1], gridSize = props.gridSize, groupedData = props.groupedData, defaultRadius = props.defaultRadius, clusterRadius = props.clusterRadius, gridXPx = gridX * gridSize, gridYPx = gridY * gridSize, propsPx = valuesToPixels(series, props), gridsToCheckCollision = [], clusterMarkerOptions = (series.options.cluster || {}).marker, zoneOptions = (series.options.cluster || {}).zones, gridOffset = series.getGridOffset();\n            var xPixel = propsPx.x, yPixel = propsPx.y, pointsLen = 0, radius = 0, nextXPixel, nextYPixel, signX, signY, cornerGridX, cornerGridY, i, j, itemX, itemY, nextClusterPos, maxDist, keys;\n            // Distance to the grid start.\n            xPixel -= gridOffset.plotLeft;\n            yPixel -= gridOffset.plotTop;\n            for (i = 1; i < 5; i++) {\n                signX = i % 2 ? -1 : 1;\n                signY = i < 3 ? -1 : 1;\n                cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n                cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n                keys = [\n                    cornerGridY + '-' + cornerGridX,\n                    cornerGridY + '-' + gridX,\n                    gridY + '-' + cornerGridX\n                ];\n                for (j = 0; j < keys.length; j++) {\n                    if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                        keys[j] !== props.key) {\n                        gridsToCheckCollision.push(keys[j]);\n                    }\n                }\n            }\n            for (var _i = 0, gridsToCheckCollision_1 = gridsToCheckCollision; _i < gridsToCheckCollision_1.length; _i++) {\n                var item = gridsToCheckCollision_1[_i];\n                if (groupedData[item]) {\n                    // Cluster or noise position is already computed.\n                    if (!groupedData[item].posX) {\n                        nextClusterPos = getClusterPosition(groupedData[item]);\n                        groupedData[item].posX = nextClusterPos.x;\n                        groupedData[item].posY = nextClusterPos.y;\n                    }\n                    var pos_1 = valuesToPixels(series, {\n                        x: groupedData[item].posX || 0,\n                        y: groupedData[item].posY || 0\n                    });\n                    nextXPixel = pos_1.x - gridOffset.plotLeft;\n                    nextYPixel = pos_1.y - gridOffset.plotTop;\n                    _a = item.split('-').map(parseFloat), itemY = _a[0], itemX = _a[1];\n                    if (zoneOptions) {\n                        pointsLen = groupedData[item].length;\n                        for (i = 0; i < zoneOptions.length; i++) {\n                            if (pointsLen >= zoneOptions[i].from &&\n                                pointsLen <= zoneOptions[i].to) {\n                                if (defined((zoneOptions[i].marker || {}).radius)) {\n                                    radius = zoneOptions[i].marker.radius || 0;\n                                }\n                                else if (clusterMarkerOptions &&\n                                    clusterMarkerOptions.radius) {\n                                    radius = clusterMarkerOptions.radius;\n                                }\n                                else {\n                                    radius =\n                                        clusterDefaults.marker.radius;\n                                }\n                            }\n                        }\n                    }\n                    if (groupedData[item].length > 1 &&\n                        radius === 0 &&\n                        clusterMarkerOptions &&\n                        clusterMarkerOptions.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else if (groupedData[item].length === 1) {\n                        radius = defaultRadius;\n                    }\n                    maxDist = clusterRadius + radius;\n                    radius = 0;\n                    if (itemX !== gridX &&\n                        Math.abs(xPixel - nextXPixel) < maxDist) {\n                        xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                            gridXPx + gridSize - clusterRadius;\n                    }\n                    if (itemY !== gridY &&\n                        Math.abs(yPixel - nextYPixel) < maxDist) {\n                        yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                            gridYPx + gridSize - clusterRadius;\n                    }\n                }\n            }\n            var pos = pixelsToValues(series, {\n                x: xPixel + gridOffset.plotLeft,\n                y: yPixel + gridOffset.plotTop\n            });\n            groupedData[props.key].posX = pos.x;\n            groupedData[props.key].posY = pos.y;\n            return pos;\n        }\n        /**\n         * Util function.\n         * @private\n         */\n        function valuesToPixels(series, pos) {\n            var chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;\n            if (chart.mapView) {\n                return chart.mapView.projectedUnitsToPixels(pos);\n            }\n            return {\n                x: xAxis ? xAxis.toPixels(pos.x) : 0,\n                y: yAxis ? yAxis.toPixels(pos.y) : 0\n            };\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterScatter = {\n            compose: compose\n        };\n\n        return MarkerClusterScatter;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusters.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterDefaults.js'], _modules['Extensions/MarkerClusters/MarkerClusterScatter.js'], _modules['Core/Utilities.js']], function (A, D, MarkerClusterDefaults, MarkerClusterScatter, U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var animObject = A.animObject;\n        var defaultOptions = D.defaultOptions;\n        var addEvent = U.addEvent, defined = U.defined, error = U.error, isFunction = U.isFunction, merge = U.merge, pushUnique = U.pushUnique, syncTimeout = U.syncTimeout;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedMembers = [];\n        (defaultOptions.plotOptions || {}).series = merge((defaultOptions.plotOptions || {}).series, MarkerClusterDefaults);\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n            var PointClass = SeriesClass.prototype.pointClass;\n            if (pushUnique(composedMembers, AxisClass)) {\n                addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n            }\n            if (pushUnique(composedMembers, ChartClass)) {\n                addEvent(ChartClass, 'render', onChartRender);\n            }\n            if (pushUnique(composedMembers, PointClass)) {\n                addEvent(PointClass, 'drillToCluster', onPointDrillToCluster);\n                addEvent(PointClass, 'update', onPointUpdate);\n            }\n            if (pushUnique(composedMembers, SeriesClass)) {\n                addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n            }\n            var ScatterSeries = SeriesClass.types.scatter;\n            if (ScatterSeries) {\n                MarkerClusterScatter.compose(highchartsDefaultOptions, ScatterSeries);\n            }\n        }\n        /**\n         * Destroy the old tooltip after zoom.\n         * @private\n         */\n        function onAxisSetExtremes() {\n            var chart = this.chart;\n            var animationDuration = 0;\n            for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (series.markerClusterInfo) {\n                    animationDuration = (animObject((series.options.cluster || {}).animation).duration ||\n                        0);\n                }\n            }\n            syncTimeout(function () {\n                if (chart.tooltip) {\n                    chart.tooltip.destroy();\n                }\n            }, animationDuration);\n        }\n        /**\n         * Handle animation.\n         * @private\n         */\n        function onChartRender() {\n            var chart = this;\n            for (var _i = 0, _a = (chart.series || []); _i < _a.length; _i++) {\n                var series = _a[_i];\n                if (series.markerClusterInfo) {\n                    var options = series.options.cluster, pointsState = (series.markerClusterInfo || {}).pointsState, oldState = (pointsState || {}).oldState;\n                    if ((options || {}).animation &&\n                        series.markerClusterInfo &&\n                        series.chart.pointer.pinchDown.length === 0 &&\n                        ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                        oldState &&\n                        Object.keys(oldState).length) {\n                        for (var _b = 0, _c = series.markerClusterInfo.clusters; _b < _c.length; _b++) {\n                            var cluster = _c[_b];\n                            series.animateClusterPoint(cluster);\n                        }\n                        for (var _d = 0, _e = series.markerClusterInfo.noise; _d < _e.length; _d++) {\n                            var noise = _e[_d];\n                            series.animateClusterPoint(noise);\n                        }\n                    }\n                }\n            }\n        }\n        /** @private */\n        function onPointDrillToCluster(event) {\n            var point = event.point || event.target, series = point.series, clusterOptions = series.options.cluster, onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n            if (isFunction(onDrillToCluster)) {\n                onDrillToCluster.call(this, event);\n            }\n        }\n        /**\n         * Override point prototype to throw a warning when trying to update\n         * clustered point.\n         * @private\n         */\n        function onPointUpdate() {\n            var point = this;\n            if (point.dataGroup) {\n                error('Highcharts marker-clusters module: ' +\n                    'Running `Point.update` when point belongs to clustered series' +\n                    ' is not supported.', false, point.series.chart);\n                return false;\n            }\n        }\n        /**\n         * Add classes, change mouse cursor.\n         * @private\n         */\n        function onSeriesAfterRender() {\n            var series = this, clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n            if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n                for (var _i = 0, _a = series.markerClusterInfo.clusters; _i < _a.length; _i++) {\n                    var cluster = _a[_i];\n                    if (cluster.point && cluster.point.graphic) {\n                        cluster.point.graphic.addClass('highcharts-cluster-point');\n                        // Change cursor to pointer when drillToCluster is enabled.\n                        if (clusterZoomEnabled && cluster.point) {\n                            cluster.point.graphic.css({\n                                cursor: 'pointer'\n                            });\n                            if (cluster.point.dataLabel) {\n                                cluster.point.dataLabel.css({\n                                    cursor: 'pointer'\n                                });\n                            }\n                        }\n                        if (defined(cluster.clusterZone)) {\n                            cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                                'highcharts-cluster-zone-' +\n                                    cluster.clusterZone.zoneIndex);\n                        }\n                    }\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusters = {\n            compose: compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Function callback when a cluster is clicked.\n         *\n         * @callback Highcharts.MarkerClusterDrillCallbackFunction\n         *\n         * @param {Highcharts.Point} this\n         *        The point where the event occured.\n         *\n         * @param {Highcharts.PointClickEventObject} event\n         *        Event arguments.\n         */\n        ''; // keeps doclets above in JS file\n\n        return MarkerClusters;\n    });\n    _registerModule(_modules, 'Extensions/MarkerClusters/MarkerClusterSymbols.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Marker clusters module.\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Author: Wojciech Chmiel\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pushUnique = U.pushUnique;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var modifiedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        var symbols;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Cluster symbol.\n         * @private\n         */\n        function cluster(x, y, width, height) {\n            var w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                open: false\n            }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w - outerWidth * 2,\n                open: false\n            }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n                start: Math.PI * 0.5,\n                end: Math.PI * 2.5,\n                innerR: w,\n                open: false\n            });\n            return outer2.concat(outer1, inner);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            if (pushUnique(modifiedMembers, SVGRendererClass)) {\n                symbols = SVGRendererClass.prototype.symbols;\n                symbols.cluster = cluster;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var MarkerClusterSymbols = {\n            compose: compose\n        };\n\n        return MarkerClusterSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/marker-clusters.src.js', [_modules['Core/Globals.js'], _modules['Extensions/MarkerClusters/MarkerClusters.js'], _modules['Extensions/MarkerClusters/MarkerClusterSymbols.js']], function (Highcharts, MarkerClusters, MarkerClusterSymbols) {\n\n        var G = Highcharts;\n        MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\n        MarkerClusterSymbols.compose(G.SVGRenderer);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","A","MarkerClusterDefaults","U","baseGeneratePoints","animObject","clusterDefaults","addEvent","defined","error","isArray","isFunction","isObject","isNumber","merge","objectEach","pushUnique","relativeLength","syncTimeout","composedMembers","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","options","x","y","gridX","key","i","gridOffset","getGridOffset","scaledGridSize","series","getScaledGridSize","length","p","valuesToPixels","plotLeft","plotTop","Math","floor","gridY","push","dataIndex","kmeans","tempPos","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","pointClusterDistance","processedGridSize","groupedData","call","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","_i","clusters_1","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","offset","extremes","getRealExtremes","clusterMarkerOptions","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","_a","pointsOutside","pointsInside","_b","_c","data","dataPoint","dataPointPx","clusterPx","sqrt","pow","clusterZone","id","_d","_e","_f","_g","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","oldPoints_1","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","mapView","clusterOptions","sortedDataX","map","sort","a","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","max","y1","y2","fitToBounds","pointer","zoomX","zoomY","zoom","originalEvent","axis","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","oldPointObj","newPointBBox","animDuration","pointsState","newState","oldState","newX","newY","isOldPointGrahic","isCbHandled","newPos","stateId","parentsId","plotX","plotY","getBBox","isImg","width","alignAttr","seriesDestroyClusteredData","clusteredSeriesData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","layoutAlgOptions","xData","yData","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","algorithm","getClusteredData","destroyOldPoints","Object","keys","groupedXData","groupedYData","hasGroupedData","groupMap","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","k","isValidGroupedDataObject","zones","from","to","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","toPixels","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","oldPointsId","seriesIsValidGroupedDataObject","result","seriesPreventClusterCollisions","props","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","gridsToCheckCollision_1","item","pos_1","projectedUnitsToPixels","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","prototype","generatePoints","animateClusterPoint","plotOptions","D","MarkerClusterScatter","defaultOptions","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","ScatterSeries","types","scatter","symbols","modifiedMembers","height","w","h","inner","arc","space","start","PI","end","open","outer1","innerR","outerWidth","outer2","concat","SVGRendererClass","MarkerClusters","MarkerClusterSymbols","G","Axis","Chart","Series","SVGRenderer"],"mappings":"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"}