{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Gantt JS v11.2.0 (2023-10-30)\n *\n * Pathfinder\n *\n * (c) 2016-2021 Øystein Moseng\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/pathfinder', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Gantt/Connection.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var defined = U.defined, error = U.error, merge = U.merge, objectEach = U.objectEach;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var deg2rad = H.deg2rad, max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Connection class. Used internally to represent a connection between two\n         * points.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Connection\n         *\n         * @param {Highcharts.Point} from\n         *        Connection runs from this Point.\n         *\n         * @param {Highcharts.Point} to\n         *        Connection runs to this Point.\n         *\n         * @param {Highcharts.ConnectorsOptions} [options]\n         *        Connection options.\n         */\n        var Connection = /** @class */ (function () {\n            function Connection(from, to, options) {\n                /* *\n                *\n                * Properties\n                *\n                * */\n                this.chart = void 0;\n                this.fromPoint = void 0;\n                this.graphics = void 0;\n                this.pathfinder = void 0;\n                this.toPoint = void 0;\n                this.init(from, to, options);\n            }\n            /**\n             * Initialize the Connection object. Used as constructor only.\n             *\n             * @function Highcharts.Connection#init\n             *\n             * @param {Highcharts.Point} from\n             *        Connection runs from this Point.\n             *\n             * @param {Highcharts.Point} to\n             *        Connection runs to this Point.\n             *\n             * @param {Highcharts.ConnectorsOptions} [options]\n             *        Connection options.\n             */\n            Connection.prototype.init = function (from, to, options) {\n                this.fromPoint = from;\n                this.toPoint = to;\n                this.options = options;\n                this.chart = from.series.chart;\n                this.pathfinder = this.chart.pathfinder;\n            };\n            /**\n             * Add (or update) this connection's path on chart. Stores reference to the\n             * created element on this.graphics.path.\n             *\n             * @function Highcharts.Connection#renderPath\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Path to render, in array format. E.g. ['M', 0, 0, 'L', 10, 10]\n             *\n             * @param {Highcharts.SVGAttributes} [attribs]\n             *        SVG attributes for the path.\n             *\n             * @param {Partial<Highcharts.AnimationOptionsObject>} [animation]\n             *        Animation options for the rendering.\n             */\n            Connection.prototype.renderPath = function (path, attribs, animation) {\n                var connection = this, chart = this.chart, styledMode = chart.styledMode, pathfinder = chart.pathfinder, animate = !chart.options.chart.forExport && animation !== false, anim = {};\n                var pathGraphic = connection.graphics && connection.graphics.path;\n                // Add the SVG element of the pathfinder group if it doesn't exist\n                if (!pathfinder.group) {\n                    pathfinder.group = chart.renderer.g()\n                        .addClass('highcharts-pathfinder-group')\n                        .attr({ zIndex: -1 })\n                        .add(chart.seriesGroup);\n                }\n                // Shift the group to compensate for plot area.\n                // Note: Do this always (even when redrawing a path) to avoid issues\n                // when updating chart in a way that changes plot metrics.\n                pathfinder.group.translate(chart.plotLeft, chart.plotTop);\n                // Create path if does not exist\n                if (!(pathGraphic && pathGraphic.renderer)) {\n                    pathGraphic = chart.renderer.path()\n                        .add(pathfinder.group);\n                    if (!styledMode) {\n                        pathGraphic.attr({\n                            opacity: 0\n                        });\n                    }\n                }\n                // Set path attribs and animate to the new path\n                pathGraphic.attr(attribs);\n                anim.d = path;\n                if (!styledMode) {\n                    anim.opacity = 1;\n                }\n                pathGraphic[animate ? 'animate' : 'attr'](anim, animation);\n                // Store reference on connection\n                this.graphics = this.graphics || {};\n                this.graphics.path = pathGraphic;\n            };\n            /**\n             * Calculate and add marker graphics for connection to the chart. The\n             * created/updated elements are stored on this.graphics.start and\n             * this.graphics.end.\n             *\n             * @function Highcharts.Connection#addMarker\n             *\n             * @param {string} type\n             *        Marker type, either 'start' or 'end'.\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} options\n             *        All options for this marker. Not calculated or merged with other\n             *        options.\n             *\n             * @param {Highcharts.SVGPathArray} path\n             *        Connection path in array format. This is used to calculate the\n             *        rotation angle of the markers.\n             */\n            Connection.prototype.addMarker = function (type, options, path) {\n                var connection = this, chart = connection.fromPoint.series.chart, pathfinder = chart.pathfinder, renderer = chart.renderer, point = (type === 'start' ?\n                    connection.fromPoint :\n                    connection.toPoint), anchor = point.getPathfinderAnchorPoint(options);\n                var markerVector, radians, rotation, box, width, height, pathVector, segment;\n                if (!options.enabled) {\n                    return;\n                }\n                // Last vector before start/end of path, used to get angle\n                if (type === 'start') {\n                    segment = path[1];\n                }\n                else { // 'end'\n                    segment = path[path.length - 2];\n                }\n                if (segment && segment[0] === 'M' || segment[0] === 'L') {\n                    pathVector = {\n                        x: segment[1],\n                        y: segment[2]\n                    };\n                    // Get angle between pathVector and anchor point and use it to\n                    // create marker position.\n                    radians = point.getRadiansToVector(pathVector, anchor);\n                    markerVector = point.getMarkerVector(radians, options.radius, anchor);\n                    // Rotation of marker is calculated from angle between pathVector\n                    // and markerVector.\n                    // (Note:\n                    //  Used to recalculate radians between markerVector and pathVector,\n                    //  but this should be the same as between pathVector and anchor.)\n                    rotation = -radians / deg2rad;\n                    if (options.width && options.height) {\n                        width = options.width;\n                        height = options.height;\n                    }\n                    else {\n                        width = height = options.radius * 2;\n                    }\n                    // Add graphics object if it does not exist\n                    connection.graphics = connection.graphics || {};\n                    box = {\n                        x: markerVector.x - (width / 2),\n                        y: markerVector.y - (height / 2),\n                        width: width,\n                        height: height,\n                        rotation: rotation,\n                        rotationOriginX: markerVector.x,\n                        rotationOriginY: markerVector.y\n                    };\n                    if (!connection.graphics[type]) {\n                        // Create new marker element\n                        connection.graphics[type] = renderer\n                            .symbol(options.symbol)\n                            .addClass('highcharts-point-connecting-path-' + type + '-marker' +\n                            ' highcharts-color-' + this.fromPoint.colorIndex)\n                            .attr(box)\n                            .add(pathfinder.group);\n                        if (!renderer.styledMode) {\n                            connection.graphics[type].attr({\n                                fill: options.color || connection.fromPoint.color,\n                                stroke: options.lineColor,\n                                'stroke-width': options.lineWidth,\n                                opacity: 0\n                            })\n                                .animate({\n                                opacity: 1\n                            }, point.series.options.animation);\n                        }\n                    }\n                    else {\n                        connection.graphics[type].animate(box);\n                    }\n                }\n            };\n            /**\n             * Calculate and return connection path.\n             * Note: Recalculates chart obstacles on demand if they aren't calculated.\n             *\n             * @function Highcharts.Connection#getPath\n             *\n             * @param {Highcharts.ConnectorsOptions} options\n             *        Connector options. Not calculated or merged with other options.\n             *\n             * @return {object|undefined}\n             *         Calculated SVG path data in array format.\n             */\n            Connection.prototype.getPath = function (options) {\n                var pathfinder = this.pathfinder, chart = this.chart, algorithm = pathfinder.algorithms[options.type];\n                var chartObstacles = pathfinder.chartObstacles;\n                if (typeof algorithm !== 'function') {\n                    error('\"' + options.type + '\" is not a Pathfinder algorithm.');\n                    return {\n                        path: [],\n                        obstacles: []\n                    };\n                }\n                // This function calculates obstacles on demand if they don't exist\n                if (algorithm.requiresObstacles && !chartObstacles) {\n                    chartObstacles =\n                        pathfinder.chartObstacles =\n                            pathfinder.getChartObstacles(options);\n                    // If the algorithmMargin was computed, store the result in default\n                    // options.\n                    chart.options.connectors.algorithmMargin =\n                        options.algorithmMargin;\n                    // Cache some metrics too\n                    pathfinder.chartObstacleMetrics =\n                        pathfinder.getObstacleMetrics(chartObstacles);\n                }\n                // Get the SVG path\n                return algorithm(\n                // From\n                this.fromPoint.getPathfinderAnchorPoint(options.startMarker), \n                // To\n                this.toPoint.getPathfinderAnchorPoint(options.endMarker), merge({\n                    chartObstacles: chartObstacles,\n                    lineObstacles: pathfinder.lineObstacles || [],\n                    obstacleMetrics: pathfinder.chartObstacleMetrics,\n                    hardBounds: {\n                        xMin: 0,\n                        xMax: chart.plotWidth,\n                        yMin: 0,\n                        yMax: chart.plotHeight\n                    },\n                    obstacleOptions: {\n                        margin: options.algorithmMargin\n                    },\n                    startDirectionX: pathfinder.getAlgorithmStartDirection(options.startMarker)\n                }, options));\n            };\n            /**\n             * (re)Calculate and (re)draw the connection.\n             *\n             * @function Highcharts.Connection#render\n             */\n            Connection.prototype.render = function () {\n                var connection = this, fromPoint = connection.fromPoint, series = fromPoint.series, chart = series.chart, pathfinder = chart.pathfinder, attribs = {};\n                var options = merge(chart.options.connectors, series.options.connectors, fromPoint.options.connectors, connection.options);\n                // Set path attribs\n                if (!chart.styledMode) {\n                    attribs.stroke = options.lineColor || fromPoint.color;\n                    attribs['stroke-width'] = options.lineWidth;\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n                }\n                attribs['class'] = // eslint-disable-line dot-notation\n                    'highcharts-point-connecting-path ' +\n                        'highcharts-color-' + fromPoint.colorIndex;\n                options = merge(attribs, options);\n                // Set common marker options\n                if (!defined(options.marker.radius)) {\n                    options.marker.radius = min(max(Math.ceil((options.algorithmMargin || 8) / 2) - 1, 1), 5);\n                }\n                // Get the path\n                var pathResult = connection.getPath(options), path = pathResult.path;\n                // Always update obstacle storage with obstacles from this path.\n                // We don't know if future calls will need this for their algorithm.\n                if (pathResult.obstacles) {\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles || [];\n                    pathfinder.lineObstacles =\n                        pathfinder.lineObstacles.concat(pathResult.obstacles);\n                }\n                // Add the calculated path to the pathfinder group\n                connection.renderPath(path, attribs, series.options.animation);\n                // Render the markers\n                connection.addMarker('start', merge(options.marker, options.startMarker), path);\n                connection.addMarker('end', merge(options.marker, options.endMarker), path);\n            };\n            /**\n             * Destroy connection by destroying the added graphics elements.\n             *\n             * @function Highcharts.Connection#destroy\n             */\n            Connection.prototype.destroy = function () {\n                if (this.graphics) {\n                    objectEach(this.graphics, function (val) {\n                        val.destroy();\n                    });\n                    delete this.graphics;\n                }\n            };\n            return Connection;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Connection;\n    });\n    _registerModule(_modules, 'Series/PathUtilities.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2022 Pawel Lysy\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var getLinkPath = {\n            'default': getDefaultPath,\n            straight: getStraightPath,\n            curved: getCurvedPath\n        };\n        function getDefaultPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.width, width = _a === void 0 ? 0 : _a, _b = pathParams.inverted, inverted = _b === void 0 ? false : _b, radius = pathParams.radius, parentVisible = pathParams.parentVisible;\n            var path = [\n                ['M', x1, y1],\n                ['L', x1, y1],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2],\n                ['C', x1, y1, x1, y2, x1, y2],\n                ['L', x1, y2]\n            ];\n            return parentVisible ?\n                applyRadius([\n                    ['M', x1, y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y1],\n                    ['L', x1 + width * (inverted ? -0.5 : 0.5), y2],\n                    ['L', x2, y2]\n                ], radius) :\n                path;\n        }\n        function getStraightPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.width, width = _a === void 0 ? 0 : _a, _b = pathParams.inverted, inverted = _b === void 0 ? false : _b, parentVisible = pathParams.parentVisible;\n            return parentVisible ? [\n                ['M', x1, y1],\n                ['L', x1 + width * (inverted ? -1 : 1), y2],\n                ['L', x2, y2]\n            ] : [\n                ['M', x1, y1],\n                ['L', x1, y2],\n                ['L', x1, y2]\n            ];\n        }\n        function getCurvedPath(pathParams) {\n            var x1 = pathParams.x1, y1 = pathParams.y1, x2 = pathParams.x2, y2 = pathParams.y2, _a = pathParams.offset, offset = _a === void 0 ? 0 : _a, _b = pathParams.width, width = _b === void 0 ? 0 : _b, _c = pathParams.inverted, inverted = _c === void 0 ? false : _c, parentVisible = pathParams.parentVisible;\n            return parentVisible ?\n                [\n                    ['M', x1, y1],\n                    [\n                        'C',\n                        x1 + offset,\n                        y1,\n                        x1 - offset + width * (inverted ? -1 : 1),\n                        y2,\n                        x1 + width * (inverted ? -1 : 1),\n                        y2\n                    ],\n                    ['L', x2, y2]\n                ] :\n                [\n                    ['M', x1, y1],\n                    ['C', x1, y1, x1, y2, x1, y2],\n                    ['L', x2, y2]\n                ];\n        }\n        /**\n         * General function to apply corner radius to a path\n         * @private\n         */\n        function applyRadius(path, r) {\n            var d = [];\n            for (var i = 0; i < path.length; i++) {\n                var x = path[i][1];\n                var y = path[i][2];\n                if (typeof x === 'number' && typeof y === 'number') {\n                    // moveTo\n                    if (i === 0) {\n                        d.push(['M', x, y]);\n                    }\n                    else if (i === path.length - 1) {\n                        d.push(['L', x, y]);\n                        // curveTo\n                    }\n                    else if (r) {\n                        var prevSeg = path[i - 1];\n                        var nextSeg = path[i + 1];\n                        if (prevSeg && nextSeg) {\n                            var x1 = prevSeg[1], y1 = prevSeg[2], x2 = nextSeg[1], y2 = nextSeg[2];\n                            // Only apply to breaks\n                            if (typeof x1 === 'number' &&\n                                typeof x2 === 'number' &&\n                                typeof y1 === 'number' &&\n                                typeof y2 === 'number' &&\n                                x1 !== x2 &&\n                                y1 !== y2) {\n                                var directionX = x1 < x2 ? 1 : -1, directionY = y1 < y2 ? 1 : -1;\n                                d.push([\n                                    'L',\n                                    x - directionX * Math.min(Math.abs(x - x1), r),\n                                    y - directionY * Math.min(Math.abs(y - y1), r)\n                                ], [\n                                    'C',\n                                    x,\n                                    y,\n                                    x,\n                                    y,\n                                    x + directionX * Math.min(Math.abs(x - x2), r),\n                                    y + directionY * Math.min(Math.abs(y - y2), r)\n                                ]);\n                            }\n                        }\n                        // lineTo\n                    }\n                    else {\n                        d.push(['L', x, y]);\n                    }\n                }\n            }\n            return d;\n        }\n        var PathUtilities = {\n            applyRadius: applyRadius,\n            getLinkPath: getLinkPath\n        };\n\n        return PathUtilities;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderAlgorithms.js', [_modules['Series/PathUtilities.js'], _modules['Core/Utilities.js']], function (PathUtilities, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Author: Øystein Moseng\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var min = Math.min, max = Math.max, abs = Math.abs;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get index of last obstacle before xMin. Employs a type of binary search, and\n         * thus requires that obstacles are sorted by xMin value.\n         *\n         * @private\n         * @function findLastObstacleBefore\n         *\n         * @param {Array<object>} obstacles\n         *        Array of obstacles to search in.\n         *\n         * @param {number} xMin\n         *        The xMin threshold.\n         *\n         * @param {number} [startIx]\n         *        Starting index to search from. Must be within array range.\n         *\n         * @return {number}\n         *         The index of the last obstacle element before xMin.\n         */\n        function findLastObstacleBefore(obstacles, xMin, startIx) {\n            var min = xMin - 0.0000001; // Make sure we include all obstacles at xMin\n            var left = startIx || 0, // Left limit\n            right = obstacles.length - 1, // Right limit\n            cursor, cmp;\n            while (left <= right) {\n                cursor = (right + left) >> 1;\n                cmp = min - obstacles[cursor].xMin;\n                if (cmp > 0) {\n                    left = cursor + 1;\n                }\n                else if (cmp < 0) {\n                    right = cursor - 1;\n                }\n                else {\n                    return cursor;\n                }\n            }\n            return left > 0 ? left - 1 : 0;\n        }\n        /**\n         * Test if a point lays within an obstacle.\n         *\n         * @private\n         * @function pointWithinObstacle\n         *\n         * @param {Object} obstacle\n         *        Obstacle to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {boolean}\n         *         Whether point is within the obstacle or not.\n         */\n        function pointWithinObstacle(obstacle, point) {\n            return (point.x <= obstacle.xMax &&\n                point.x >= obstacle.xMin &&\n                point.y <= obstacle.yMax &&\n                point.y >= obstacle.yMin);\n        }\n        /**\n         * Find the index of an obstacle that wraps around a point.\n         * Returns -1 if not found.\n         *\n         * @private\n         * @function findObstacleFromPoint\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to test.\n         *\n         * @param {Highcharts.Point} point\n         *        Point with x/y props.\n         *\n         * @return {number}\n         *         Ix of the obstacle in the array, or -1 if not found.\n         */\n        function findObstacleFromPoint(obstacles, point) {\n            var i = findLastObstacleBefore(obstacles, point.x + 1) + 1;\n            while (i--) {\n                if (obstacles[i].xMax >= point.x &&\n                    // Optimization using lazy evaluation\n                    pointWithinObstacle(obstacles[i], point)) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Get SVG path array from array of line segments.\n         *\n         * @private\n         * @function pathFromSegments\n         *\n         * @param {Array<object>} segments\n         *        The segments to build the path from.\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         SVG path array as accepted by the SVG Renderer.\n         */\n        function pathFromSegments(segments) {\n            var path = [];\n            if (segments.length) {\n                path.push(['M', segments[0].start.x, segments[0].start.y]);\n                for (var i = 0; i < segments.length; ++i) {\n                    path.push(['L', segments[i].end.x, segments[i].end.y]);\n                }\n            }\n            return path;\n        }\n        /**\n         * Limits obstacle max/mins in all directions to bounds. Modifies input\n         * obstacle.\n         *\n         * @private\n         * @function limitObstacleToBounds\n         *\n         * @param {Object} obstacle\n         *        Obstacle to limit.\n         *\n         * @param {Object} bounds\n         *        Bounds to use as limit.\n         *\n         * @return {void}\n         */\n        function limitObstacleToBounds(obstacle, bounds) {\n            obstacle.yMin = max(obstacle.yMin, bounds.yMin);\n            obstacle.yMax = min(obstacle.yMax, bounds.yMax);\n            obstacle.xMin = max(obstacle.xMin, bounds.xMin);\n            obstacle.xMax = min(obstacle.xMax, bounds.xMax);\n        }\n        /**\n         * Get an SVG path from a starting coordinate to an ending coordinate.\n         * Draws a straight line.\n         *\n         * @function Highcharts.Pathfinder.algorithms.straight\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function straight(start, end) {\n            return {\n                path: [\n                    ['M', start.x, start.y],\n                    ['L', end.x, end.y]\n                ],\n                obstacles: [{ start: start, end: end }]\n            };\n        }\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, using\n         * right angles only, and taking only starting/ending obstacle into\n         * consideration.\n         *\n         * @function Highcharts.Pathfinder.algorithms.simpleConnect\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm:\n         *        - chartObstacles: Array of chart obstacles to avoid\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *          If not provided, the algorithm starts in the direction that is\n         *          the furthest between start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        var simpleConnect = function (start, end, options) {\n            var segments = [], chartObstacles = options.chartObstacles, startObstacleIx = findObstacleFromPoint(chartObstacles, start), endObstacleIx = findObstacleFromPoint(chartObstacles, end);\n            var endSegment, dir = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)) ? 'x' : 'y', startObstacle, endObstacle, waypoint, useMax, endPoint;\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return a clone of a point with a property set from a target object,\n             * optionally with an offset\n             * @private\n             */\n            function copyFromPoint(from, fromKey, to, toKey, offset) {\n                var point = {\n                    x: from.x,\n                    y: from.y\n                };\n                point[fromKey] = to[toKey || fromKey] + (offset || 0);\n                return point;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Return waypoint outside obstacle.\n             * @private\n             */\n            function getMeOut(obstacle, point, direction) {\n                var useMax = abs(point[direction] - obstacle[direction + 'Min']) >\n                    abs(point[direction] - obstacle[direction + 'Max']);\n                return copyFromPoint(point, direction, obstacle, direction + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1);\n            }\n            // Pull out end point\n            if (endObstacleIx > -1) {\n                endObstacle = chartObstacles[endObstacleIx];\n                waypoint = getMeOut(endObstacle, end, dir);\n                endSegment = {\n                    start: waypoint,\n                    end: end\n                };\n                endPoint = waypoint;\n            }\n            else {\n                endPoint = end;\n            }\n            // If an obstacle envelops the start point, add a segment to get out,\n            // and around it.\n            if (startObstacleIx > -1) {\n                startObstacle = chartObstacles[startObstacleIx];\n                waypoint = getMeOut(startObstacle, start, dir);\n                segments.push({\n                    start: start,\n                    end: waypoint\n                });\n                // If we are going back again, switch direction to get around start\n                // obstacle.\n                if (\n                // Going towards max from start:\n                waypoint[dir] >= start[dir] ===\n                    // Going towards min to end:\n                    waypoint[dir] >= endPoint[dir]) {\n                    dir = dir === 'y' ? 'x' : 'y';\n                    useMax = start[dir] < end[dir];\n                    segments.push({\n                        start: waypoint,\n                        end: copyFromPoint(waypoint, dir, startObstacle, dir + (useMax ? 'Max' : 'Min'), useMax ? 1 : -1)\n                    });\n                    // Switch direction again\n                    dir = dir === 'y' ? 'x' : 'y';\n                }\n            }\n            // We are around the start obstacle. Go towards the end in one\n            // direction.\n            var prevWaypoint = segments.length ?\n                segments[segments.length - 1].end :\n                start;\n            waypoint = copyFromPoint(prevWaypoint, dir, endPoint);\n            segments.push({\n                start: prevWaypoint,\n                end: waypoint\n            });\n            // Final run to end point in the other direction\n            dir = dir === 'y' ? 'x' : 'y';\n            var waypoint2 = copyFromPoint(waypoint, dir, endPoint);\n            segments.push({\n                start: waypoint,\n                end: waypoint2\n            });\n            // Finally add the endSegment\n            segments.push(endSegment);\n            var path = PathUtilities.applyRadius(pathFromSegments(segments), options.radius);\n            return {\n                path: path,\n                obstacles: segments\n            };\n        };\n        simpleConnect.requiresObstacles = true;\n        /**\n         * Find a path from a starting coordinate to an ending coordinate, taking\n         * obstacles into consideration. Might not always find the optimal path,\n         * but is fast, and usually good enough.\n         *\n         * @function Highcharts.Pathfinder.algorithms.fastAvoid\n         *\n         * @param {Highcharts.PositionObject} start\n         *        Starting coordinate, object with x/y props.\n         *\n         * @param {Highcharts.PositionObject} end\n         *        Ending coordinate, object with x/y props.\n         *\n         * @param {Object} options\n         *        Options for the algorithm.\n         *        - chartObstacles:  Array of chart obstacles to avoid\n         *        - lineObstacles:   Array of line obstacles to jump over\n         *        - obstacleMetrics: Object with metrics of chartObstacles cached\n         *        - hardBounds:      Hard boundaries to not cross\n         *        - obstacleOptions: Options for the obstacles, including margin\n         *        - startDirectionX: Optional. True if starting in the X direction.\n         *                           If not provided, the algorithm starts in the\n         *                           direction that is the furthest between\n         *                           start/end.\n         *\n         * @return {Object}\n         *         An object with the SVG path in Array form as accepted by the SVG\n         *         renderer, as well as an array of new obstacles making up this\n         *         path.\n         */\n        function fastAvoid(start, end, options) {\n            /*\n                Algorithm rules/description\n                - Find initial direction\n                - Determine soft/hard max for each direction.\n                - Move along initial direction until obstacle.\n                - Change direction.\n                - If hitting obstacle, first try to change length of previous line\n                    before changing direction again.\n\n                Soft min/max x = start/destination x +/- widest obstacle + margin\n                Soft min/max y = start/destination y +/- tallest obstacle + margin\n\n                @todo:\n                    - Make retrospective, try changing prev segment to reduce\n                        corners\n                    - Fix logic for breaking out of end-points - not always picking\n                        the best direction currently\n                    - When going around the end obstacle we should not always go the\n                        shortest route, rather pick the one closer to the end point\n            */\n            var dirIsX = pick(options.startDirectionX, abs(end.x - start.x) > abs(end.y - start.y)), dir = dirIsX ? 'x' : 'y', endSegments = [], \n            // Boundaries to stay within. If beyond soft boundary, prefer to\n            // change direction ASAP. If at hard max, always change immediately.\n            metrics = options.obstacleMetrics, softMinX = min(start.x, end.x) - metrics.maxWidth - 10, softMaxX = max(start.x, end.x) + metrics.maxWidth + 10, softMinY = min(start.y, end.y) - metrics.maxHeight - 10, softMaxY = max(start.y, end.y) + metrics.maxHeight + 10;\n            var segments, useMax, extractedEndPoint, forceObstacleBreak = false, // Used in clearPathTo to keep track of\n            // when to force break through an obstacle.\n            // Obstacles\n            chartObstacles = options.chartObstacles, endObstacleIx = findLastObstacleBefore(chartObstacles, softMaxX);\n            var startObstacleIx = findLastObstacleBefore(chartObstacles, softMinX);\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * How far can you go between two points before hitting an obstacle?\n             * Does not work for diagonal lines (because it doesn't have to).\n             * @private\n             */\n            function pivotPoint(fromPoint, toPoint, directionIsX) {\n                var searchDirection = fromPoint.x < toPoint.x ? 1 : -1;\n                var firstPoint, lastPoint, highestPoint, lowestPoint;\n                if (fromPoint.x < toPoint.x) {\n                    firstPoint = fromPoint;\n                    lastPoint = toPoint;\n                }\n                else {\n                    firstPoint = toPoint;\n                    lastPoint = fromPoint;\n                }\n                if (fromPoint.y < toPoint.y) {\n                    lowestPoint = fromPoint;\n                    highestPoint = toPoint;\n                }\n                else {\n                    lowestPoint = toPoint;\n                    highestPoint = fromPoint;\n                }\n                // Go through obstacle range in reverse if toPoint is before\n                // fromPoint in the X-dimension.\n                var i = searchDirection < 0 ?\n                    // Searching backwards, start at last obstacle before last point\n                    min(findLastObstacleBefore(chartObstacles, lastPoint.x), chartObstacles.length - 1) :\n                    // Forwards. Since we're not sorted by xMax, we have to look\n                    // at all obstacles.\n                    0;\n                // Go through obstacles in this X range\n                while (chartObstacles[i] && (searchDirection > 0 && chartObstacles[i].xMin <= lastPoint.x ||\n                    searchDirection < 0 && chartObstacles[i].xMax >= firstPoint.x)) {\n                    // If this obstacle is between from and to points in a straight\n                    // line, pivot at the intersection.\n                    if (chartObstacles[i].xMin <= lastPoint.x &&\n                        chartObstacles[i].xMax >= firstPoint.x &&\n                        chartObstacles[i].yMin <= highestPoint.y &&\n                        chartObstacles[i].yMax >= lowestPoint.y) {\n                        if (directionIsX) {\n                            return {\n                                y: fromPoint.y,\n                                x: fromPoint.x < toPoint.x ?\n                                    chartObstacles[i].xMin - 1 :\n                                    chartObstacles[i].xMax + 1,\n                                obstacle: chartObstacles[i]\n                            };\n                        }\n                        // Else ...\n                        return {\n                            x: fromPoint.x,\n                            y: fromPoint.y < toPoint.y ?\n                                chartObstacles[i].yMin - 1 :\n                                chartObstacles[i].yMax + 1,\n                            obstacle: chartObstacles[i]\n                        };\n                    }\n                    i += searchDirection;\n                }\n                return toPoint;\n            }\n            /**\n             * Decide in which direction to dodge or get out of an obstacle.\n             * Considers desired direction, which way is shortest, soft and hard\n             * bounds.\n             *\n             * (? Returns a string, either xMin, xMax, yMin or yMax.)\n             *\n             * @private\n             * @function\n             *\n             * @param {Object} obstacle\n             *        Obstacle to dodge/escape.\n             *\n             * @param {Object} fromPoint\n             *        Point with x/y props that's dodging/escaping.\n             *\n             * @param {Object} toPoint\n             *        Goal point.\n             *\n             * @param {boolean} dirIsX\n             *        Dodge in X dimension.\n             *\n             * @param {Object} bounds\n             *        Hard and soft boundaries.\n             *\n             * @return {boolean}\n             *         Use max or not.\n             */\n            function getDodgeDirection(obstacle, fromPoint, toPoint, dirIsX, bounds) {\n                var softBounds = bounds.soft, hardBounds = bounds.hard, dir = dirIsX ? 'x' : 'y', toPointMax = { x: fromPoint.x, y: fromPoint.y }, toPointMin = { x: fromPoint.x, y: fromPoint.y }, maxOutOfSoftBounds = obstacle[dir + 'Max'] >=\n                    softBounds[dir + 'Max'], minOutOfSoftBounds = obstacle[dir + 'Min'] <=\n                    softBounds[dir + 'Min'], maxOutOfHardBounds = obstacle[dir + 'Max'] >=\n                    hardBounds[dir + 'Max'], minOutOfHardBounds = obstacle[dir + 'Min'] <=\n                    hardBounds[dir + 'Min'], \n                // Find out if we should prefer one direction over the other if\n                // we can choose freely\n                minDistance = abs(obstacle[dir + 'Min'] - fromPoint[dir]), maxDistance = abs(obstacle[dir + 'Max'] - fromPoint[dir]);\n                var // If it's a small difference, pick the one leading towards dest\n                // point. Otherwise pick the shortest distance\n                useMax = abs(minDistance - maxDistance) < 10 ?\n                    fromPoint[dir] < toPoint[dir] :\n                    maxDistance < minDistance;\n                // Check if we hit any obstacles trying to go around in either\n                // direction.\n                toPointMin[dir] = obstacle[dir + 'Min'];\n                toPointMax[dir] = obstacle[dir + 'Max'];\n                var minPivot = pivotPoint(fromPoint, toPointMin, dirIsX)[dir] !==\n                    toPointMin[dir], maxPivot = pivotPoint(fromPoint, toPointMax, dirIsX)[dir] !==\n                    toPointMax[dir];\n                useMax = minPivot ?\n                    (maxPivot ? useMax : true) :\n                    (maxPivot ? false : useMax);\n                // `useMax` now contains our preferred choice, bounds not taken into\n                // account. If both or neither direction is out of bounds we want to\n                // use this.\n                // Deal with soft bounds\n                useMax = minOutOfSoftBounds ?\n                    (maxOutOfSoftBounds ? useMax : true) : // Out on min\n                    (maxOutOfSoftBounds ? false : useMax); // Not out on min\n                // Deal with hard bounds\n                useMax = minOutOfHardBounds ?\n                    (maxOutOfHardBounds ? useMax : true) : // Out on min\n                    (maxOutOfHardBounds ? false : useMax); // Not out on min\n                return useMax;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Find a clear path between point.\n             * @private\n             */\n            function clearPathTo(fromPoint, toPoint, dirIsX) {\n                // Don't waste time if we've hit goal\n                if (fromPoint.x === toPoint.x && fromPoint.y === toPoint.y) {\n                    return [];\n                }\n                var dir = dirIsX ? 'x' : 'y', obstacleMargin = options.obstacleOptions.margin, bounds = {\n                    soft: {\n                        xMin: softMinX,\n                        xMax: softMaxX,\n                        yMin: softMinY,\n                        yMax: softMaxY\n                    },\n                    hard: options.hardBounds\n                };\n                var pivot, segments, waypoint, waypointUseMax, envelopingObstacle, secondEnvelopingObstacle, envelopWaypoint;\n                // If fromPoint is inside an obstacle we have a problem. Break out\n                // by just going to the outside of this obstacle. We prefer to go to\n                // the nearest edge in the chosen direction.\n                envelopingObstacle =\n                    findObstacleFromPoint(chartObstacles, fromPoint);\n                if (envelopingObstacle > -1) {\n                    envelopingObstacle = chartObstacles[envelopingObstacle];\n                    waypointUseMax = getDodgeDirection(envelopingObstacle, fromPoint, toPoint, dirIsX, bounds);\n                    // Cut obstacle to hard bounds to make sure we stay within\n                    limitObstacleToBounds(envelopingObstacle, options.hardBounds);\n                    envelopWaypoint = dirIsX ? {\n                        y: fromPoint.y,\n                        x: envelopingObstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    } : {\n                        x: fromPoint.x,\n                        y: envelopingObstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                            (waypointUseMax ? 1 : -1)\n                    };\n                    // If we crashed into another obstacle doing this, we put the\n                    // waypoint between them instead\n                    secondEnvelopingObstacle = findObstacleFromPoint(chartObstacles, envelopWaypoint);\n                    if (secondEnvelopingObstacle > -1) {\n                        secondEnvelopingObstacle = chartObstacles[secondEnvelopingObstacle];\n                        // Cut obstacle to hard bounds\n                        limitObstacleToBounds(secondEnvelopingObstacle, options.hardBounds);\n                        // Modify waypoint to lay between obstacles\n                        envelopWaypoint[dir] = waypointUseMax ? max(envelopingObstacle[dir + 'Max'] - obstacleMargin + 1, (secondEnvelopingObstacle[dir + 'Min'] +\n                            envelopingObstacle[dir + 'Max']) / 2) :\n                            min((envelopingObstacle[dir + 'Min'] + obstacleMargin - 1), ((secondEnvelopingObstacle[dir + 'Max'] +\n                                envelopingObstacle[dir + 'Min']) / 2));\n                        // We are not going anywhere. If this happens for the first\n                        // time, do nothing. Otherwise, try to go to the extreme of\n                        // the obstacle pair in the current direction.\n                        if (fromPoint.x === envelopWaypoint.x &&\n                            fromPoint.y === envelopWaypoint.y) {\n                            if (forceObstacleBreak) {\n                                envelopWaypoint[dir] = waypointUseMax ?\n                                    max(envelopingObstacle[dir + 'Max'], secondEnvelopingObstacle[dir + 'Max']) + 1 :\n                                    min(envelopingObstacle[dir + 'Min'], secondEnvelopingObstacle[dir + 'Min']) - 1;\n                            }\n                            // Toggle on if off, and the opposite\n                            forceObstacleBreak = !forceObstacleBreak;\n                        }\n                        else {\n                            // This point is not identical to previous.\n                            // Clear break trigger.\n                            forceObstacleBreak = false;\n                        }\n                    }\n                    segments = [{\n                            start: fromPoint,\n                            end: envelopWaypoint\n                        }];\n                }\n                else { // If not enveloping, use standard pivot calculation\n                    pivot = pivotPoint(fromPoint, {\n                        x: dirIsX ? toPoint.x : fromPoint.x,\n                        y: dirIsX ? fromPoint.y : toPoint.y\n                    }, dirIsX);\n                    segments = [{\n                            start: fromPoint,\n                            end: {\n                                x: pivot.x,\n                                y: pivot.y\n                            }\n                        }];\n                    // Pivot before goal, use a waypoint to dodge obstacle\n                    if (pivot[dirIsX ? 'x' : 'y'] !== toPoint[dirIsX ? 'x' : 'y']) {\n                        // Find direction of waypoint\n                        waypointUseMax = getDodgeDirection(pivot.obstacle, pivot, toPoint, !dirIsX, bounds);\n                        // Cut waypoint to hard bounds\n                        limitObstacleToBounds(pivot.obstacle, options.hardBounds);\n                        waypoint = {\n                            x: dirIsX ?\n                                pivot.x :\n                                pivot.obstacle[waypointUseMax ? 'xMax' : 'xMin'] +\n                                    (waypointUseMax ? 1 : -1),\n                            y: dirIsX ?\n                                pivot.obstacle[waypointUseMax ? 'yMax' : 'yMin'] +\n                                    (waypointUseMax ? 1 : -1) :\n                                pivot.y\n                        };\n                        // We're changing direction here, store that to make sure we\n                        // also change direction when adding the last segment array\n                        // after handling waypoint.\n                        dirIsX = !dirIsX;\n                        segments = segments.concat(clearPathTo({\n                            x: pivot.x,\n                            y: pivot.y\n                        }, waypoint, dirIsX));\n                    }\n                }\n                // Get segments for the other direction too\n                // Recursion is our friend\n                segments = segments.concat(clearPathTo(segments[segments.length - 1].end, toPoint, !dirIsX));\n                return segments;\n            }\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Extract point to outside of obstacle in whichever direction is\n             * closest. Returns new point outside obstacle.\n             * @private\n             */\n            function extractFromObstacle(obstacle, point, goalPoint) {\n                var dirIsX = min(obstacle.xMax - point.x, point.x - obstacle.xMin) <\n                    min(obstacle.yMax - point.y, point.y - obstacle.yMin), bounds = {\n                    soft: options.hardBounds,\n                    hard: options.hardBounds\n                }, useMax = getDodgeDirection(obstacle, point, goalPoint, dirIsX, bounds);\n                return dirIsX ? {\n                    y: point.y,\n                    x: obstacle[useMax ? 'xMax' : 'xMin'] + (useMax ? 1 : -1)\n                } : {\n                    x: point.x,\n                    y: obstacle[useMax ? 'yMax' : 'yMin'] + (useMax ? 1 : -1)\n                };\n            }\n            // Cut the obstacle array to soft bounds for optimization in large\n            // datasets.\n            chartObstacles =\n                chartObstacles.slice(startObstacleIx, endObstacleIx + 1);\n            // If an obstacle envelops the end point, move it out of there and add\n            // a little segment to where it was.\n            if ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                extractedEndPoint = extractFromObstacle(chartObstacles[endObstacleIx], end, start);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // If it's still inside one or more obstacles, get out of there by\n            // force-moving towards the start point.\n            while ((endObstacleIx = findObstacleFromPoint(chartObstacles, end)) > -1) {\n                useMax = end[dir] - start[dir] < 0;\n                extractedEndPoint = {\n                    x: end.x,\n                    y: end.y\n                };\n                extractedEndPoint[dir] = chartObstacles[endObstacleIx][useMax ? dir + 'Max' : dir + 'Min'] + (useMax ? 1 : -1);\n                endSegments.push({\n                    end: end,\n                    start: extractedEndPoint\n                });\n                end = extractedEndPoint;\n            }\n            // Find the path\n            segments = clearPathTo(start, end, dirIsX);\n            // Add the end-point segments\n            segments = segments.concat(endSegments.reverse());\n            return {\n                path: pathFromSegments(segments),\n                obstacles: segments\n            };\n        }\n        fastAvoid.requiresObstacles = true;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        // Define the available pathfinding algorithms.\n        // Algorithms take up to 3 arguments: starting point, ending point, and an\n        // options object.\n        var algorithms = {\n            fastAvoid: fastAvoid,\n            straight: straight,\n            simpleConnect: simpleConnect\n        };\n\n        return algorithms;\n    });\n    _registerModule(_modules, 'Gantt/ConnectorsDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Defaults\n         *\n         * */\n        /*\n         @todo:\n             - Document how to write your own algorithms\n             - Consider adding a Point.pathTo method that wraps creating a connection\n               and rendering it\n        */\n        var connectorsDefaults = {\n            /**\n             * The Pathfinder module allows you to define connections between any two\n             * points, represented as lines - optionally with markers for the start\n             * and/or end points. Multiple algorithms are available for calculating how\n             * the connecting lines are drawn.\n             *\n             * Connector functionality requires Highcharts Gantt to be loaded. In Gantt\n             * charts, the connectors are used to draw dependencies between tasks.\n             *\n             * @see [dependency](series.gantt.data.dependency)\n             *\n             * @sample gantt/pathfinder/demo\n             *         Pathfinder connections\n             *\n             * @declare      Highcharts.ConnectorsOptions\n             * @product      gantt\n             * @optionparent connectors\n             */\n            connectors: {\n                /**\n                 * Enable connectors for this chart. Requires Highcharts Gantt.\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     6.2.0\n                 * @apioption connectors.enabled\n                 */\n                /**\n                 * Set the default dash style for this chart's connecting lines.\n                 *\n                 * @type      {string}\n                 * @default   solid\n                 * @since     6.2.0\n                 * @apioption connectors.dashStyle\n                 */\n                /**\n                 * Set the default color for this chart's Pathfinder connecting lines.\n                 * Defaults to the color of the point being connected.\n                 *\n                 * @type      {Highcharts.ColorString}\n                 * @since     6.2.0\n                 * @apioption connectors.lineColor\n                 */\n                /**\n                 * Set the default pathfinder margin to use, in pixels. Some Pathfinder\n                 * algorithms attempt to avoid obstacles, such as other points in the\n                 * chart. These algorithms use this margin to determine how close lines\n                 * can be to an obstacle. The default is to compute this automatically\n                 * from the size of the obstacles in the chart.\n                 *\n                 * To draw connecting lines close to existing points, set this to a low\n                 * number. For more space around existing points, set this number\n                 * higher.\n                 *\n                 * @sample gantt/pathfinder/algorithm-margin\n                 *         Small algorithmMargin\n                 *\n                 * @type      {number}\n                 * @since     6.2.0\n                 * @apioption connectors.algorithmMargin\n                 */\n                /**\n                 * Set the default pathfinder algorithm to use for this chart. It is\n                 * possible to define your own algorithms by adding them to the\n                 * Highcharts.Pathfinder.prototype.algorithms object before the chart\n                 * has been created.\n                 *\n                 * The default algorithms are as follows:\n                 *\n                 * `straight`:      Draws a straight line between the connecting\n                 *                  points. Does not avoid other points when drawing.\n                 *\n                 * `simpleConnect`: Finds a path between the points using right angles\n                 *                  only. Takes only starting/ending points into\n                 *                  account, and will not avoid other points.\n                 *\n                 * `fastAvoid`:     Finds a path between the points using right angles\n                 *                  only. Will attempt to avoid other points, but its\n                 *                  focus is performance over accuracy. Works well with\n                 *                  less dense datasets.\n                 *\n                 * Default value: `straight` is used as default for most series types,\n                 * while `simpleConnect` is used as default for Gantt series, to show\n                 * dependencies between points.\n                 *\n                 * @sample gantt/pathfinder/demo\n                 *         Different types used\n                 *\n                 * @type    {Highcharts.PathfinderTypeValue}\n                 * @default undefined\n                 * @since   6.2.0\n                 */\n                type: 'straight',\n                /**\n                 * The corner radius for the connector line.\n                 *\n                 * @since 11.2.0\n                 */\n                radius: 0,\n                /**\n                 * Set the default pixel width for this chart's Pathfinder connecting\n                 * lines.\n                 *\n                 * @since 6.2.0\n                 */\n                lineWidth: 1,\n                /**\n                 * Marker options for this chart's Pathfinder connectors. Note that\n                 * this option is overridden by the `startMarker` and `endMarker`\n                 * options.\n                 *\n                 * @declare Highcharts.ConnectorsMarkerOptions\n                 * @since   6.2.0\n                 */\n                marker: {\n                    /**\n                     * Set the radius of the connector markers. The default is\n                     * automatically computed based on the algorithmMargin setting.\n                     *\n                     * Setting marker.width and marker.height will override this\n                     * setting.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.radius\n                     */\n                    /**\n                     * Set the width of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.width\n                     */\n                    /**\n                     * Set the height of the connector markers. If not supplied, this\n                     * is inferred from the marker radius.\n                     *\n                     * @type      {number}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.height\n                     */\n                    /**\n                     * Set the color of the connector markers. By default this is the\n                     * same as the connector color.\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.color\n                     */\n                    /**\n                     * Set the line/border color of the connector markers. By default\n                     * this is the same as the marker color.\n                     *\n                     * @type      {Highcharts.ColorString}\n                     * @since     6.2.0\n                     * @apioption connectors.marker.lineColor\n                     */\n                    /**\n                     * Enable markers for the connectors.\n                     */\n                    enabled: false,\n                    /**\n                     * Horizontal alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'center',\n                    /**\n                     * Vertical alignment of the markers relative to the points.\n                     *\n                     * @type {Highcharts.VerticalAlignValue}\n                     */\n                    verticalAlign: 'middle',\n                    /**\n                     * Whether or not to draw the markers inside the points.\n                     */\n                    inside: false,\n                    /**\n                     * Set the line/border width of the pathfinder markers.\n                     */\n                    lineWidth: 1\n                },\n                /**\n                 * Marker options specific to the start markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsStartMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                startMarker: {\n                    /**\n                     * Set the symbol of the connector start markers.\n                     */\n                    symbol: 'diamond'\n                },\n                /**\n                 * Marker options specific to the end markers for this chart's\n                 * Pathfinder connectors. Overrides the generic marker options.\n                 *\n                 * @declare Highcharts.ConnectorsEndMarkerOptions\n                 * @extends connectors.marker\n                 * @since   6.2.0\n                 */\n                endMarker: {\n                    /**\n                     * Set the symbol of the connector end markers.\n                     */\n                    symbol: 'arrow-filled'\n                }\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Override Pathfinder connector options for a series. Requires Highcharts Gantt\n         * to be loaded.\n         *\n         * @declare   Highcharts.SeriesConnectorsOptionsObject\n         * @extends   connectors\n         * @since     6.2.0\n         * @excluding enabled, algorithmMargin\n         * @product   gantt\n         * @apioption plotOptions.series.connectors\n         */\n        /**\n         * Connect to a point. This option can be either a string, referring to the ID\n         * of another point, or an object, or an array of either. If the option is an\n         * array, each element defines a connection.\n         *\n         * @sample gantt/pathfinder/demo\n         *         Different connection types\n         *\n         * @declare   Highcharts.XrangePointConnectorsOptionsObject\n         * @type      {string|Array<string|*>|*}\n         * @extends   plotOptions.series.connectors\n         * @since     6.2.0\n         * @excluding enabled\n         * @product   gantt\n         * @requires  highcharts-gantt\n         * @apioption series.xrange.data.connect\n         */\n        /**\n         * The ID of the point to connect to.\n         *\n         * @type      {string}\n         * @since     6.2.0\n         * @product   gantt\n         * @apioption series.xrange.data.connect.to\n         */\n        ''; // Keeps doclets above in JS file\n\n        return connectorsDefaults;\n    });\n    _registerModule(_modules, 'Gantt/PathfinderComposition.js', [_modules['Gantt/ConnectorsDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (ConnectorsDefaults, D, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setOptions = D.setOptions;\n        var defined = U.defined, error = U.error, merge = U.merge, pushUnique = U.pushUnique;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            var shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            var bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Warn if using legacy options. Copy the options over. Note that this will\n         * still break if using the legacy options in chart.update, addSeries etc.\n         * @private\n         */\n        function warnLegacy(chart) {\n            if (chart.options.pathfinder ||\n                chart.series.reduce(function (acc, series) {\n                    if (series.options) {\n                        merge(true, (series.options.connectors = series.options.connectors ||\n                            {}), series.options.pathfinder);\n                    }\n                    return acc || series.options && series.options.pathfinder;\n                }, false)) {\n                merge(true, (chart.options.connectors = chart.options.connectors || {}), chart.options.pathfinder);\n                error('WARNING: Pathfinder options have been renamed. ' +\n                    'Use \"chart.connectors\" or \"series.connectors\" instead.');\n            }\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var ConnectionComposition;\n        (function (ConnectionComposition) {\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            var composedMembers = [];\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(ChartClass, PathfinderClass, PointClass) {\n                if (pushUnique(composedMembers, ChartClass)) {\n                    // Initialize Pathfinder for charts\n                    ChartClass.prototype.callbacks.push(function (chart) {\n                        var options = chart.options;\n                        if (options.connectors.enabled !== false) {\n                            warnLegacy(chart);\n                            this.pathfinder = new PathfinderClass(this);\n                            this.pathfinder.update(true); // First draw, defer render\n                        }\n                    });\n                }\n                if (pushUnique(composedMembers, PointClass)) {\n                    var pointProto = PointClass.prototype;\n                    pointProto.getMarkerVector = pointGetMarkerVector;\n                    pointProto.getPathfinderAnchorPoint = pointGetPathfinderAnchorPoint;\n                    pointProto.getRadiansToVector = pointGetRadiansToVector;\n                }\n                if (pushUnique(composedMembers, setOptions)) {\n                    // Set default Pathfinder options\n                    setOptions(ConnectorsDefaults);\n                }\n            }\n            ConnectionComposition.compose = compose;\n            /**\n             * Get coordinates of anchor point for pathfinder connection.\n             *\n             * @private\n             * @function Highcharts.Point#getPathfinderAnchorPoint\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Connection options for position on point.\n             *\n             * @return {Highcharts.PositionObject}\n             *         An object with x/y properties for the position. Coordinates are\n             *         in plot values, not relative to point.\n             */\n            function pointGetPathfinderAnchorPoint(markerOptions) {\n                var bb = getPointBB(this);\n                var x, y;\n                switch (markerOptions.align) { // eslint-disable-line default-case\n                    case 'right':\n                        x = 'xMax';\n                        break;\n                    case 'left':\n                        x = 'xMin';\n                }\n                switch (markerOptions.verticalAlign) { // eslint-disable-line default-case\n                    case 'top':\n                        y = 'yMin';\n                        break;\n                    case 'bottom':\n                        y = 'yMax';\n                }\n                return {\n                    x: x ? bb[x] : (bb.xMin + bb.xMax) / 2,\n                    y: y ? bb[y] : (bb.yMin + bb.yMax) / 2\n                };\n            }\n            /**\n             * Utility to get the angle from one point to another.\n             *\n             * @private\n             * @function Highcharts.Point#getRadiansToVector\n             *\n             * @param {Highcharts.PositionObject} v1\n             *        The first vector, as an object with x/y properties.\n             *\n             * @param {Highcharts.PositionObject} v2\n             *        The second vector, as an object with x/y properties.\n             *\n             * @return {number}\n             *         The angle in degrees\n             */\n            function pointGetRadiansToVector(v1, v2) {\n                var box;\n                if (!defined(v2)) {\n                    box = getPointBB(this);\n                    if (box) {\n                        v2 = {\n                            x: (box.xMin + box.xMax) / 2,\n                            y: (box.yMin + box.yMax) / 2\n                        };\n                    }\n                }\n                return Math.atan2(v2.y - v1.y, v1.x - v2.x);\n            }\n            /**\n             * Utility to get the position of the marker, based on the path angle and\n             * the marker's radius.\n             *\n             * @private\n             * @function Highcharts.Point#getMarkerVector\n             *\n             * @param {number} radians\n             *        The angle in radians from the point center to another vector.\n             *\n             * @param {number} markerRadius\n             *        The radius of the marker, to calculate the additional distance to\n             *        the center of the marker.\n             *\n             * @param {Object} anchor\n             *        The anchor point of the path and marker as an object with x/y\n             *        properties.\n             *\n             * @return {Object}\n             *         The marker vector as an object with x/y properties.\n             */\n            function pointGetMarkerVector(radians, markerRadius, anchor) {\n                var twoPI = Math.PI * 2.0, bb = getPointBB(this), rectWidth = bb.xMax - bb.xMin, rectHeight = bb.yMax - bb.yMin, rAtan = Math.atan2(rectHeight, rectWidth), rectHalfWidth = rectWidth / 2.0, rectHalfHeight = rectHeight / 2.0, rectHorizontalCenter = bb.xMin + rectHalfWidth, rectVerticalCenter = bb.yMin + rectHalfHeight, edgePoint = {\n                    x: rectHorizontalCenter,\n                    y: rectVerticalCenter\n                };\n                var theta = radians, tanTheta = 1, leftOrRightRegion = false, xFactor = 1, yFactor = 1;\n                while (theta < -Math.PI) {\n                    theta += twoPI;\n                }\n                while (theta > Math.PI) {\n                    theta -= twoPI;\n                }\n                tanTheta = Math.tan(theta);\n                if ((theta > -rAtan) && (theta <= rAtan)) {\n                    // Right side\n                    yFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else if (theta > rAtan && theta <= (Math.PI - rAtan)) {\n                    // Top side\n                    yFactor = -1;\n                }\n                else if (theta > (Math.PI - rAtan) || theta <= -(Math.PI - rAtan)) {\n                    // Left side\n                    xFactor = -1;\n                    leftOrRightRegion = true;\n                }\n                else {\n                    // Bottom side\n                    xFactor = -1;\n                }\n                // Correct the edgePoint according to the placement of the marker\n                if (leftOrRightRegion) {\n                    edgePoint.x += xFactor * (rectHalfWidth);\n                    edgePoint.y += yFactor * (rectHalfWidth) * tanTheta;\n                }\n                else {\n                    edgePoint.x += xFactor * (rectHeight / (2.0 * tanTheta));\n                    edgePoint.y += yFactor * (rectHalfHeight);\n                }\n                if (anchor.x !== rectHorizontalCenter) {\n                    edgePoint.x = anchor.x;\n                }\n                if (anchor.y !== rectVerticalCenter) {\n                    edgePoint.y = anchor.y;\n                }\n                return {\n                    x: edgePoint.x + (markerRadius * Math.cos(theta)),\n                    y: edgePoint.y - (markerRadius * Math.sin(theta))\n                };\n            }\n        })(ConnectionComposition || (ConnectionComposition = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ConnectionComposition;\n    });\n    _registerModule(_modules, 'Gantt/Pathfinder.js', [_modules['Gantt/Connection.js'], _modules['Gantt/PathfinderAlgorithms.js'], _modules['Gantt/PathfinderComposition.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (Connection, PathfinderAlgorithms, PathfinderComposition, Point, U) {\n        /* *\n         *\n         *  (c) 2016 Highsoft AS\n         *  Authors: Øystein Moseng, Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent, defined = U.defined, pick = U.pick, splat = U.splat;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var max = Math.max, min = Math.min;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Get point bounding box using plotX/plotY and shapeArgs. If using\n         * graphic.getBBox() directly, the bbox will be affected by animation.\n         *\n         * @private\n         * @function\n         *\n         * @param {Highcharts.Point} point\n         *        The point to get BB of.\n         *\n         * @return {Highcharts.Dictionary<number>|null}\n         *         Result xMax, xMin, yMax, yMin.\n         */\n        function getPointBB(point) {\n            var shapeArgs = point.shapeArgs;\n            // Prefer using shapeArgs (columns)\n            if (shapeArgs) {\n                return {\n                    xMin: shapeArgs.x || 0,\n                    xMax: (shapeArgs.x || 0) + (shapeArgs.width || 0),\n                    yMin: shapeArgs.y || 0,\n                    yMax: (shapeArgs.y || 0) + (shapeArgs.height || 0)\n                };\n            }\n            // Otherwise use plotX/plotY and bb\n            var bb = point.graphic && point.graphic.getBBox();\n            return bb ? {\n                xMin: point.plotX - bb.width / 2,\n                xMax: point.plotX + bb.width / 2,\n                yMin: point.plotY - bb.height / 2,\n                yMax: point.plotY + bb.height / 2\n            } : null;\n        }\n        /**\n         * Compute smallest distance between two rectangles.\n         * @private\n         */\n        function calculateObstacleDistance(a, b, bbMargin) {\n            // Count the distance even if we are slightly off\n            var margin = pick(bbMargin, 10), yOverlap = a.yMax + margin > b.yMin - margin &&\n                a.yMin - margin < b.yMax + margin, xOverlap = a.xMax + margin > b.xMin - margin &&\n                a.xMin - margin < b.xMax + margin, xDistance = yOverlap ? (a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax) : Infinity, yDistance = xOverlap ? (a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax) : Infinity;\n            // If the rectangles collide, try recomputing with smaller margin.\n            // If they collide anyway, discard the obstacle.\n            if (xOverlap && yOverlap) {\n                return (margin ?\n                    calculateObstacleDistance(a, b, Math.floor(margin / 2)) :\n                    Infinity);\n            }\n            return min(xDistance, yDistance);\n        }\n        /**\n         * Calculate margin to place around obstacles for the pathfinder in pixels.\n         * Returns a minimum of 1 pixel margin.\n         *\n         * @private\n         * @function\n         *\n         * @param {Array<object>} obstacles\n         *        Obstacles to calculate margin from.\n         *\n         * @return {number}\n         *         The calculated margin in pixels. At least 1.\n         */\n        function calculateObstacleMargin(obstacles) {\n            var len = obstacles.length, distances = [];\n            var onstacleDistance;\n            // Go over all obstacles and compare them to the others.\n            for (var i = 0; i < len; ++i) {\n                // Compare to all obstacles ahead. We will already have compared this\n                // obstacle to the ones before.\n                for (var j = i + 1; j < len; ++j) {\n                    onstacleDistance =\n                        calculateObstacleDistance(obstacles[i], obstacles[j]);\n                    // TODO: Magic number 80\n                    if (onstacleDistance < 80) { // Ignore large distances\n                        distances.push(onstacleDistance);\n                    }\n                }\n            }\n            // Ensure we always have at least one value, even in very spaceous charts\n            distances.push(80);\n            return max(Math.floor(distances.sort(function (a, b) {\n                return (a - b);\n            })[\n            // Discard first 10% of the relevant distances, and then grab\n            // the smallest one.\n            Math.floor(distances.length / 10)] / 2 - 1 // Divide the distance by 2 and subtract 1.\n            ), 1 // 1 is the minimum margin\n            );\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The Pathfinder class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pathfinder\n         *\n         * @param {Highcharts.Chart} chart\n         *        The chart to operate on.\n         */\n        var Pathfinder = /** @class */ (function () {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            function Pathfinder(chart) {\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                this.chart = void 0;\n                this.chartObstacles = void 0;\n                this.chartObstacleMetrics = void 0;\n                this.connections = void 0;\n                this.group = void 0;\n                this.lineObstacles = void 0;\n                this.init(chart);\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            Pathfinder.compose = function (ChartClass, PointClass) {\n                PathfinderComposition.compose(ChartClass, Pathfinder, PointClass);\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initialize the Pathfinder object.\n             *\n             * @function Highcharts.Pathfinder#init\n             *\n             * @param {Highcharts.Chart} chart\n             *        The chart context.\n             */\n            Pathfinder.prototype.init = function (chart) {\n                // Initialize pathfinder with chart context\n                this.chart = chart;\n                // Init connection reference list\n                this.connections = [];\n                // Recalculate paths/obstacles on chart redraw\n                addEvent(chart, 'redraw', function () {\n                    this.pathfinder.update();\n                });\n            };\n            /**\n             * Update Pathfinder connections from scratch.\n             *\n             * @function Highcharts.Pathfinder#update\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer rendering of connections until\n             *        series.afterAnimate event has fired. Used on first render.\n             */\n            Pathfinder.prototype.update = function (deferRender) {\n                var chart = this.chart, pathfinder = this, oldConnections = pathfinder.connections;\n                // Rebuild pathfinder connections from options\n                pathfinder.connections = [];\n                chart.series.forEach(function (series) {\n                    if (series.visible && !series.options.isInternal) {\n                        series.points.forEach(function (point) {\n                            var _a;\n                            var ganttPointOptions = point.options;\n                            // For Gantt series the connect could be\n                            // defined as a dependency\n                            if (ganttPointOptions && ganttPointOptions.dependency) {\n                                ganttPointOptions.connect = ganttPointOptions\n                                    .dependency;\n                            }\n                            var connects = (((_a = point.options) === null || _a === void 0 ? void 0 : _a.connect) &&\n                                splat(point.options.connect));\n                            var to;\n                            if (point.visible && point.isInside !== false && connects) {\n                                connects.forEach(function (connect) {\n                                    to = chart.get(typeof connect === 'string' ?\n                                        connect : connect.to);\n                                    if (to instanceof Point &&\n                                        to.series.visible &&\n                                        to.visible &&\n                                        to.isInside !== false) {\n                                        // Add new connection\n                                        pathfinder.connections.push(new Connection(point, // From\n                                        to, typeof connect === 'string' ?\n                                            {} :\n                                            connect));\n                                    }\n                                });\n                            }\n                        });\n                    }\n                });\n                // Clear connections that should not be updated, and move old info over\n                // to new connections.\n                for (var j = 0, k = void 0, found = void 0, lenOld = oldConnections.length, lenNew = pathfinder.connections.length; j < lenOld; ++j) {\n                    found = false;\n                    var oldCon = oldConnections[j];\n                    for (k = 0; k < lenNew; ++k) {\n                        var newCon = pathfinder.connections[k];\n                        if ((oldCon.options && oldCon.options.type) ===\n                            (newCon.options && newCon.options.type) &&\n                            oldCon.fromPoint === newCon.fromPoint &&\n                            oldCon.toPoint === newCon.toPoint) {\n                            newCon.graphics = oldCon.graphics;\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        oldCon.destroy();\n                    }\n                }\n                // Clear obstacles to force recalculation. This must be done on every\n                // redraw in case positions have changed. Recalculation is handled in\n                // Connection.getPath on demand.\n                delete this.chartObstacles;\n                delete this.lineObstacles;\n                // Draw the pending connections\n                pathfinder.renderConnections(deferRender);\n            };\n            /**\n             * Draw the chart's connecting paths.\n             *\n             * @function Highcharts.Pathfinder#renderConnections\n             *\n             * @param {boolean} [deferRender]\n             *        Whether or not to defer render until series animation is finished.\n             *        Used on first render.\n             */\n            Pathfinder.prototype.renderConnections = function (deferRender) {\n                if (deferRender) {\n                    // Render after series are done animating\n                    this.chart.series.forEach(function (series) {\n                        var render = function () {\n                            // Find pathfinder connections belonging to this series\n                            // that haven't rendered, and render them now.\n                            var pathfinder = series.chart.pathfinder, conns = pathfinder && pathfinder.connections || [];\n                            conns.forEach(function (connection) {\n                                if (connection.fromPoint &&\n                                    connection.fromPoint.series === series) {\n                                    connection.render();\n                                }\n                            });\n                            if (series.pathfinderRemoveRenderEvent) {\n                                series.pathfinderRemoveRenderEvent();\n                                delete series.pathfinderRemoveRenderEvent;\n                            }\n                        };\n                        if (series.options.animation === false) {\n                            render();\n                        }\n                        else {\n                            series.pathfinderRemoveRenderEvent = addEvent(series, 'afterAnimate', render);\n                        }\n                    });\n                }\n                else {\n                    // Go through connections and render them\n                    this.connections.forEach(function (connection) {\n                        connection.render();\n                    });\n                }\n            };\n            /**\n             * Get obstacles for the points in the chart. Does not include connecting\n             * lines from Pathfinder. Applies algorithmMargin to the obstacles.\n             *\n             * @function Highcharts.Pathfinder#getChartObstacles\n             *\n             * @param {Object} options\n             *        Options for the calculation. Currenlty only\n             *        options.algorithmMargin.\n             *\n             * @return {Array<object>}\n             *         An array of calculated obstacles. Each obstacle is defined as an\n             *         object with xMin, xMax, yMin and yMax properties.\n             */\n            Pathfinder.prototype.getChartObstacles = function (options) {\n                var series = this.chart.series, margin = pick(options.algorithmMargin, 0);\n                var obstacles = [], calculatedMargin;\n                for (var i = 0, sLen = series.length; i < sLen; ++i) {\n                    if (series[i].visible && !series[i].options.isInternal) {\n                        for (var j = 0, pLen = series[i].points.length, bb = void 0, point = void 0; j < pLen; ++j) {\n                            point = series[i].points[j];\n                            if (point.visible) {\n                                bb = getPointBB(point);\n                                if (bb) {\n                                    obstacles.push({\n                                        xMin: bb.xMin - margin,\n                                        xMax: bb.xMax + margin,\n                                        yMin: bb.yMin - margin,\n                                        yMax: bb.yMax + margin\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n                // Sort obstacles by xMin for optimization\n                obstacles = obstacles.sort(function (a, b) {\n                    return a.xMin - b.xMin;\n                });\n                // Add auto-calculated margin if the option is not defined\n                if (!defined(options.algorithmMargin)) {\n                    calculatedMargin =\n                        options.algorithmMargin =\n                            calculateObstacleMargin(obstacles);\n                    obstacles.forEach(function (obstacle) {\n                        obstacle.xMin -= calculatedMargin;\n                        obstacle.xMax += calculatedMargin;\n                        obstacle.yMin -= calculatedMargin;\n                        obstacle.yMax += calculatedMargin;\n                    });\n                }\n                return obstacles;\n            };\n            /**\n             * Utility function to get metrics for obstacles:\n             * - Widest obstacle width\n             * - Tallest obstacle height\n             *\n             * @function Highcharts.Pathfinder#getObstacleMetrics\n             *\n             * @param {Array<object>} obstacles\n             *        An array of obstacles to inspect.\n             *\n             * @return {Object}\n             *         The calculated metrics, as an object with maxHeight and maxWidth\n             *         properties.\n             */\n            Pathfinder.prototype.getObstacleMetrics = function (obstacles) {\n                var maxWidth = 0, maxHeight = 0, width, height, i = obstacles.length;\n                while (i--) {\n                    width = obstacles[i].xMax - obstacles[i].xMin;\n                    height = obstacles[i].yMax - obstacles[i].yMin;\n                    if (maxWidth < width) {\n                        maxWidth = width;\n                    }\n                    if (maxHeight < height) {\n                        maxHeight = height;\n                    }\n                }\n                return {\n                    maxHeight: maxHeight,\n                    maxWidth: maxWidth\n                };\n            };\n            /**\n             * Utility to get which direction to start the pathfinding algorithm\n             * (X vs Y), calculated from a set of marker options.\n             *\n             * @function Highcharts.Pathfinder#getAlgorithmStartDirection\n             *\n             * @param {Highcharts.ConnectorsMarkerOptions} markerOptions\n             *        Marker options to calculate from.\n             *\n             * @return {boolean}\n             *         Returns true for X, false for Y, and undefined for autocalculate.\n             */\n            Pathfinder.prototype.getAlgorithmStartDirection = function (markerOptions) {\n                var xCenter = markerOptions.align !== 'left' &&\n                    markerOptions.align !== 'right', yCenter = markerOptions.verticalAlign !== 'top' &&\n                    markerOptions.verticalAlign !== 'bottom';\n                return xCenter ?\n                    (yCenter ? void 0 : false) : // When x is centered\n                    (yCenter ? true : void 0); // When x is off-center\n            };\n            return Pathfinder;\n        }());\n        /**\n         * @name Highcharts.Pathfinder#algorithms\n         * @type {Highcharts.Dictionary<Function>}\n         */\n        Pathfinder.prototype.algorithms = PathfinderAlgorithms;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The default pathfinder algorithm to use for a chart. It is possible to define\n         * your own algorithms by adding them to the\n         * `Highcharts.Pathfinder.prototype.algorithms`\n         * object before the chart has been created.\n         *\n         * The default algorithms are as follows:\n         *\n         * `straight`:      Draws a straight line between the connecting\n         *                  points. Does not avoid other points when drawing.\n         *\n         * `simpleConnect`: Finds a path between the points using right angles\n         *                  only. Takes only starting/ending points into\n         *                  account, and will not avoid other points.\n         *\n         * `fastAvoid`:     Finds a path between the points using right angles\n         *                  only. Will attempt to avoid other points, but its\n         *                  focus is performance over accuracy. Works well with\n         *                  less dense datasets.\n         *\n         * @typedef {\"fastAvoid\"|\"simpleConnect\"|\"straight\"|string} Highcharts.PathfinderTypeValue\n         */\n        ''; // Keeps doclets above in JS file\n\n        return Pathfinder;\n    });\n    _registerModule(_modules, 'Extensions/ArrowSymbols.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2017 Highsoft AS\n         *  Authors: Lars A. V. Cabrera\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates an arrow symbol. Like a triangle, except not filled.\n         * ```\n         *                   o\n         *             o\n         *       o\n         * o\n         *       o\n         *             o\n         *                   o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrow(x, y, w, h) {\n            return [\n                ['M', x, y + h / 2],\n                ['L', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h]\n            ];\n        }\n        /**\n         * Creates a half-width arrow symbol. Like a triangle, except not filled.\n         * ```\n         *       o\n         *    o\n         * o\n         *    o\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the arrow\n         *\n         * @param {number} y\n         *        y position of the arrow\n         *\n         * @param {number} w\n         *        width of the arrow\n         *\n         * @param {number} h\n         *        height of the arrow\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function arrowHalf(x, y, w, h) {\n            return arrow(x, y, w / 2, h);\n        }\n        /**\n         * @private\n         */\n        function compose(SVGRendererClass) {\n            if (U.pushUnique(composedMembers, SVGRendererClass)) {\n                var symbols = SVGRendererClass.prototype.symbols;\n                symbols.arrow = arrow;\n                symbols['arrow-filled'] = triangleLeft;\n                symbols['arrow-filled-half'] = triangleLeftHalf;\n                symbols['arrow-half'] = arrowHalf;\n                symbols['triangle-left'] = triangleLeft;\n                symbols['triangle-left-half'] = triangleLeftHalf;\n            }\n        }\n        /**\n         * Creates a left-oriented triangle.\n         * ```\n         *             o\n         *       ooooooo\n         * ooooooooooooo\n         *       ooooooo\n         *             o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeft(x, y, w, h) {\n            return [\n                ['M', x + w, y],\n                ['L', x, y + h / 2],\n                ['L', x + w, y + h],\n                ['Z']\n            ];\n        }\n        /**\n         * Creates a half-width, left-oriented triangle.\n         * ```\n         *       o\n         *    oooo\n         * ooooooo\n         *    oooo\n         *       o\n         * ```\n         *\n         * @private\n         * @function\n         *\n         * @param {number} x\n         *        x position of the triangle\n         *\n         * @param {number} y\n         *        y position of the triangle\n         *\n         * @param {number} w\n         *        width of the triangle\n         *\n         * @param {number} h\n         *        height of the triangle\n         *\n         * @return {Highcharts.SVGPathArray}\n         *         Path array\n         */\n        function triangleLeftHalf(x, y, w, h) {\n            return triangleLeft(x, y, w / 2, h);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var ArrowSymbols = {\n            compose: compose\n        };\n\n        return ArrowSymbols;\n    });\n    _registerModule(_modules, 'masters/modules/pathfinder.src.js', [_modules['Core/Globals.js'], _modules['Gantt/Pathfinder.js'], _modules['Extensions/ArrowSymbols.js']], function (Highcharts, Pathfinder, ArrowSymbols) {\n\n        var G = Highcharts;\n        G.Pathfinder = Pathfinder;\n        ArrowSymbols.compose(G.SVGRenderer);\n        Pathfinder.compose(G.Chart, G.Point);\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","H","U","defined","error","merge","objectEach","deg2rad","max","Math","min","Connection","from","to","options","chart","fromPoint","graphics","pathfinder","toPoint","init","prototype","series","renderPath","attribs","animation","styledMode","animate","forExport","anim","pathGraphic","connection","group","renderer","g","addClass","attr","zIndex","add","seriesGroup","translate","plotLeft","plotTop","opacity","d","addMarker","type","markerVector","radians","rotation","box","width","height","pathVector","segment","point","anchor","getPathfinderAnchorPoint","enabled","length","x","y","getRadiansToVector","getMarkerVector","radius","rotationOriginX","rotationOriginY","symbol","colorIndex","fill","color","stroke","lineColor","lineWidth","getPath","algorithm","algorithms","chartObstacles","obstacles","requiresObstacles","getChartObstacles","connectors","algorithmMargin","chartObstacleMetrics","getObstacleMetrics","startMarker","endMarker","lineObstacles","obstacleMetrics","hardBounds","xMin","xMax","plotWidth","yMin","yMax","plotHeight","obstacleOptions","margin","startDirectionX","getAlgorithmStartDirection","render","dashStyle","dashstyle","marker","ceil","pathResult","concat","destroy","val","applyRadius","r","i","push","prevSeg","nextSeg","x1","y1","x2","y2","directionX","directionY","abs","getLinkPath","pathParams","_a","_b","inverted","parentVisible","straight","curved","offset","_c","PathUtilities","pick","findLastObstacleBefore","startIx","cursor","cmp","left","right","findObstacleFromPoint","obstacle","pathFromSegments","segments","start","end","limitObstacleToBounds","bounds","simpleConnect","endSegment","startObstacle","waypoint","useMax","endPoint","startObstacleIx","endObstacleIx","dir","copyFromPoint","fromKey","toKey","getMeOut","direction","prevWaypoint","waypoint2","fastAvoid","dirIsX","extractedEndPoint","endSegments","metrics","softMinX","maxWidth","softMaxX","softMinY","maxHeight","softMaxY","forceObstacleBreak","pivotPoint","directionIsX","firstPoint","lastPoint","highestPoint","lowestPoint","searchDirection","getDodgeDirection","softBounds","soft","hard","toPointMax","toPointMin","maxOutOfSoftBounds","minOutOfSoftBounds","maxOutOfHardBounds","minOutOfHardBounds","minDistance","maxDistance","minPivot","maxPivot","slice","clearPathTo","pivot","waypointUseMax","envelopingObstacle","secondEnvelopingObstacle","envelopWaypoint","obstacleMargin","reverse","align","verticalAlign","inside","ConnectorsDefaults","D","ConnectionComposition","setOptions","pushUnique","getPointBB","shapeArgs","bb","graphic","getBBox","plotX","plotY","composedMembers","pointGetPathfinderAnchorPoint","markerOptions","pointGetRadiansToVector","v1","v2","atan2","pointGetMarkerVector","markerRadius","twoPI","PI","rectWidth","rectHeight","rAtan","rectHalfWidth","rectHalfHeight","rectHorizontalCenter","rectVerticalCenter","edgePoint","theta","tanTheta","leftOrRightRegion","xFactor","yFactor","tan","cos","sin","compose","ChartClass","PathfinderClass","PointClass","callbacks","reduce","acc","update","pointProto","PathfinderAlgorithms","PathfinderComposition","Point","addEvent","splat","Pathfinder","connections","deferRender","oldConnections","forEach","visible","isInternal","points","ganttPointOptions","dependency","connect","connects","isInside","get","j","k","found","lenOld","lenNew","oldCon","newCon","renderConnections","conns","pathfinderRemoveRenderEvent","calculatedMargin","sLen","pLen","sort","a","b","calculateObstacleMargin","onstacleDistance","len","distances","calculateObstacleDistance","bbMargin","yOverlap","xOverlap","xDistance","Infinity","yDistance","floor","xCenter","yCenter","arrow","w","h","arrowHalf","triangleLeft","triangleLeftHalf","SVGRendererClass","symbols","ArrowSymbols","G","SVGRenderer","Chart"],"mappings":"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"}